
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for server/src/generated/prisma/runtime/library.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../../index.html">All files</a> / <a href="index.html">server/src/generated/prisma/runtime</a> library.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">74.02% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>57/77</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">56.05% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>472/842</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">29.7% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>281/946</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">74.02% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>57/77</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line medium'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a>
<a name='L86'></a><a href='#L86'>86</a>
<a name='L87'></a><a href='#L87'>87</a>
<a name='L88'></a><a href='#L88'>88</a>
<a name='L89'></a><a href='#L89'>89</a>
<a name='L90'></a><a href='#L90'>90</a>
<a name='L91'></a><a href='#L91'>91</a>
<a name='L92'></a><a href='#L92'>92</a>
<a name='L93'></a><a href='#L93'>93</a>
<a name='L94'></a><a href='#L94'>94</a>
<a name='L95'></a><a href='#L95'>95</a>
<a name='L96'></a><a href='#L96'>96</a>
<a name='L97'></a><a href='#L97'>97</a>
<a name='L98'></a><a href='#L98'>98</a>
<a name='L99'></a><a href='#L99'>99</a>
<a name='L100'></a><a href='#L100'>100</a>
<a name='L101'></a><a href='#L101'>101</a>
<a name='L102'></a><a href='#L102'>102</a>
<a name='L103'></a><a href='#L103'>103</a>
<a name='L104'></a><a href='#L104'>104</a>
<a name='L105'></a><a href='#L105'>105</a>
<a name='L106'></a><a href='#L106'>106</a>
<a name='L107'></a><a href='#L107'>107</a>
<a name='L108'></a><a href='#L108'>108</a>
<a name='L109'></a><a href='#L109'>109</a>
<a name='L110'></a><a href='#L110'>110</a>
<a name='L111'></a><a href='#L111'>111</a>
<a name='L112'></a><a href='#L112'>112</a>
<a name='L113'></a><a href='#L113'>113</a>
<a name='L114'></a><a href='#L114'>114</a>
<a name='L115'></a><a href='#L115'>115</a>
<a name='L116'></a><a href='#L116'>116</a>
<a name='L117'></a><a href='#L117'>117</a>
<a name='L118'></a><a href='#L118'>118</a>
<a name='L119'></a><a href='#L119'>119</a>
<a name='L120'></a><a href='#L120'>120</a>
<a name='L121'></a><a href='#L121'>121</a>
<a name='L122'></a><a href='#L122'>122</a>
<a name='L123'></a><a href='#L123'>123</a>
<a name='L124'></a><a href='#L124'>124</a>
<a name='L125'></a><a href='#L125'>125</a>
<a name='L126'></a><a href='#L126'>126</a>
<a name='L127'></a><a href='#L127'>127</a>
<a name='L128'></a><a href='#L128'>128</a>
<a name='L129'></a><a href='#L129'>129</a>
<a name='L130'></a><a href='#L130'>130</a>
<a name='L131'></a><a href='#L131'>131</a>
<a name='L132'></a><a href='#L132'>132</a>
<a name='L133'></a><a href='#L133'>133</a>
<a name='L134'></a><a href='#L134'>134</a>
<a name='L135'></a><a href='#L135'>135</a>
<a name='L136'></a><a href='#L136'>136</a>
<a name='L137'></a><a href='#L137'>137</a>
<a name='L138'></a><a href='#L138'>138</a>
<a name='L139'></a><a href='#L139'>139</a>
<a name='L140'></a><a href='#L140'>140</a>
<a name='L141'></a><a href='#L141'>141</a>
<a name='L142'></a><a href='#L142'>142</a>
<a name='L143'></a><a href='#L143'>143</a>
<a name='L144'></a><a href='#L144'>144</a>
<a name='L145'></a><a href='#L145'>145</a>
<a name='L146'></a><a href='#L146'>146</a>
<a name='L147'></a><a href='#L147'>147</a></td><td class="line-coverage quiet"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">3x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">234x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">239x</span>
<span class="cline-any cline-yes">239x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">464x</span>
<span class="cline-any cline-yes">464x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">348x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">118x</span>
<span class="cline-any cline-yes">118x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">118x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">3x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">118x</span>
<span class="cline-any cline-yes">118x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">3x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">3x</span>
<span class="cline-any cline-yes">3x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">241x</span>
<span class="cline-any cline-yes">241x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">&nbsp;
/* !!! This is code generated by Prisma. Do not edit directly. !!!
/* eslint-disable */
"use strict";var xu=Object.create;var Vt=Object.defineProperty;var vu=Object.getOwnPropertyDescriptor;var Pu=Object.getOwnPropertyNames;var Tu=Object.getPrototypeOf,Su=Object.prototype.hasOwnProperty;var Oo=(e,r)=&gt;()=&gt;(e&amp;&amp;(r=e(e=0)),r);var ne=(e,r)=&gt;()=&gt;(r||e((r={exports:{}}).exports,r),r.exports),tr=(e,r)=&gt;{for(var t in r)Vt(e,t,{get:r[t],enumerable:!0})},ko=(e,r,t,n)=&gt;{if(r&amp;&amp;typeof r=="object"||typeof r=="function")for(let i of Pu(r))!Su.call(e,i)&amp;&amp;i!==t&amp;&amp;Vt(e,i,{get:()=&gt;r[i],enumerable:!(n=vu(r,i))||n.<span class="branch-0 cbranch-no" title="branch not covered" >enumerable});r</span>eturn e};var A=(e,r,t)=&gt;(t=e!=null?xu(Tu(e)):{},ko(r||!e||!e.__esModule?Vt(t,"default",{value:e,enumerable:!0}):t,e)),Ru=e=&gt;ko(Vt({},<span class="branch-0 cbranch-no" title="branch not covered" >"__esModule",{<span class="branch-0 cbranch-no" title="branch not covered" ></span>value:!</span>0}),e);var hi=ne((Mg,os)=&gt;{<span class="branch-0 cbranch-no" title="branch not covered" >"use strict";os.exports=(</span>e,r=process.argv)=&gt;{let t=e.startsWith("-")?"":e.length===1?"-":"--",n=r.indexOf(t+e),i=r.indexOf("--");return n!==-1&amp;&amp;(i===<span class="branch-0 cbranch-no" title="branch not covered" >-1||n&lt;i</span>)}});var ls=ne(($g,as)=&gt;{"use strict";var <span class="branch-0 cbranch-no" title="branch not covered" >Vc=require("</span>node:os"),ss=require("node:tty"),de=hi(<span class="branch-0 cbranch-no" title="branch not covered" >),{env:G}=process,Qe;de("no-color")||de("no-colors")||de("color=false")||de("color=never")</span>?Qe=0:(de(<span class="branch-0 cbranch-no" title="branch not covered" >"color")||d</span>e("colors")||de("color=true")||de("color=always"))&amp;&amp;(Qe=1);<span class="branch-0 cbranch-no" title="branch not covered" >"FORCE_COLOR"in G</span>&amp;&amp;(G.FORCE_COLOR==="true"?Qe=1:G.<span class="branch-0 cbranch-no" title="branch not covered" >FORCE_COLOR==="false"?Q</span>e=0:<span class="branch-0 cbranch-no" title="branch not covered" >Qe=G.FORCE_COLOR.l</span>ength===<span class="branch-0 cbranch-no" title="branch not covered" >0?1:Math.m</span>in(<span class="branch-0 cbranch-no" title="branch not covered" >parseInt(G</span>.FORCE_COLOR,<span class="branch-0 cbranch-no" title="branch not covered" >10),3));function y</span>i(e){<span class="branch-0 cbranch-no" title="branch not covered" >return e===0?!1:{level:e,hasBasic:!0,has256:e&gt;=2,has16m:e&gt;=3}}function b</span>i(e,<span class="branch-0 cbranch-no" title="branch not covered" >r){if(Qe===0)return 0;if(de("color=16m")||de("color=full")||de("color=truecolor"))return 3;if(de("color=256")</span>)return 2;<span class="branch-0 cbranch-no" title="branch not covered" >if(e&amp;&amp;!r&amp;&amp;Qe===void 0)return 0;let t=Qe||0;if(G</span>.TERM==="dumb")<span class="branch-0 cbranch-no" title="branch not covered" >return t;if(p</span>rocess.<span class="branch-0 cbranch-no" title="branch not covered" >platform==="win32"){let n=Vc.release().split(".");return Number(n[0])&gt;=10&amp;&amp;Number(n[2])&gt;=10586?Number(n[2])&gt;=14931?3:2:1}</span>if("CI"in G)return[<span class="branch-0 cbranch-no" title="branch not covered" >"TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","GITHUB_ACTIONS","BUILDKITE"].some(n=&gt;n in G)||G</span>.CI_NAME==="codeship"?1:t;if("TEAMCITY_VERSION"in G)return/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(G.TEAMCITY_VERSION)?1:0;if(G.COLORTERM==="truecolor")return 3;if(<span class="fstat-no" title="function not covered" >"TERM_PROGRAM"in G){let n=parseInt((G.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(G.TERM_PROGRAM){case"iTerm.app":return n&gt;=3?3:2;case"Apple_Terminal":return 2</span>}}return/-256(color)?$/i.test(G.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(G.TERM)||<span class="branch-0 cbranch-no" title="branch not covered" >"COLORTERM"in G?1:t}function jc(e</span>){let r=bi(e,e&amp;&amp;e.isTTY);return yi(r)}as.exports={<span class="branch-0 cbranch-no" title="branch not covered" >supportsColor:j</span>c,stdout:yi(bi(!0,ss.isatty(1))),<span class="branch-0 cbranch-no" title="branch not covered" >stderr:yi(bi(!0,s</span>s.isatty(2)))}});var ps=ne((qg,<span class="branch-0 cbranch-no" title="branch not covered" >cs)=&gt;{"use strict";var Bc=ls(),br=hi();function us(e){<span class="branch-0 cbranch-no" title="branch not covered" >if(/</span>^\d{3,4}$/.test(e)){let t=/(\d{1,2})(\d{2})/.exec(e)||[];return{major:0,minor:parseInt(t[1],10),patch:parseInt(t[2],10)}}let r=(e||"").split(".").map(t=&gt;parseInt(t,10));return{major:r[0],minor:r[1],patch:r[2]}}function Ei(e){let{CI:<span class="branch-0 cbranch-no" title="branch not covered" >r</span>,FORCE_HYPERLINK:t</span>,NETLIFY:n,TEAMCITY_VERSION:i,TERM_PROGRAM:o,TERM_PROGRAM_VERSION:s,VTE_VERSION:a,TERM:l}=process.env;if(t)return!(t.length&gt;0&amp;&amp;parseInt(t,10)===0);if(br("no-hyperlink")||br("no-hyperlinks")||br("hyperlink=false")||br("hyperlink=never"))return!1;if(br("hyperlink=true")||br("hyperlink=always")||n)return!0;if(!Bc.supportsColor(e)||e&amp;&amp;!e.isTTY)return!1;if("WT_SESSION"in process.env)return!0;if(process.platform==="win32"||r||i)return!1;if(o){let u=us(s||"");switch(o){case"iTerm.app":return u.major===3?u.minor&gt;=1:u.major&gt;3;case"WezTerm":return u.major&gt;=20200620;case"vscode":return u.major&gt;1||u.major===1&amp;&amp;u.minor&gt;=72;case"ghostty":return!0}}if(a){if(a==="0.50.0")return!1;let u=us(a);return u.major&gt;0||u.minor&gt;=50}switch(l){case"alacritty":return!0}return!1}cs.exports={supportsHyperlink:Ei,stdout:Ei(process.stdout),stderr:Ei(process.stderr)}});var ds=ne((Zg,Uc)=&gt;{Uc.exports={name:"@prisma/internals",version:"6.15.0",description:"This package is intended for Prisma's internal use",main:"dist/index.js",types:"dist/index.d.ts",repository:{type:"git",url:"https://github.com/prisma/prisma.git",directory:"packages/internals"},homepage:"https://www.prisma.io",author:"Tim Suchanek &lt;suchanek@prisma.io&gt;",bugs:"https://github.com/prisma/prisma/issues",license:"Apache-2.0",scripts:{dev:"DEV=true tsx helpers/build.ts",build:"tsx helpers/build.ts",test:"dotenv -e ../../.db.env -- jest --silent",prepublishOnly:"pnpm run build"},files:["README.md","dist","!**/libquery_engine*","!dist/get-generators/engines/*","scripts"],devDependencies:{"@babel/helper-validator-identifier":"7.25.9","@opentelemetry/api":"1.9.0","@swc/core":"1.11.5","@swc/jest":"0.2.37","@types/babel__helper-validator-identifier":"7.15.2","@types/jest":"29.5.14","@types/node":"18.19.76","@types/resolve":"1.20.6",archiver:"6.0.2","checkpoint-client":"1.1.33","cli-truncate":"4.0.0",dotenv:"16.5.0",empathic:"2.0.0",esbuild:"0.25.5","escape-string-regexp":"5.0.0",execa:"5.1.1","fast-glob":"3.3.3","find-up":"7.0.0","fp-ts":"2.16.9","fs-extra":"11.3.0","fs-jetpack":"5.1.0","global-dirs":"4.0.0",globby:"11.1.0","identifier-regex":"1.0.0","indent-string":"4.0.0","is-windows":"1.0.2","is-wsl":"3.1.0",jest:"29.7.0","jest-junit":"16.0.0",kleur:"4.1.5","mock-stdin":"1.0.0","new-github-issue-url":"0.2.1","node-fetch":"3.3.2","npm-packlist":"5.1.3",open:"7.4.2","p-map":"4.0.0",resolve:"1.22.10","string-width":"7.2.0","strip-ansi":"6.0.1","strip-indent":"4.0.0","temp-dir":"2.0.0",tempy:"1.0.1","terminal-link":"4.0.0",tmp:"0.2.3","ts-node":"10.9.2","ts-pattern":"5.6.2","ts-toolbelt":"9.6.0",typescript:"5.4.5",yarn:"1.22.22"},dependencies:{"@prisma/config":"workspace:*","@prisma/debug":"workspace:*",<span class="fstat-no" title="function not covered" >"@prisma/dmmf":"workspace:*","@prisma/driver-adapter-utils":"workspace:*","@prisma/engines":"workspace:*","</span>@prisma/fetch-engine":<span class="fstat-no" title="function not covered" >"workspace:*","@prisma/generator":"workspace:*","@prisma/generator-helper":"workspace:*","@prisma/get-platform":"workspace:*","@prisma/prisma-schema-wasm":"6.15.0-5.85179d7826409ee107a6ba334b5e305ae3fba9fb","@prisma/schema-engine-wasm":"6.15.0-5.85179d7826409ee107a6ba334b5e305ae3fba9fb","@prisma/schema-files-loader":"workspace:*",arg:"5.0.2",prompts:"2.4.2"},peerDependencies:{typescript:"&gt;=5.1.0"},peerDependenciesMeta:{typescript:{optional:!0}},sideEffects:!1}</span>});var Ti=ne((Eh,Hc)=&gt;{Hc.<span class="fstat-no" title="function not covered" >exports={name:"@prisma/engines-version",version:"6.15.0-5.85179d7826409ee107a6ba334b5e305ae3fba9fb",main:"index.js",types:"index.d.ts",license:"Apache-2.0",author:"Tim Suchanek &lt;suchanek@prisma.io&gt;",prisma:{enginesVersion:"85179d7826409ee107a6ba334b5e305ae3fba9fb"}</span>,repository:{type:"git",url:<span class="fstat-no" title="function not covered" >"https://github.com/prisma/engines-wrapper.git",directory:"</span>packages/engines-version"},devDependencies:{"@types/node":"18.19.76",typescript:"4.9.5"},files:["index.js","index.d.ts"],scripts:{build:"tsc -d"}}});var nn=ne(tn=&gt;{"use strict";Object.defineProperty(tn,"__esModule",{value:!0});tn.enginesVersion=void 0;tn.enginesVersion=Ti().prisma.enginesVersion});var ys=ne((_h,hs)=&gt;{"use strict";hs.exports=e=&gt;{let r=e.match(/^[ \t]*(?=\S)/gm);return r?r.reduce((t,n)=&gt;Math.min(t,n.length),1/0):0}});var Di=ne((Fh,ws)=&gt;{"use strict";ws.exports=(e,r=1,t)=&gt;{if(t={indent:" ",includeEmptyLines:!1,...t},typeof e!="string")throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);if(typeof r!="number")throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof r}\``);if(typeof t.indent!="string")throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof t.indent}\``);if(r===0)return e;let n=t.includeEmptyLines?/^/gm:/^(?!\s*$)/gm;return e.replace(n,t.indent.repeat(r))}});var Ts=ne((qh,Ps)=&gt;{"use strict";Ps.exports=({onlyFirst:e=!1}={})=&gt;{let r=["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&amp;.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&amp;.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=&gt;&lt;~]))"].join("|");return new RegExp(r,e?void 0:"g")}});var Ni=ne((Vh,Ss)=&gt;{"use strict";var op=Ts();Ss.exports=e=&gt;typeof e=="string"?e.replace(op(),""):e});var Rs=ne((Gh,sp)=&gt;{sp.exports={name:<span class="branch-0 cbranch-no" title="branch not covered" >"dotenv",v</span>ersion:"16.5.0",description:"Loads environment variables from .env file",main:"lib/main.js",types:"lib/main.d.ts",exports:{".":<span class="fstat-no" title="function not covered" >{types:"./lib/main.d.ts",require:"./lib/main.js",default:"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js",<span class="fstat-no" title="function not covered" >"./package.json":"</span>./package.json"},scripts:{"dts-check":<span class="fstat-no" title="function not covered" >"tsc --project tests/types/tsconfig.json",l</span>int:"standard",pretest:<span class="branch-0 cbranch-no" title="branch not covered" >"</span>npm run lint &amp;&amp; npm run dts-check",test:<span class="branch-0 cbranch-no" title="branch not covered" >"tap run --allow-empty-coverage --disable-coverage --timeout=60000","</span>test:coverage":<span class="fstat-no" title="function not covered" >"tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",p</span>rerelease:"npm test",release:"standard-version"},repository:{type:"git",url:"git://github.com/motdotla/dotenv.git"},homepage:"https://github.com/motdotla/dotenv#readme",funding:"https://dotenvx.com",keywords:["dotenv","env",".env","environment","variables","config","settings"],readmeFilename:"README.md",license:"BSD-2-Clause",devDependencies:{"@types/node":"^18.11.3",decache:"^4.6.2",sinon:"^14.0.1",standard:"^17.0.0","standard-version":"^9.5.0",tap:"^19.2.0",typescript:"^4.8.4"},engines:{node:"&gt;=12"},browser:{fs:!1}}});var Os=ne((Qh,_e)=&gt;{"use strict";var Fi=require("node:fs"),Mi=require("node:path"),ap=require("node:os"),lp=require(<span class="fstat-no" title="function not covered" >"node:crypto")</span>,up=Rs(),Cs=up.version,cp=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;function pp(e){let r={},t=e.toString();t=t.replace(/\r\n?/mg,`</span>
`);let n;for(;(n=cp.exec(t))!=null;){<span class="branch-0 cbranch-no" title="branch not covered" >let i=n[1],o=n[2]||"";<span class="fstat-no" title="function not covered" >o</span>=o.trim();let s=o[0];o=o.replace(/^(['"`])([\s\S]*)\1$/mg,"$2"),s==='"'&amp;&amp;(o=o.replace(/\\n/g,`</span>
`),o=o.replace(/\\r/g,"\r")),r[i]=o}return r}function dp(e){let r=Ds(e),t=B.configDotenv({path:r});<span class="branch-0 cbranch-no" title="branch not covered" >if(!t.parsed){<span class="branch-0 cbranch-no" title="branch not covered" >l</span>et s=new Error(`MISSING_DATA: Cannot parse ${r} for an unknown reason`)</span>;throw s.code="MISSING_DATA",<span class="branch-0 cbranch-no" title="branch not covered" >s}let n=Is(e).split(","),i=n.length,o</span>;for(let s=0;s&lt;i;s++)try{let a=n[s].trim(),l=fp(t,a);<span class="branch-0 cbranch-no" title="branch not covered" >o=B.decrypt(l.ciphertext,l.key);break}catch(a</span>){if(s+1&gt;=i)throw <span class="branch-0 cbranch-no" title="branch not covered" >a}return B.parse(o</span>)}<span class="branch-0 cbranch-no" title="branch not covered" >function mp(e){console.l</span>og(`[dotenv@${Cs}][WARN] ${e}`)}function it(e){<span class="branch-0 cbranch-no" title="branch not covered" >console.log(`[dotenv@${Cs}][DEBUG] ${e}`)}function Is(e){return e&amp;&amp;e.DOTENV_KEY&amp;&amp;e.DOTENV_KEY.length&gt;0?e.DOTENV_KEY:process.<span class="fstat-no" title="function not covered" >e</span>nv.DOTENV_KEY&amp;&amp;process.env.DOTENV_KEY.length&gt;0?process.env.DOTENV_KEY:""}function fp(e,r){let t;try{t=new URL(r)}catch(a){if(a.code==="ERR_INVALID_URL"){let l=new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");throw l.code="INVALID_DOTENV_KEY",l}throw a}let n=t.password;if(!n){let a=new Error("INVALID_DOTENV_KEY: Missing key part");throw a.code="INVALID_DOTENV_KEY",a}let i=t</span>.searchParams.get("environment");if(!i){let a=new Error(<span class="branch-0 cbranch-no" title="branch not covered" >"INVALID_DOTENV_KEY: Missing environment part");throw a.code="INVALID_DOTENV_KEY",a}let o=`DOTENV_VAULT_${i.toUpperCase()</span>}`,s=e.parsed[o];if(!s){let a=new Error(<span class="branch-0 cbranch-no" title="branch not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${o</span>} in your .env.vault file.`);throw a.code="NOT_FOUND_DOTENV_ENVIRONMENT",a</span>}return{ciphertext:s,key:n}}function Ds(e){let r=null;if(e&amp;&amp;e.path&amp;&amp;e.path.length&gt;0)if(Array.isArray(e.path))for(let t of e.path)Fi.existsSync(t)&amp;&amp;(r=t.endsWith(".vault")?t:`${t}.vault`);else r=e.path.endsWith(".vault")?e.path:`${e.path}.vault`;else r=Mi.resolve(process.cwd(),".env.vault");<span class="fstat-no" title="function not covered" >return Fi.existsSync(r)?r:null}function As(e){return e[0]==="~"?Mi.join(ap.homedir(),e.slice(1)):e}function gp(e){!!(e&amp;&amp;e.debug)&amp;&amp;it("Loading env from encrypted .env.vault");let t=B._parseVault(e),n=process.env;return e&amp;&amp;e.processEnv!=null&amp;&amp;(n=e.processEnv),B.populate(n,t,e),{parsed:t}}function hp(e){let r=Mi.resolve(process.cwd(),".env"),t="utf8",n=!!(e&amp;&amp;e.debug);e&amp;&amp;e.encoding?t=e.encoding:n&amp;&amp;i</span>t("No encoding is specified. UTF-8 is used by default");let i=[r];if(<span class="fstat-no" title="function not covered" >e&amp;&amp;e.path)if(!Array.isArray(e.path))i=[As(e.path)];else{</span>i=[];for(let l of e.path)i.push(As(l))}let o,s={};for(let l of i)try{let u=B.parse(Fi.readFileSync(l,{encoding:t}));B.populate(s,u,e)}catch(u){n&amp;&amp;it(`Failed to load ${l} ${u.message}`),o=u}let a=process.env;return e&amp;&amp;e.processEnv!=null&amp;&amp;(a=e.processEnv),B.populate(a,s,e),o?{parsed:s,error:o}:{parsed:s}}function yp(e){if(Is(e).length===0)return B.configDotenv(e);let r=Ds(e);return r?B._configVault(e):(mp(`You set DOTENV_KEY but you are missing a .env.vault file at ${r}. Did you forget to build it?`),B.configDotenv(e))}function bp(e,r){let t=Buffer.from(r.slice(-64<span class="fstat-no" title="function not covered" >),"hex")</span>,n=Buffer.from(e,"base64"),i=n.subarray(0,12),<span class="fstat-no" title="function not covered" >o=n.subarray(-</span>16);n=n.subarray(12,-16);try{let s=lp.createDecipheriv("aes-256-gcm",t,i);return s.setAuthTag(o),`${s.update(n)}${s.final()}`}catch(s){let <span class="fstat-no" title="function not covered" >a=s instanceof R</span>angeError,l=s.message==="Invalid key length",u=s.<span class="fstat-no" title="function not covered" >message===<span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" >"</span>Unsupported state or unable to authenticate data";i</span>f(a</span>||l){let c=new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");<span class="fstat-no" title="function not covered" >throw c</span>.code="INVALID_DOTENV_KEY",c}else if(<span class="fstat-no" title="function not covered" >u){let c</span>=new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");throw c.code="DECRYPTION_FAILED",c}else throw s}}<span class="fstat-no" title="function not covered" >function Ep(e,r,t={}){let n=!!(t&amp;&amp;t.debug),i=<span class="fstat-no" title="function not covered" >!</span>!(t&amp;&amp;t.override);if(t</span>ypeof r!="object"){<span class="fstat-no" title="function not covered" >let o=new Error(<span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" >"OBJECT_REQUIRED: Please check the processEnv argument being passed to populate")</span></span></span></span>;<span class="fstat-no" title="function not covered" >t</span>hrow o.c</span>ode=<span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" >"OBJECT_REQUIRED",o</span>}<span class="fstat-no" title="function not covered" ></span>for(let o</span> of <span class="fstat-no" title="function not covered" >Object.k</span>eys(r<span class="fstat-no" title="function not covered" >))Object.<span class="fstat-no" title="function not covered" >p</span>rototype.<span class="fstat-no" title="function not covered" >h</span>asOwnProperty.<span class="fstat-no" title="function not covered" >c</span>all(e,o<span class="fstat-no" title="function not covered" ></span>)?(i===<span class="fstat-no" title="function not covered" >!</span>0&amp;&amp;(e</span>[o<span class="fstat-no" title="function not covered" >]=r[o</span>]),<span class="fstat-no" title="function not covered" >n&amp;&amp;it(i</span>===<span class="fstat-no" title="function not covered" >!0?`</span>"${o<span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" >}" is already defined and WAS overwritten`:`</span></span></span>"${o<span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" >}</span>" is already defined and was NOT overwritten`)</span></span>):e</span>[o<span class="fstat-no" title="function not covered" >]=r[o]</span>}<span class="fstat-no" title="function not covered" >var B={</span>configDotenv:hp,_configVault:gp,_parseVault:dp,config:yp,decrypt:bp,parse:pp,populate:Ep};_e.<span class="branch-0 cbranch-no" title="branch not covered" >exports.c</span>onfigDotenv=B.configDotenv;_e.exports._configVault=B._configVault;_e.exports._parseVault=<span class="branch-0 cbranch-no" title="branch not covered" >B._parseVault;_</span>e.exports.config=B.config;_e.exports.decrypt=B.decrypt;_e.exports.parse=B.parse;_e.exports.populate=B.<span class="branch-0 cbranch-no" title="branch not covered" >populate;_</span>e.<span class="branch-0 cbranch-no" title="branch not covered" >exports=B});var Ls=n</span>e((zh,un)=&gt;{"use strict";un.exports=(e={})=&gt;{let r;if(e.repoUrl)r=e.repoUrl;else if(e.user&amp;&amp;e.repo)r=`https://github.com/${e.user}/${e.repo}`;else throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");let t=new URL(`${r}/issues/new`),n=["body","title","labels","template","milestone","assignee","projects"<span class="branch-0 cbranch-no" title="branch not covered" >];for(let i</span> of n){let o=e[i];if(o!==void 0){<span class="branch-0 cbranch-no" title="branch not covered" >if(i==="labels"||i</span>===<span class="fstat-no" title="function not covered" >"projects"){if(!Array.isArray(o))throw new <span class="fstat-no" title="function not covered" >T</span>ypeError(`The \`${i}\` option should be an array`);o=o</span>.join(",")}t.searchParams.set(i,o)}}return t.toString()};<span class="branch-0 cbranch-no" title="branch not covered" >un.exports.<span class="branch-0 cbranch-no" title="branch not covered" >default=u</span>n.exports});var Ki=ne((Sb,ia)=&gt;{</span>"use strict";<span class="branch-0 cbranch-no" title="branch not covered" >ia.exports=<span class="branch-0 cbranch-no" title="branch not covered" >f</span>unction(){function e(r,t,n,i</span>,o){<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >return r</span>&lt;t||n&lt;t?r&gt;n?n+1:r+1:i===o?t:t+1}return f</span>unction(r,t){if(r===t)return 0;if(r.length&gt;t.length){var n=r;<span class="fstat-no" title="function not covered" >r=t,t</span>=n}for(var i=r.length,o=t.length;i&gt;0&amp;&amp;r.charCodeAt(i-1)===t.charCodeAt(o-1);)i--,o--;<span class="branch-0 cbranch-no" title="branch not covered" >for(var s=0;s&lt;i&amp;&amp;r.charCodeAt(s)===t.charCodeAt(s);)s++;if(i-=s,o-=s,i===0||o&lt;3)return o;var a=0,l,u,c,p</span>,d,f,h,g,D,T,S,<span class="fstat-no" title="function not covered" >b,O=[];<span class="fstat-no" title="function not covered" >for(l</span>=0;l&lt;i</span>;l++)O.push(l+1),O.push(r.charCodeAt(<span class="fstat-no" title="function not covered" >s+l));<span class="fstat-no" title="function not covered" >for(var m</span>e=O.length-1;a&lt;o-3;)for(D=t.charCodeAt(s+(u=a)),T=t.charCodeAt(s+(c=a+1)),S=t.charCodeAt(s+(p=a+2)),b=t.charCodeAt(s+(d=a+3)),f=a+=4,l=0;<span class="fstat-no" title="function not covered" >l&lt;m</span>e;l+=2)h=O[l],g=O[l+1],u=e(h,u,c,D,g),c=e(u,c,p,T,g),p=e(c,p,d,S,g),f=e(p,d,f,b,g),O[l]=f,d=p,p=c,<span class="fstat-no" title="function not covered" >c</span>=u,u=h;for(;a</span>&lt;o;)for(D=t.charCodeAt(s+(u=a)),f=++a,l=0;l&lt;me;l+=2)h=O[l],O[l]=f=e(<span class="branch-0 cbranch-no" title="branch not covered" >h,u,f,D,O[l+1]),u=h</span>;return f<span class="branch-0 cbranch-no" title="branch not covered" >}}()});var ua=Oo(()=&gt;{"use strict"});var ca=Oo(()=&gt;{"use strict"});var Qf={};tr(Qf,{DMMF:()=&gt;ut,Debug:()=&gt;N,Decimal:()=&gt;Fe,Extensions:()=&gt;ni,MetricsClient:()=&gt;Nr,PrismaClientInitializationError:()=&gt;P,PrismaClientKnownRequestError:()=&gt;z,PrismaClientRustPanicError:(</span>)=&gt;le,PrismaClientUnknownRequestError:()=&gt;V,PrismaClientValidationError:()=&gt;Z,Public:()=&gt;ii,Sql:()=&gt;oe,createParam:()=&gt;Ra,defineDmmfProperty:()=&gt;ka,deserializeJsonResponse:()=&gt;qr,deserializeRawResult:()=&gt;Xn,dmmfToRuntimeDataModel:()=&gt;$s,empty:()=&gt;La,getPrismaClient:()=&gt;bu,getRuntime:()=&gt;Gn,join:()=&gt;Na,makeStrictEnum:()=&gt;Eu,makeTypedQueryFactory:()=&gt;_a,objectEnumValues:()=&gt;Dn,raw:()=&gt;no,serializeJsonQuery:()=&gt;Mn,skip:()=&gt;Fn,sqltag:()=&gt;io,warnEnvConflicts:()=&gt;wu,warnOnce:()=&gt;st});module.exports=Ru(Qf);var ni={};tr(ni,{defineExtension:()=&gt;_o,<span class="branch-0 cbranch-no" title="branch not covered" >getExtensionContext:()=&gt;No});function _o(e){return typeof e</span>=="function"?<span class="branch-0 cbranch-no" title="branch not covered" >e:r=&gt;r.$extends(e)}function No(<span class="branch-0 cbranch-no" title="branch not covered" >e){</span>return e}</span>var ii={};tr(ii,{validator:()=&gt;Lo});function Lo(...e){return r=&gt;r}var jt={};tr(jt,{$:()=&gt;Vo,bgBlack:()=&gt;Fu,bgBlue:()=&gt;Vu,bgCyan:()=&gt;Bu,bgGreen:()=&gt;$u,bgMagenta:()=&gt;ju,bgRed:()=&gt;Mu,bgWhite:()=&gt;Uu,bgYellow:()=&gt;qu,black:()=&gt;ku,blue:()=&gt;nr,<span class="branch-0 cbranch-no" title="branch not covered" >bold:()=&gt;W,cyan:()=&gt;De,dim:()=&gt;Ce,gray:()=&gt;Kr,green:()=&gt;qe,grey:()=&gt;Lu,hidden:(</span>)=&gt;Du,inverse:<span class="branch-0 cbranch-no" title="branch not covered" >()=&gt;Iu,i</span>talic:()=&gt;Cu,<span class="branch-0 cbranch-no" title="branch not covered" >magenta:()=&gt;_u,red:()=&gt;ce,reset:()=&gt;Au,strikethrough:()=&gt;Ou,underline:()=&gt;Y,white:()=&gt;Nu,yellow:()=&gt;Ie});var oi,Fo,Mo,$o,qo=!0;typeof process&lt;"u"&amp;&amp;({FORCE_COLOR:oi,NODE_DISABLE_COLORS:Fo,NO_COLOR:Mo,TERM:$o}=process.env||{},qo=process.stdout&amp;&amp;process.stdout.isTTY);var Vo={enabled:!Fo&amp;&amp;Mo==null&amp;&amp;$o!=="dumb"&amp;&amp;(oi!=null&amp;&amp;oi!=="0"||qo)};function F(e,r){let t=new RegExp(`\\x1b\\[${r}m`,"g"),n=`\x1B[${e}m`,i=`\x1B[${r}m`;return function(o){return!Vo.enabled||o==n</span>ull?o:n+(~(""+o).indexOf(i)?o.replace(t,i+n<span class="branch-0 cbranch-no" title="branch not covered" >):o)+i}}var Au=F(0,0),W=F(1,2</span>2),Ce=F(<span class="branch-0 cbranch-no" title="branch not covered" >2,22),C</span>u=F(3,23),Y=F(4,24<span class="fstat-no" title="function not covered" >),Iu=F(7,27),Du=F(8,28),Ou=F(9,29),ku=F(30,39),ce=F(31,39),qe=F(32,39),Ie=F(33,39),nr=F(34,39),_u=F(35,39),De=F(36,39),<span class="fstat-no" title="function not covered" >N</span>u=F(37,39),Kr=F(90,39),Lu=F(90,39)</span>,Fu=F(40,49),Mu=F(41,49),$u=F(42,49<span class="fstat-no" title="function not covered" >),qu=F(4</span>3,<span class="fstat-no" title="function not covered" >49),Vu=F</span>(<span class="fstat-no" title="function not covered" >44,49),ju=F</span>(<span class="fstat-no" title="function not covered" >45,49),Bu=F(46,49),Uu=F</span>(<span class="fstat-no" title="function not covered" >47,49);var Gu=100,jo=["green","yellow","blue","magenta","cyan","red"],Hr=[],Bo=Date.now(),Qu=0,si=typeof process&lt;"u"?process.env:{};globalThis.DEBUG??=si.DEBUG??"";globalThis.DEBUG_COLORS??=si.<span class="fstat-no" title="function not covered" >DEBUG_COLORS?s</span>i.DEBUG_COLORS==="true":!0;var Yr={enable(e){typeof e=="string"&amp;&amp;(globalThis.DEBUG=e)},disable(){let e=globalThis.DEBUG;return <span class="fstat-no" title="function not covered" >globalThis.D</span>EBUG="",e},enabled(e){let r=globalThis.DEBUG.split(",").map(i=&gt;i.replace(/[.+?^${}()|[\]\\]/g,"\\$&amp;")),t=r.some(i=&gt;i===""||i[0]==="-"?!1:e.match(RegExp(i.split("*")</span>.join(".*")+"$"))),<span class="fstat-no" title="function not covered" >n=r.some(i=&gt;i===""||i[0]!==<span class="fstat-no" title="function not covered" >"</span>-"?!1:e.match(RegExp(i.slice(1).split("*").join(".*")+"$")));return t&amp;&amp;!n},log:(...e)=&gt;{let[r,t,...n]=e;(console.warn??console.log)(`${r} ${t}`,...n)},formatters:{}};function Wu(e){let r={color:jo[Qu++%jo.length],enabled:Yr.<span class="fstat-no" title="function not covered" >enabled(e</span>),namespace:e,log:Yr.log,<span class="fstat-no" title="function not covered" >extend:(</span>)=&gt;{}},t=(...n)=&gt;{<span class="fstat-no" title="function not covered" >let{</span>enabled:i,namespace:o,color:s,l</span>og:a}=r;if(n.length!==0&amp;&amp;Hr.push([o,...n]),Hr.length&gt;Gu&amp;&amp;<span class="fstat-no" title="function not covered" >Hr.shift(),Yr.enabled(o)||i){let l=n.map(c=&gt;t</span>ypeof <span class="fstat-no" title="function not covered" >c=="string"?c:Ju(c)),u=`+${Date.now()-Bo}ms`;Bo=D</span>ate.<span class="fstat-no" title="function not covered" >now(),globalThis.DEBUG_COLORS?a(jt[s](W(o)</span>),...<span class="fstat-no" title="function not covered" >l,jt[s](u)):a(o,...l,u)}};return n</span>ew <span class="fstat-no" title="function not covered" >Proxy(t,{get:(n,i)=&gt;r[i],set:(n,i,o)=&gt;r</span>[i]=<span class="fstat-no" title="function not covered" >o})}var N=new Proxy(Wu,{get:(e,r)=&gt;Yr[r],set:(<span class="fstat-no" title="function not covered" ></span>e,r,t)=&gt;Yr[r]=t});function Ju(e,r=2){let t=n</span>ew Set;return JSON.<span class="fstat-no" title="function not covered" >stringify(e,(n,i)=&gt;{if(typeof i=="object"&amp;&amp;i!==<span class="fstat-no" title="function not covered" >n</span>ull){if(t.has(i))return<span class="fstat-no" title="function not covered" >"[Circular *]";t</span>.add(i)<span class="fstat-no" title="function not covered" >}else if(t</span>ypeof i=="bigint")return i.toString(<span class="fstat-no" title="function not covered" >)</span>;return i},r)}function Uo(<span class="fstat-no" title="function not covered" >e</span>=7500){let r=Hr.map(([t,...n])=&gt;`${t</span>} ${n.<span class="fstat-no" title="function not covered" >map(i=&gt;typeof i=="string"?i:JSON.stringify(i<span class="fstat-no" title="function not covered" ></span>)).join(" ")}`).join(`</span>
`);return r.<span class="fstat-no" title="function not covered" >length&lt;e?r:r.slice(-e)</span>}function Go(){Hr.length=0}var gr=<span class="fstat-no" title="function not covered" >N;var Qo=A(require("node:fs"));function ai(){let <span class="fstat-no" title="function not covered" >e</span>=process.env.<span class="fstat-no" title="function not covered" >PRISMA_QUERY_ENGINE_LIBRARY;i</span>f(!(e&amp;&amp;Qo.default.<span class="fstat-no" title="function not covered" >existsSync(e</span>))&amp;&amp;process.arch==="ia32")throw <span class="fstat-no" title="function not covered" >n</span>ew Error(<span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" >'The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)')</span></span></span>}var li=[<span class="fstat-no" title="function not covered" >"darwin","darwin-arm64","debian-openssl-1.0.x","debian-openssl-1.1.x","debian-openssl-3.0.x","rhel-openssl-1.0.x","rhel-openssl-1.1.x","rhel-openssl-3.0.x","</span>linux-arm64-openssl-1.1.x","linux-arm64-openssl-1.0.x","linux-arm64-openssl-3.0.x","linux-arm-openssl-1.1.x","linux-arm-openssl-1.0.x","linux-arm-openssl-3.0.x","linux-musl",<span class="branch-0 cbranch-no" title="branch not covered" >"linux-musl-openssl-3.0.x","</span>linux-musl-arm64-openssl-1.1.x",<span class="branch-0 cbranch-no" title="branch not covered" >"linux-musl-arm64-openssl-3.0.x","</span>linux-nixos","linux-static-x64",<span class="fstat-no" title="function not covered" >"linux-static-arm64","windows","freebsd11","</span>freebsd12","freebsd13",<span class="branch-0 cbranch-no" title="branch not covered" >"freebsd14",<span class="branch-0 cbranch-no" title="branch not covered" >"freebsd15","</span>openbsd","netbsd","arm"];var Bt="libquery_engine";function U</span>t(e,r){let t=r==="url";return e.<span class="branch-0 cbranch-no" title="branch not covered" >includes("windows")</span>?t?"query_engine.dll.node":<span class="branch-0 cbranch-no" title="branch not covered" >`query_engine-${e}.dll.node`:e.includes("darwin")?t</span>?`${Bt}.dylib.node`:`${Bt}-${e<span class="branch-0 cbranch-no" title="branch not covered" >}.dylib.node`:t?`${B</span>t<span class="fstat-no" title="function not covered" >}.so.node`:`${Bt}-${e}.so.node`}var Ho=A(require("node:child_process")),mi=A(<span class="fstat-no" title="function not covered" >require("</span>node:fs/promises")),Kt=A(<span class="fstat-no" title="function not covered" >r</span>equire("node:os"));var O</span>e=Symbol.for("@ts-pattern/matcher"),Ku=Symbol.for(<span class="fstat-no" title="function not covered" >"@ts-pattern/isVariadic"),Qt=<span class="fstat-no" title="function not covered" >"@ts-pattern/anonymous-select-key",u</span>i=e=&gt;!!(e&amp;&amp;typeof e=="object"),Gt=e=&gt;e</span>&amp;&amp;!!e[Oe],Ee=(e,r,t)=&gt;{if(Gt(e)){let n=e[Oe](),{matched:i,selections:o}=n.match(r);return i&amp;&amp;o&amp;&amp;Object.keys(o).forEach(<span class="branch-0 cbranch-no" title="branch not covered" >s=&gt;t(s,o[s])),i}if(ui(e)){if(!ui(r))return!1;if(Array.isArray(e)){if(!Array.isArray(r))return!1;let n=[</span>],i=[],<span class="branch-0 cbranch-no" title="branch not covered" >o=[];for(let s of e</span>.keys()){let a=e[s];Gt(a)&amp;&amp;a[Ku]?o.push(a):o.length?i.push(a):n.push(a)}if(o.length){if(o.length&gt;1)throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");if(r.<span class="branch-0 cbranch-no" title="branch not covered" >length&lt;n</span>.length+<span class="branch-0 cbranch-no" title="branch not covered" >i.length)return!1;let s</span>=r.slice(0,n.length),a=i.length===0?[]:r.slice(-i.length),l=r.slice(n.length,i.length===0?1/0:-i.length);return n.every((u,c)=&gt;Ee(u,s[c],t))&amp;&amp;i.every((u,c)=&gt;Ee(u,a[c],t))&amp;&amp;(o.length===0||Ee(o[0],l,t))}return e.length===r.length&amp;&amp;e.every((s,a)=&gt;Ee(s,r[a],t))}return Reflect.ownKeys(e).every(n=&gt;{let i=e[n];return(n in r||Gt(o=i)&amp;&amp;o[Oe]().matcherType==="optional")&amp;&amp;Ee(i,r[n],t);var o})}return Object.is(r,e)},Ge=e=&gt;{var r,t,n;return ui(e)?Gt(e)?(r=(t=(n=e[Oe]()).getSelectionKeys)==null?void 0:t.call(n))!=null?r:[]:Array.isArray(e)?zr(e,Ge):zr(Object.values(e),Ge):[]},zr=(e,r)=&gt;e.reduce((t,n)=&gt;t.concat(r(n)),[]);function pe(e){return Object.assign(e,{optional:()=&gt;Hu(e),and:r=&gt;q(e,r),or:r=&gt;Yu(e,r),select:r=&gt;r===void 0?Wo(e):Wo(r,e)})}function Hu(e){return pe({[Oe]:()=&gt;({match:r=&gt;{let t={},n=(i,o)=&gt;{t[i]=o};return r===void 0?(Ge(e).forEach(i=&gt;n(i,void 0)<span class="branch-0 cbranch-no" title="branch not covered" >),{matched:!0,selections:t}):{matched:Ee(e,r,n),selections:t<span class="fstat-no" title="function not covered" >}</span>},getSelectionKeys:()=&gt;Ge(e),matcherType:"optional"})})}function q(...e){return p</span>e({[Oe]:()=&gt;({match:r=&gt;{let t={},n=(i,o)=&gt;{t[i]=o};return{matched:e.every(i=&gt;Ee(<span class="branch-0 cbranch-no" title="branch not covered" >i,r,n)),s</span>elections:t}},getSelectionKeys:()=&gt;zr(e,Ge),matcherType:"and"})})}function Yu(...e){return pe({[Oe]:()=&gt;({match:r=&gt;{let t={},n=(i,o)=&gt;{t[i]=o};return zr(e,Ge).forEach(i=&gt;n(i,void 0)),{matched:e.some(i=&gt;Ee(i,r,n)),selections:t}},getSelectionKeys:()=&gt;zr(e,Ge),matcherType:"or"})})}function C(e){return{[Oe]:()=&gt;({match:r=&gt;({matched:!!e(r)})})}}function Wo(...e){let r=typeof e[0]=="string"?e[0]:void 0,t=e.length===2?e[1]:typeof e[0]=="string"?void 0:e[0];return pe({[Oe]:()=&gt;({match:n=&gt;{<span class="branch-0 cbranch-no" title="branch not covered" >let i={[r??Qt]:n};return{matched:t===void 0||Ee(t,n,(o,s)=&gt;{i[o]=s}),selections:i}},getSelectionKeys:()=&gt;[r??Qt].concat(t</span>===void 0?[]:Ge(t))})})}function ye(e){return typeof e=="number"}function Ve(e){return typeof e=="string"}function <span class="branch-0 cbranch-no" title="branch not covered" >je(e){return typeof e=="bigint"}var ig=pe(C</span>(function(e){return!0}));var Be=e=&gt;Object.assign(pe(e),{startsWith:r=&gt;{return Be(q(e,(t=r,C(n=&gt;Ve(n)&amp;&amp;n.startsWith(t)))));<span class="branch-0 cbranch-no" title="branch not covered" >var t},endsWith:r=&gt;{return Be(q(e,(t=r,C(n=&gt;Ve(n)&amp;&amp;n.endsWith(t)))));var t},minLength:r=&gt;Be(q(e,(t=&gt;C(n=&gt;Ve(n)&amp;&amp;n.length&gt;=t))(r))),length:r=&gt;Be(q(e,(t=&gt;C(n=&gt;Ve(n)&amp;&amp;n.length===t))(r))),maxLength:r=&gt;B</span>e(q(e,(t=&gt;C(n=&gt;Ve(n<span class="branch-0 cbranch-no" title="branch not covered" >)&amp;&amp;n.length&lt;=t))(r))),<span class="fstat-no" title="function not covered" >includes:r</span>=&gt;{return Be(q(e,(t=r,C(n=&gt;Ve(n)&amp;&amp;n.includes(t)))));var t},regex:r=&gt;{return Be(q(e,(t=r,C(n=&gt;Ve(n)&amp;&amp;!!n.match(t)))));var t}</span>}),og=Be(C(Ve)),be=e=&gt;Object.assign(pe(e),{between:(r,t)=&gt;be(q(e,((n,i)=&gt;C(o=&gt;ye(o)&amp;&amp;n&lt;=o&amp;&amp;i&gt;=o))(r,t))),lt:r=&gt;be(q(e,(t=&gt;C(n=&gt;ye(n)&amp;&amp;n&lt;t))(r))),gt:r=&gt;be(q(e,(t=&gt;C(n=&gt;ye(n)&amp;&amp;n&gt;t))(r))),lte:r=&gt;be(q(e,(t=&gt;C(n=&gt;ye(n)&amp;&amp;n&lt;=t))(r))),gte:r=&gt;be(q(e,(t=&gt;C(n=&gt;ye(n)&amp;&amp;n&gt;=t))(r))),int:()=&gt;be(q(e,C(r=&gt;ye(r)&amp;&amp;Number.isInteger(r)))),finite:()=&gt;be(q(<span class="branch-0 cbranch-no" title="branch not covered" >e,C(r=&gt;ye(r)&amp;&amp;Number.isFinite(r)))),positive:()=&gt;be(q(e,C(r=&gt;ye(r)&amp;&amp;r&gt;0))),negative:()=&gt;be(q(e,C(r=&gt;ye(r)&amp;&amp;r&lt;0)))}),sg=be(C(ye)),Ue=e=&gt;Object.assign(pe(e),{between:(r,t)=&gt;Ue(q(e,((n,i)=&gt;C(o=&gt;je(o)&amp;&amp;n&lt;=o&amp;&amp;i&gt;=o))(r</span>,t))),lt:r=&gt;Ue(q(e,(t=&gt;C(<span class="branch-0 cbranch-no" title="branch not covered" >n=&gt;je(n)&amp;&amp;n&lt;t))(r))),gt:r=&gt;Ue(q(e,(t=&gt;C(n=&gt;je(n)&amp;&amp;n&gt;t))(r))),lte:r=&gt;Ue(q(e,(t=&gt;C(n=&gt;je(n)&amp;&amp;n&lt;=t))(r))),gte:r=&gt;Ue(q(e,(t=&gt;C(n=&gt;je(n)&amp;&amp;n&gt;=t))(r))),positive:()=&gt;Ue(q(e,C(r=&gt;je(r)&amp;&amp;r&gt;0))),negative:()=&gt;Ue(q(e,C(r=&gt;je(r)&amp;&amp;r&lt;0)))}),ag=Ue(C(je)),lg=pe(C(function(e){return typeof e=="boolean"})),ug=pe(C(function(e){return typeof e=="symbol"})),cg=pe(C(function(e){return e==null})),pg=p</span>e(C(function(e){return e!=null}));var ci=class extends Error{constructor(r){let t;try{<span class="branch-0 cbranch-no" title="branch not covered" >t=JSON.<span class="branch-0 cbranch-no" title="branch not covered" >stringify(r</span>)}catch{</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >r}super(<span class="branch-0 cbranch-no" title="branch not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >`</span>Pattern matching error: no pattern matches value ${t</span>}`)</span>,this.input=<span class="branch-0 cbranch-no" title="branch not covered" >void 0,this.input=r</span>}},<span class="branch-0 cbranch-no" title="branch not covered" >pi={matched:!1,v</span>alue:void 0};<span class="branch-0 cbranch-no" title="branch not covered" >function hr(e){return n</span>ew di(e,pi)}var <span class="branch-0 cbranch-no" title="branch not covered" >di=class e{constructor(r,t){this.input=void 0,this.state=v</span>oid 0,this.input=r,<span class="branch-0 cbranch-no" title="branch not covered" >this.state=t}with(...r){i</span>f(this.state.<span class="branch-0 cbranch-no" title="branch not covered" >matched)return this;let t=r[r.length-1],n=[r[0]],i;r</span>.length===<span class="branch-0 cbranch-no" title="branch not covered" >3&amp;&amp;typeof r[1]=="function"?i</span>=r[<span class="branch-0 cbranch-no" title="branch not covered" >1]:r.length&gt;2&amp;&amp;n.push(...r.slice(1,r.length-1));let o=!1,s={},a=(u,c)=&gt;{</span>o=<span class="branch-0 cbranch-no" title="branch not covered" >!0,s[u]=c},l=!n.some(u=&gt;Ee(u,t</span>his.input,a))||i&amp;&amp;!i(this.input)?<span class="branch-0 cbranch-no" title="branch not covered" >pi:{matched:!</span>0,value:t(o?Qt in s?s[Qt]:s:this.input,this.input)};return new e(this.input,l)}when(r,t){if(this.state.matched)return this;let n=!!r(this.input);return new e(this.<span class="branch-0 cbranch-no" title="branch not covered" >input,n?{matched:!0,value:t</span>(this.input,this.input)}:pi)}otherwise(r){<span class="fstat-no" title="function not covered" >return t</span>his.state.<span class="fstat-no" title="function not covered" >matched?t</span>his.state.<span class="fstat-no" title="function not covered" >value:r</span>(this.input<span class="fstat-no" title="function not covered" >)}exhaustive()<span class="fstat-no" title="function not covered" >{</span>if(t</span>his.state.<span class="fstat-no" title="function not covered" >matched)r</span>eturn this.<span class="fstat-no" title="function not covered" >state.value;<span class="fstat-no" title="function not covered" >t</span>hrow new ci(t</span>his.input<span class="fstat-no" title="function not covered" >)}r</span>un(){<span class="fstat-no" title="function not covered" >return t</span>his.<span class="fstat-no" title="function not covered" >exhaustive()}<span class="fstat-no" title="function not covered" ></span>returnType(){return t</span>his}<span class="fstat-no" title="function not covered" >};var Yo=r</span>equire(<span class="fstat-no" title="function not covered" >"node:util");var z</span>u={<span class="fstat-no" title="function not covered" >warn:Ie(<span class="fstat-no" title="function not covered" >"</span>prisma:warn")}</span>,Zu=<span class="fstat-no" title="function not covered" >{warn:(</span>)=&gt;!process.env.<span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" >PRISMA_DISABLE_WARNINGS}</span>;function W</span>t(<span class="fstat-no" title="function not covered" >e,...r</span>){Zu.<span class="fstat-no" title="function not covered" >warn()&amp;&amp;c</span>onsole.<span class="fstat-no" title="function not covered" >warn(`${z</span>u.warn} ${<span class="fstat-no" title="function not covered" >e}`,.</span>..r)}var <span class="fstat-no" title="function not covered" >Xu=(0,Y</span>o.<span class="fstat-no" title="function not covered" >promisify)(Ho.d</span>efault.exec),ee=<span class="fstat-no" title="function not covered" >gr(<span class="fstat-no" title="function not covered" >"prisma:get-platform")</span></span>,<span class="fstat-no" title="function not covered" >ec=[<span class="fstat-no" title="function not covered" >"</span>1.0.x","1.1.x",<span class="fstat-no" title="function not covered" >"</span>3.0.x"];<span class="fstat-no" title="function not covered" >async function z</span>o(){</span>let e=Kt.default.platform(),r=process.arch;if(<span class="branch-0 cbranch-no" title="branch not covered" >e==="freebsd"){</span>let s=await Ht("freebsd-version");if(s&amp;&amp;s.trim().length&gt;0){let l=/^(\d+)\.?/.exec(s<span class="branch-0 cbranch-no" title="branch not covered" >);if(l)return{</span>platform:"freebsd",targetDistro:`freebsd${l[1]}`,arch:r}}}if(e!=="linux")return{platform:e,arch:r};let <span class="branch-0 cbranch-no" title="branch not covered" >t=await tc(),n=await cc(),i=ic({arch:r</span>,archFromUname:n,familyDistro:t.<span class="branch-0 cbranch-no" title="branch not covered" >familyDistro}),{libssl:o}=await oc(i);return{</span>platform:"linux",libssl:o,<span class="branch-0 cbranch-no" title="branch not covered" >arch:r,archFromUname:n,...t}}function rc(e</span>){let r=<span class="branch-0 cbranch-no" title="branch not covered" >/^ID="?([^"\n]*)"?$/im,t=/^ID_LIKE="?([^"\n]*)"?$/im,n=r.exec(e)</span>,i=n&amp;&amp;n[1]&amp;&amp;n[1].toLowerCase(<span class="branch-0 cbranch-no" title="branch not covered" >)||"",o=t</span>.exec(e),s=o&amp;&amp;o[1]&amp;&amp;o[1].toLowerCase()||"",a=hr({id:i,idLike:s}).with({id:"alpine"},({id:l})=&gt;({targetDistro:"musl",familyDistro:l,originalDistro:l})).with({id:"raspbian"},({id:l})=&gt;({targetDistro:"arm",familyDistro:"debian",originalDistro:l})).with({id:"nixos"},({id:l<span class="branch-0 cbranch-no" title="branch not covered" >})=&gt;({targetDistro:"nixos",originalDistro:l,familyDistro:"nixos"})).with({id:"debian"},{i</span>d:"ubuntu"},({id:l})=&gt;({targetDistro:"debian",<span class="branch-0 cbranch-no" title="branch not covered" >familyDistro:"debian",originalDistro:l}</span>)).with({id:"rhel"},{id:"centos"},{id:"fedora"},({id:l})=&gt;({targetDistro:"rhel",familyDistro:"rhel",originalDistro:l})).when(({idLike:l})=&gt;l.includes("debian")||l.includes("ubuntu"),({id:l})=&gt;({targetDistro:"debian",familyDistro:"debian",originalDistro:l})).when(({idLike:l})=&gt;i==="arch"||l.includes("arch"<span class="branch-0 cbranch-no" title="branch not covered" >),<span class="fstat-no" title="function not covered" >({id:l})=&gt;({targetDistro:"debian",familyDistro:"arch",originalDistro:l</span></span>})).when(({<span class="fstat-no" title="function not covered" >idLike:l})=&gt;l.includes("centos")||l.includes("fedora")||l.includes("rhel")||l.includes("suse"),({id:l})=&gt;({targetDistro:"rhel",<span class="fstat-no" title="function not covered" >f</span>amilyDistro:"rhel",originalDistro:l})).otherwise(({id:l})=&gt;({targetDistro:void 0,familyDistro:void 0,originalDistro:l}));return ee(`Found distro info:</span>
${<span class="fstat-no" title="function not covered" >JSON.stringify(a,<span class="fstat-no" title="function not covered" >n</span>ull,2)}`),a}<span class="fstat-no" title="function not covered" >a</span>sync function tc()<span class="fstat-no" title="function not covered" >{</span>let e=<span class="branch-0 cbranch-no" title="branch not covered" >"/etc/os-release";t</span>ry{</span>let <span class="branch-0 cbranch-no" title="branch not covered" >r=await m</span>i.default.readFile(e,{encoding:"utf-8"});return <span class="fstat-no" title="function not covered" >rc(r)}catch{return{targetDistro:void 0,familyDistro:void 0,o</span>riginalDistro:void 0}}}function nc(e){let r=/^OpenSSL\s(\d+\.\d+)\.\d+/.<span class="branch-0 cbranch-no" title="branch not covered" >exec(e);if(r){</span>let t=`${r[1]}.x`;return Zo(t)}}<span class="fstat-no" title="function not covered" >function Jo(e){let r=/libssl\.so\.(\d)(\.\d)?/.exec(<span class="fstat-no" title="function not covered" >e</span>);if(r){let t=`${r[1]}${r[2]??".0"}.x`;return Zo(t)}}function Zo(e){let r=(()=&gt;{if(es(e))return e;let t=e.split(".");return t[1]="0",t.join(".")})();if(e</span>c.<span class="fstat-no" title="function not covered" >includes(r))return r}function ic(e){<span class="fstat-no" title="function not covered" >return h</span>r(e).with({familyDistro:"musl"},()=&gt;(ee('Trying platform-specific paths for "alpine"'),["/lib","/usr/lib"])).with({familyDistro:"debian"},({archFromUname:r})=&gt;(ee('Trying platform-specific paths for "debian" (and "ubuntu")'),[`/usr/lib/${r}-linux-gnu`,`/lib/${r}-linux-gnu`])).with({familyDistro:"rhel"},()=&gt;(ee(<span class="fstat-no" title="function not covered" >'</span>Trying platform-specific paths for "rhel"'),["/lib64","/usr/lib64"])).otherwise(({familyDistro:r,arch:t,archFromUname:n})=&gt;(ee(`Don't know any platform-specific paths for "${r}" on ${t</span>} (${n})`),[]))}async function <span class="fstat-no" title="function not covered" >oc(e){let r='grep -v "libssl.so.0"',t</span>=await Ko(e);if(t){ee(<span class="fstat-no" title="function not covered" >`Found libssl.so file using platform-specific paths: ${t</span>}`);let o=Jo(t);if(ee(`The parsed libssl version is: ${o}`),o)return{<span class="branch-0 cbranch-no" title="branch not covered" >libssl:o,strategy:"libssl-specific-path"}}ee('Falling back to "ldconfig" and other generic paths')</span>;let n=await Ht(<span class="branch-0 cbranch-no" title="branch not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >`ldconfig -p | sed "s/.*=&gt;s*//" | sed "s|.*/||" | grep libssl | sort | ${r</span>}`)</span>;if(<span class="branch-0 cbranch-no" title="branch not covered" >n||(n=await K</span>o([<span class="fstat-no" title="function not covered" >"/lib64","/usr/lib64","/lib","/usr/lib"])),n){ee(<span class="fstat-no" title="function not covered" >`Found libssl.so file using "ldconfig" or other generic paths: ${n</span>}`);let o=Jo(n);if(ee(<span class="fstat-no" title="function not covered" >`The parsed libssl version is: ${o</span>}`),o)return{libssl:o,strategy:"ldconfig"}<span class="fstat-no" title="function not covered" >}l</span>et i=await Ht("openssl version -v");if(i){ee(`Found openssl binary with version: ${i</span>}`);let o=nc(i<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >);if(ee(`The parsed openssl version is: ${o}`),o)return{libssl:o,strategy:"openssl-binary"}}return ee("Couldn't find any version of libssl or OpenSSL in the system"),{</span></span>}}<span class="fstat-no" title="function not covered" >async function Ko(e){for(let r of e){let t=await sc(r);if(t)return t}}async function sc(e){try{return(await mi.default.readdir(e)).find(t=&gt;t.startsWith("libssl.so.")&amp;&amp;!t.startsWith("libssl.so.0"))}catch(r){if(r.code==="ENOENT")return;throw r}}async function ir(){let{binaryTarget:e}=await Xo();return e}function ac(<span class="fstat-no" title="function not covered" >e</span>){return e.binaryTarget!==void 0}async function fi(){let{memoized:e,...r}=await Xo();return r}var Jt={};async function Xo(){if(ac(Jt))return Promise.resolve({...Jt,<span class="fstat-no" title="function not covered" >memoized:!</span>0});let e=await zo(),r=lc(e);return Jt={...e,binaryTarget:r},{...Jt,memoized:!1}}function lc(e){let{platform:r,arch:t,archFromUname:n,<span class="fstat-no" title="function not covered" >libssl:i</span>,targetDistro:o,familyDistro:s,originalDistro:a}=e;r==="linux"&amp;&amp;!["x64","arm64"].includes(t)&amp;&amp;Wt(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures (detected "${t<span class="fstat-no" title="function not covered" ></span>}" instead). If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n</span>}".`);let l="1.1.x";if(r==="linux"&amp;&amp;i===void 0){let c=hr({familyDistro:s}).with({familyDistro:"debian"},()=&gt;"Please manually install OpenSSL via `apt-get update -y &amp;&amp; apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(()=&gt;"Please manually install OpenSSL and try installing Prisma again.");Wt(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l}".
${c}`)}let u="debian";if(r==="linux"&amp;&amp;o===void 0&amp;&amp;ee(`Distro is "${a}". Falling back to Prisma engines built for "${u}".`),r==="darwin"&amp;&amp;t==="arm64")return"darwin-arm64";if(r==="darwin")return"darwin";if(r==="win32")return"windows";if(r==="freebsd")return o;if(r==="openbsd")return"openbsd";if(r==="netbsd")return"netbsd";if(r==="linux"&amp;&amp;o==="nixos")return"linux-nixos";if(r==="linux"&amp;&amp;t==="arm64")return`${o==="musl"?"linux-musl-arm64":"linux-arm64"}-openssl-${i||l}`;if(r==="linux"&amp;&amp;t==="arm")return`linux-arm-openssl-${i||l}`;if(r==="linux"&amp;&amp;o==="musl"){let c="linux-musl";return!i||es(i)?c:`${c}-openssl-${i}`}return r==="linux"&amp;&amp;o&amp;&amp;i?`${o}-openssl-${i}`:(r!=="linux"&amp;&amp;Wt(`Prisma detected unknown OS "${r}" and may not work as expected. Defaulting to "linux".`),i?`${u}-openssl-${i}`:o?`${o}-openssl-${l}`:`${u}-openssl-${l}`)}async function uc(e){<span class="fstat-no" title="function not covered" >try{return await e()}catch{return}}function Ht(e){return uc(async()=&gt;{let r=await Xu(e);return ee(`Command "${e}" successfully returned "${r.stdout}"`),r.stdout})}async function cc(){return <span class="fstat-no" title="function not covered" >typeof K</span>t.default.machine=="function"?Kt.default.machine():(await Ht("uname -m"))?.trim()}function es(e){return e.startsWith("1.")}var Zt={};tr(Zt,{beep:()=&gt;Fc,clearScreen:()=&gt;kc,clearTerminal:()=&gt;_c,cursorBackward:()=&gt;yc,cursorDown:()=&gt;gc,cursorForward:()=&gt;hc,cursorGetPosition:()=&gt;wc,cursorHide:()=&gt;Pc,cursorLeft:()=&gt;ns,cursorMove:()=&gt;fc,cursorNextLine:()=&gt;xc,cursorPrevLine:()=&gt;vc,cursorRestorePosition:()=&gt;Ec,cursorSavePosition:()=&gt;bc,cursorShow:()=&gt;Tc,cursorTo:()=&gt;mc,cursorUp:()=&gt;ts,enterAlternativeScreen:()=&gt;Nc,eraseDown:()=&gt;Cc,eraseEndLine:()=&gt;Rc,eraseLine:()=&gt;is,eraseLines:()=&gt;Sc,eraseScreen:()=&gt;gi,eraseStartLine:()=&gt;Ac,eraseUp:()=&gt;Ic,exitAlternativeScreen:()=&gt;Lc,iTerm:()=&gt;qc,image:()=&gt;$c,link:()=&gt;Mc,scrollDown:()=&gt;Oc,scrollUp:()=&gt;Dc});var zt=A(require("node:process"),1);var Yt=globalThis.window?.document!==void 0,Eg=globalThis.process?.versions?.node!==void 0,wg=globalThis.process?.versions?.bun!==void 0,xg=globalThis.Deno?.version?.deno!==void 0,vg=globalThis.process?.versions?.electron!==void 0,Pg=globalThis.navigator?.userAgent?.includes("jsdom")===!0,Tg=typeof WorkerGlobalScope&lt;"u"&amp;&amp;globalThis instanceof WorkerGlobalScope,Sg=typeof DedicatedWorkerGlobalScope&lt;"u"&amp;&amp;globalThis instanceof DedicatedWorkerGlobalScope,Rg=t</span>ypeof <span class="fstat-no" title="function not covered" >SharedWorkerGlobalScope&lt;"u"&amp;&amp;globalThis instanceof SharedWorkerGlobalScope,Ag=typeof ServiceWorkerGlobalScope&lt;"u"&amp;&amp;g</span>lobalThis instanceof ServiceWorkerGlobalScope,Zr=globalThis.navigator?.userAgentData?.<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >platform,C</span>g=Zr==="macOS"||globalThis.navigator?.platform==="MacIntel"||globalThis.navigator?.userAgent?.includes(" Mac ")===!0||g</span>lobalThis.<span class="fstat-no" title="function not covered" >process?.platform==="darwin",Ig=Zr===<span class="fstat-no" title="function not covered" >"</span>Windows"||globalThis.navigator?.<span class="fstat-no" title="function not covered" >platform==="</span>Win32"||globalThis.process?.platform==="win32",Dg=Zr==="Linux"||globalThis.navigator?.platform?.startsWith("Linux")===!0||globalThis.navigator?.userAgent?.includes(" Linux ")===!0||globalThis.process?.<span class="fstat-no" title="function not covered" >platform==="</span>linux",Og=Zr==="iOS"||globalThis.navigator?.platform==="MacIntel"&amp;&amp;globalThis.navigator?.maxTouchPoints&gt;1||/iPad|iPhone|iPod/.test(globalThis.<span class="fstat-no" title="function not covered" >navigator?.p</span>latform),kg=Zr==="Android"||globalThis.navigator?.platform==="Android"||globalThis.navigator?.userAgent?.includes(" Android "<span class="fstat-no" title="function not covered" >)===!</span>0||globalThis.process?.platform==="android";var I="\x1B[",et="\x1B]",yr="\x07",Xr=";",rs=!Yt&amp;&amp;zt.default.env.TERM_PROGRAM===<span class="fstat-no" title="function not covered" >"</span>Apple_Terminal",p</span>c=!<span class="fstat-no" title="function not covered" >Yt&amp;&amp;z</span>t.<span class="fstat-no" title="function not covered" >default.<span class="fstat-no" title="function not covered" >p</span>latform===<span class="fstat-no" title="function not covered" >"</span>win32",dc=Y</span>t?<span class="fstat-no" title="function not covered" >()=&gt;{<span class="fstat-no" title="function not covered" >t</span>hrow new E</span>rror("`process.cwd()` only works in Node.js, not the browser.")}:zt.default.cwd,mc=(e,r)=&gt;{if(<span class="fstat-no" title="function not covered" >typeof e!="number")throw new TypeError(<span class="fstat-no" title="function not covered" >"The `x` argument is required")</span>;<span class="fstat-no" title="function not covered" >return t</span>ypeof r!="number"?I+(e+1)+"G":I+(r+1)+Xr+(<span class="fstat-no" title="function not covered" >e</span>+1)+"H"},fc=(e,r)=&gt;{if(typeof <span class="fstat-no" title="function not covered" >e!="</span>number")throw new TypeError(<span class="fstat-no" title="function not covered" >"The `x` argument is required")</span>;let t="";return e&lt;0?t+=I+-e+<span class="fstat-no" title="function not covered" >"D":e</span>&gt;0&amp;&amp;(t+=I+e+"C"),r&lt;0?t+=I+-r+"A":r&gt;0&amp;&amp;(t+=I+r+"B"),t},ts=(e=1)=&gt;I+e+"A",gc=(e=1)=&gt;I+e+<span class="fstat-no" title="function not covered" >"B",h</span>c=(e=1)=&gt;I+e+"C",yc=(</span>e=1)=&gt;I+e+<span class="fstat-no" title="function not covered" >"D",ns=I+"G",bc=rs?"\x1B7":I+"s",Ec=rs?"\x1B8":I+"u",wc=I+"6n",xc=I+"E",vc=I+"F",P</span>c=I+"?25l",Tc=I+"?25h",Sc=e=&gt;{let r="";for(let t=0;t&lt;e;t++)r+=is+(<span class="branch-0 cbranch-no" title="branch not covered" >t&lt;e</span>-1?ts():"");return e&amp;&amp;(r+=ns),r},<span class="branch-0 cbranch-no" title="branch not covered" >Rc=I+"</span>K",Ac=I+"1K",is=I+"2K",Cc=I+"J",Ic=I+"1J",gi=I+"2J",Dc=I+"S",Oc=I+"T",kc="\x1Bc",_c=pc?`${gi}${I}0f`:`${gi}${I}3J${I}H`,Nc=I+"?1049h",Lc=I+"?1049l",Fc=yr,Mc=(e,r)=&gt;[et,"8",Xr,Xr,r,yr,e,et,"8",Xr,Xr,yr].join(""),$c=(e,r={})=&gt;{let t=<span class="branch-0 cbranch-no" title="branch not covered" >`${et}1337;File=inline=1`;r</span>eturn r.width&amp;&amp;(t+=`;width=${r.width}`),r.height&amp;&amp;(t+=`;height=${r.height}`),r.preserveAspectRatio===!1&amp;&amp;(t+=";preserveAspectRatio=0"),t+":"+Buffer.from(e).toString("base64")+yr},qc={setCwd:(e=<span class="branch-0 cbranch-no" title="branch not covered" >dc())=&gt;`</span>${et<span class="branch-0 cbranch-no" title="branch not covered" >}50;CurrentDir=${e}${yr}`,annotation(e,r={}){l</span>et t=`${et<span class="branch-0 cbranch-no" title="branch not covered" >}1337;`,n=r.x!==void 0,i=r.y!==void 0;if((n||i)&amp;&amp;!(n&amp;&amp;i</span>&amp;&amp;r.<span class="branch-0 cbranch-no" title="branch not covered" >length!==v</span>oid 0))throw new Error(<span class="branch-0 cbranch-no" title="branch not covered" >"`x`, `y` and `length` must be defined when `x` or `y` is defined")</span>;return e=e.replaceAll(<span class="branch-0 cbranch-no" title="branch not covered" >"|",""),t+=r.isHidden?<span class="branch-0 cbranch-no" title="branch not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >"</span>AddHiddenAnnotation=":"</span>AddAnnotation=",r.<span class="branch-0 cbranch-no" title="branch not covered" >length&gt;0</span>?t+=(n?[e,r.length,r.x,r.y]:[r.length,e]).join("|"):t+=e,t+yr}};var Xt=A(ps(),1);function or(e,r,{target:t="stdout",...n}={}){return Xt.default[t]?Zt.link(e,r):n.fallback===!1?e:typeof n.fallback=="function"?n.fallback(e,r):`${e} (\u200B${r}\u200B)`}or.isSupported=Xt.default.stdout;or.stderr=(e,r,t={})=&gt;or(e,r,{target:"stderr",...t});or.stderr.isSupported=Xt.default.stderr;function wi(e){return or(e,e,{fallback:Y})}var Gc=ds(),xi=Gc.version;function Er(e){let r=Qc();return r||(e?.config.engineType==="library"?"library":e?.config.engineType==="</span>binary"?"binary":e?.config.engineType==="client"?"client":Wc(e))}function Qc(){let e=process.env.<span class="branch-0 cbranch-no" title="branch not covered" >PRISMA_CLIENT_ENGINE_TYPE;r</span>eturn e==="library"?"library":e==="binary"?"binary":e==="client"?"client":void 0}function Wc(e){return e?.previewFeatures.includes("queryCompiler")?"client":<span class="branch-0 cbranch-no" title="branch not covered" >"library"}function vi(e){return e.name==="DriverAdapterError"&amp;&amp;t</span>ypeof e.cause=="object"}<span class="fstat-no" title="function not covered" >function en(e){return{ok:!0,value:e,map(r){<span class="fstat-no" title="function not covered" >return e</span>n(r(e))},flatMap(r){return r(e)}}}function sr(<span class="fstat-no" title="function not covered" >e){</span>return{ok:!1,error:e,map(){return sr(e)},flatMap(){return sr(e)}}}</span>var ms=N("driver-adapter-utils"),Pi=class{registeredErrors=[];consumeError(<span class="fstat-no" title="function not covered" >r){return this.registeredErrors[r]}r</span>egisterNewError(r){<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >let t=0;for(;this.registeredErrors[t]!==void 0;)t++;return this.registeredErrors[t]={error:r},t}};var rn=(e,r=new Pi)=&gt;{let t={adapterName:e.adapterName,errorRegistry:r,queryRaw:ke(r,e.q</span></span>ueryRaw.bind(e)),executeRaw:ke(r,e.executeRaw.bind(e)<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >),executeScript:ke(r,e.executeScript.bind(e)),dispose:ke(r,e.dispose.bind(e)),provider:e.provider,startTransaction:async(...n)=&gt;(await ke(r,e.startTransaction.bind(e))(...n)).map(o=&gt;Jc(r,o))};return e.getConnectionInfo&amp;&amp;(t.getConnectionInfo=Kc(r,e.getConnectionInfo.bind(e))),t},Jc=(e,r)=&gt;({</span></span>adapterName:r.adapterName,provider:r.provider,options:r.<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >options,queryRaw:ke(e,r.queryRaw.bind(r)),executeRaw:ke(e,r.executeRaw.bind(r)),commit:ke(e,r.commit.bind(r)),rollback:ke(e,r.rollback.bind(r))}</span></span>);function ke(e,r){return async(...t)=&gt;{try<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >{return en(await r(...t))}catch(n){if(ms("[error@wrapAsync]",n),vi(n))return sr(n.cause);let i=e.registerNewError(n);return sr({kind:"GenericJs",id:i})}}}function Kc(e,r){return(...t)=&gt;{try{return en(r(...t))}catch(n</span></span>){if(ms("[error@wrapSync]",n),vi(n))return sr(n.<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >cause);let i=e.registerNewError(n);return sr({kind:"GenericJs",id:i})}}}var Yc=A(nn());var M=A(require("node:path")),zc=A(nn()),Th=N</span></span>("prisma:engines");function fs(){return M.default.join(<span class="fstat-no" title="function not covered" >__dirname,"../")}var Sh="libquery-engine";M</span>.default.join(__dirname,"../query-engine-darwin");M.default.join(__dirname,"../query-engine-darwin-arm64");M.<span class="fstat-no" title="function not covered" >default.join(__dirname,"../query-engine-debian-openssl-1.0.x");M.default.<span class="fstat-no" title="function not covered" >j</span>oin(__dirname,"../query-engine-debian-openssl-1.1.x");M.default.join(_</span>_dirname,<span class="fstat-no" title="function not covered" >"../query-engine-debian-openssl-3.0.x");M.default.join(<span class="fstat-no" title="function not covered" >_</span>_dirname,"../query-engine-linux-static-x64");M.default.join(__dirname,<span class="fstat-no" title="function not covered" >"../query-engine-linux-static-arm64")</span>;M.default.join(__dirname,"../query-engine-rhel-openssl-1.0.x")</span>;M.default.join(__dirname,"../query-engine-rhel-openssl-1.1.x");M.default.join(__dirname,"../query-engine-rhel-openssl-3.0.x");M.default.join(__dirname,"../libquery_engine-darwin.dylib.node");M.default.join(__dirname,"../libquery_engine-darwin-arm64.dylib.node");M.default.join(__dirname,"../libquery_engine-debian-openssl-1.0.x.so.node");M.default.join(__dirname,"../libquery_engine-debian-openssl-1.1.x.so.node");M.default.join(__dirname,"../libquery_engine-debian-openssl-3.0.x.so.node");M.default.join(__dirname,"../libquery_engine-linux-arm64-openssl-1.0.x.so.node");M.default.join(__dirname,"../libquery_engine-linux-arm64-openssl-1.1.x.so.node");M.default.join(__dirname,"../libquery_engine-linux-arm64-openssl-3.0.x.so.node");M.default.join(__dirname,"../libquery_engine-linux-musl.so.node");M.default.join(__dirname,"../libquery_engine-linux-musl-openssl-3.0.x.so.node");M.default.join(__dirname,"../libquery_engine-rhel-openssl-1.0.x.so.node");M.default.join(__dirname,"../libquery_engine-rhel-openssl-1.1.x.so.node");M.default.join(__dirname,"../libquery_engine-rhel-openssl-3.0.x.so.node");M.default.join(__dirname,"../query_engine-windows.dll.node");var Si=A(require("node:fs")),gs=gr("chmodPlusX");function Ri(e){if(process.platform==="win32")return;let r=Si.default.statSync(e),t=r.mode|64|8|1;if(r.mode===t){gs(`Execution permissions of ${e} are fine`);return}let n=t.toString(8).slice(-3);gs(`Have to call chmodPlusX on ${e}`),Si.default.chmodSync(e,n)}function Ai(e){let r=e.e,t=a=&gt;`Prisma cannot find the required \`${a}\` system library in your system`,n=r.message.includes("cannot open shared object file"),i=`Please refer to the documentation about Prisma's system requirements: ${wi("https://pris.ly/d/system-requirements")}`,o=`Unable to require(\`${Ce(e.id)}\`).`,s=hr({message:r.message,code:r.code}).with({code:"ENOENT"},()=&gt;"File does not exist.").when(({message:a})=&gt;n&amp;&amp;a.includes("libz"),()=&gt;`${t("libz")}. Please install it and try again.`).when(({message:a})=&gt;n&amp;&amp;a.includes("libgcc_s"),()=&gt;`${t("libgcc_s")}. Please install it and try again.`).when(({message:a})=&gt;n&amp;&amp;a.includes("libssl"),()=&gt;{let a=e.platformInfo.libssl?`openssl-${e.platformInfo.libssl}`:"openssl";return`${t("libssl")}. Please install ${a} and try again.`}).when(({message:a})=&gt;a.includes("GLIBC"),()=&gt;`Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`).when(({message:a})=&gt;e.platformInfo.platform==="linux"&amp;&amp;a.includes(<span class="fstat-no" title="function not covered" >"symbol not found"),()=&gt;`The Prisma engines are not compatible with your system ${<span class="fstat-no" title="function not covered" >e</span>.platformInfo.originalDistro} on (${e.platformInfo.archFromUname<span class="fstat-no" title="function not covered" >}</span>) which uses the \`${e.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`).otherwise(()=&gt;`The Prisma engines do not seem to be compatible with your system. ${i}`);return`</span>${o}
${s<span class="fstat-no" title="function not covered" >}</span>
&nbsp;
Details: ${r.message}`}var bs=A(ys(),1);function Ci(e){let r=(0,bs.default)(e);if(r===0)return e;let t=new RegExp(`^[ \\t]{${r}}`,"gm");return e.replace(t,"")}var Es="prisma+postgres",on=`${Es}:`;function sn(e){return e?.toString().startsWith(`${on}//`)??!1}function Ii(e){if(!sn(e))return<span class="fstat-no" title="function not covered" >!1;let{host:r}=new URL(e);return r.includes("localhost")||r.includes("127.0.0.1")||r.includes("[::1]")}var xs=A(Di());function ki(e){return String(new Oi(e))}var Oi=class{constructor(r){this.c</span>onfig=r<span class="fstat-no" title="function not covered" >}toString(){let{config:r}=this,t=r.provider.fromEnvVar?`env("${r.provider.fromEnvVar}")`:r.provider.value,n=JSON.parse(JSON.stringify({provider:t,binaryTargets:Zc(r.binaryTargets)}));return`generator ${r.name} {</span>
<span class="cstat-no" title="statement not covered" >${(0,xs.default)(Xc(n),2)}</span>
<span class="cstat-no" title="statement not covered" >}`}};function Zc(e){let r;if(e.length&gt;0){let t=e.find(n=&gt;n.fromEnvVar!==null);t?r=`env("${t.fromEnvVar}")`:r=e.map(n=&gt;n.native?"native":n.value)}else r=void 0;return r}function Xc(e){let r=Object.keys(e).reduce((t,n)=&gt;Math.max(t,n.length),0);return Object.entries(e).map(([t,n])=&gt;`${t.padEnd(r)} = ${ep(n)}`).join(`</span>
`)}function ep(e){return JSON.parse(JSON.stringify(e,(r,t)=&gt;Array.<span class="fstat-no" title="function not covered" >isArray(t)?`[${t.map(n=&gt;JSON.stringify(n)).join(", ")}]`:JSON.stringify(t)))}var tt={};tr(tt,{error:()=&gt;np,info:(</span>)=&gt;tp,log:<span class="fstat-no" title="function not covered" >()=&gt;rp,query:()=&gt;ip,should:()=&gt;vs,tags:()=&gt;r</span>t,warn:()=&gt;_i});var <span class="fstat-no" title="function not covered" >rt={error:ce("prisma:error"),warn:Ie("prisma:warn"),info:De("prisma:info"),query:nr("prisma:query")<span class="fstat-no" title="function not covered" ></span>},vs={warn:()=&gt;!process.env.<span class="fstat-no" title="function not covered" >P</span>RISMA_DISABLE_WARNINGS};function rp(...e){console.log(...e)</span>}function _i(<span class="fstat-no" title="function not covered" >e,...r){vs.warn()&amp;&amp;console.w</span>arn(`${rt.warn} ${e}`,...<span class="fstat-no" title="function not covered" >r)}function tp(e,...r){console.info(`${r</span>t.info} ${e}`,...r)}<span class="fstat-no" title="function not covered" >function np(e,...r){console.error(`${rt.error} ${e}`,...r)}function ip(e,...r){console.log(`${rt.query} ${e}`,...r)}function an(e,r){if(!e)throw new Error(`${r}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`)}function ar(e,r){throw new Error(r)}var nt=A(require("node:path"));function Li(e){return nt.default.sep===nt.default.posix.s</span>ep?e:e.split(<span class="fstat-no" title="function not covered" >nt.default.sep).join(nt.default.posix.sep)}var qi=A(Os()),ln=A(require("node:fs"));var wr=A(require("node:path"));function ks(e){let r=e.ignoreProcessEnv?{}:process.env,t=n=&gt;n.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(o,s){let a=/(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);if(!a)return o;let l=a[1],u,c;if(l==="\\")c=a[0],u=c.replace("\\$","$");else{let p</span>=a[2];c=a[0<span class="fstat-no" title="function not covered" >].substring(l.length),u=Object.hasOwnProperty.call(r,p)?r[p]:e.parsed[p]||"",u=t(u)}return o.replace(c,u)},n)??n;for(let n in e.parsed){let i=Object.hasOwnProperty.c</span>all(r,n<span class="fstat-no" title="function not covered" >)?r[n]:e.parsed[n];e.parsed[n]=t(i)}for(let n in e.parsed)r[n]=e.parsed[n];return e}var $i=gr("prisma:tryLoadEnv");function ot({rootEnvPath:e,schemaEnvPath:r},t={conflictCheck:"none"}){let n=_s(e);t.conflictCheck!=="none"&amp;&amp;wp(n</span>,r,t.conflictCheck);let <span class="fstat-no" title="function not covered" >i=null;return Ns(n?.path,r)||(i=_s(r)),!n&amp;&amp;!i&amp;&amp;$i("No Environment variables loaded"),i?.dotenvResult.error?console.error(ce(W("Schema Env Error: "))+i.dotenvResult.error):{message:[n?.message,i?.message].filter(Boolean).join(`</span>
`),parsed:{...n?.dotenvResult?.parsed,...i?.<span class="fstat-no" title="function not covered" >dotenvResult?.parsed}}}function wp(e,r,t){let n=e?.dotenvResult.parsed,i=!Ns(e?.path,r);if(n&amp;&amp;r&amp;&amp;i&amp;&amp;ln.default.existsSync(r)){let o=qi.default.parse(ln.default.readFileSync(r)),s=[];for(let a in o)n[a]===o[a]&amp;&amp;s</span>.push(a);if(s.length&gt;<span class="fstat-no" title="function not covered" >0){let a=wr.default.relative(process.cwd(),e.path),l=wr.default.relative(process.cwd(),r);if(t==="error"){let u=`There is a conflict between env var${s.length&gt;1?"s":""} in ${Y(a)} and ${Y(l)}</span>
Conflicting env vars:
<span class="cstat-no" title="statement not covered" >${s.map(c=&gt;`  ${W(c)}`).join(`</span>
<span class="cstat-no" title="statement not covered" >`)}</span>
&nbsp;
We suggest to move the contents of ${Y(l)} to ${Y(a)<span class="fstat-no" title="function not covered" >} to consolidate your env vars.</span>
<span class="cstat-no" title="statement not covered" >`;throw new Error(u)}else if(t==="warn"){let u=`Conflict for env var${s.length&gt;1?"s":""} ${s.map(c=&gt;W(c)).join(", ")} in ${Y(a)} and ${Y(l)}</span>
<span class="cstat-no" title="statement not covered" >Env vars from ${Y(l)} overwrite the ones from ${Y(a)}</span>
      `;console.warn(`${Ie("warn(prisma)")} ${u}`)}}}<span class="fstat-no" title="function not covered" >}function _s(e){if(xp(e)){$i(`Environment variables loaded from ${e}`);let r=qi.default.config({path:e,debug:process.env.DOTENV_CONFIG_DEBUG?!0:void 0});return{dotenvResult:ks(r),message:Ce(`Environment variables loaded from ${wr.default.relative(process.cwd(),e)}`),path:e}}else $i(`Environment variables not found at ${e}`);return null}function Ns(e,r){return e&amp;&amp;r&amp;&amp;wr.default.resolve(e)===wr.default.resolve(r)}function xp(e){return!!(e&amp;&amp;ln.default.existsSync(e))}function Vi(e,r){return Object.prototype.hasOwnProperty.call(e,r)}function c</span>n(<span class="fstat-no" title="function not covered" >e,r){let t={};for(let n</span> of Object.<span class="fstat-no" title="function not covered" >keys(e))t[n]=r(e[n],n);return t}function j</span>i(e,<span class="fstat-no" title="function not covered" >r){if(e.length===0</span>)return;let t=<span class="fstat-no" title="function not covered" >e[0];for(let n=1;n&lt;e</span>.length;n++)r(<span class="fstat-no" title="function not covered" >t,e[n])&lt;0&amp;&amp;(t=e[n]</span>);<span class="fstat-no" title="function not covered" >return t}function x(e,r){Object.defineProperty(e</span>,<span class="fstat-no" title="function not covered" >"name",{value:r,configurable:!</span>0})}var Fs=<span class="fstat-no" title="function not covered" >new Set,st=(e,r,...t</span>)=&gt;{Fs.<span class="fstat-no" title="function not covered" >has(e)||(Fs.add(e),_i(r,...t))};var P=class e extends Error{clientVersion;errorCode;retryable;constructor(r,t,n){super(r),this.name="PrismaClientInitializationError",this.clientVersion=t,this.errorCode=n,Error.captureStackTrace(e)}get[Symbol.toStringTag](){return"PrismaClientInitializationError"}};x(P,"PrismaClientInitializationError");var z=class extends Error{code;meta;clientVersion;batchRequestIdx;constructor(r,{code:t,clientVersion:n,meta:i,batchRequestIdx:o}){super(r</span>),this.<span class="fstat-no" title="function not covered" >name="PrismaClientKnownRequestError",this.code=t,this.clientVersion=n,this.meta=i,Object.defineProperty(this,"batchRequestIdx",{value:o,enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return"PrismaClientKnownRequestError"}};x(z,"PrismaClientKnownRequestError");var le=class extends Error{clientVersion;constructor(r,t){super(r),this.name="PrismaClientRustPanicError",this.clientVersion=t}get[Symbol.toStringTag](){return"PrismaClientRustPanicError"}};x(le,"PrismaClientRustPanicError");var V=class extends Error{clientVersion;batchRequestIdx;constructor(r,{clientVersion:t,batchRequestIdx:n}){super(r),this.name="PrismaClientUnknownRequestError",this.clientVersion=t,Object.defineProperty(this,"batchRequestIdx",{value:n,writable:!0,enumerable:!1})}get[Symbol.toStringTag](){</span>return<span class="fstat-no" title="function not covered" >"PrismaClientUnknownRequestError"}};x(V,"PrismaClientUnknownRequestError");var Z=class extends Error{name="PrismaClientValidationError";clientVersion;constructor(r,{clientVersion:t}){super(r),this.clientVersion=t}g</span>et[Symbol.toStringTag<span class="fstat-no" title="function not covered" >](){return"PrismaClientValidationError"}</span>};<span class="fstat-no" title="function not covered" >x(Z,"PrismaClientValidationError")</span>;var <span class="fstat-no" title="function not covered" >we=class{_map=new Map;get(r){return t</span>his._map.<span class="fstat-no" title="function not covered" >get(r)?.value}set(r,t){this._map.set(r,{value:t})}getOrCreate(r,t){let n=this._map.get(r);if(n)return n.value;let i=t();return this.set(r,i),i}};function We(e){return e.substring(0,1).toLowerCase()+e.substring(1)}function Ms(e,r){let t={};for(let n of e){let i=n[r];t[i]=n}return t}function at(e){let r;return{get(){return r||(r={value:e()}),r.value}}}function $s(e){return{models:Bi(e.models),enums:Bi(e.enums),types:Bi(e.types)}}function Bi(e){let r={};for(let{name:t,...n</span>}of e)r[t<span class="fstat-no" title="function not covered" >]=n;return r}function xr(e){return e instanceof Date||Object.prototype.toString.call(e)==="[object Date]"}function d</span>n(<span class="fstat-no" title="function not covered" >e){return e.toString()!=="Invalid Date"}var vr=9e15,Ye=1e9,U</span>i=<span class="fstat-no" title="function not covered" >"0123456789abcdef",gn=<span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" >"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",h</span></span>n=<span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" >"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",G</span></span></span></span>i={precision:20,rounding:4,modulo:1,toExpNeg:-7,<span class="fstat-no" title="function not covered" >t</span>oExpPos:21,minE:-vr,maxE:vr,crypto:!1},Bs,Ne,w=!0,bn="[DecimalError] ",He=bn+"Invalid argument: ",Us=bn+"Precision limit exceeded",Gs=bn+"crypto unavailable",Qs=<span class="fstat-no" title="function not covered" >"</span>[object Decimal]",X=Math.floor,U=Math.pow,vp=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,Pp=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,Tp=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,Ws=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,fe=1e7,E=7,Sp=9007199254740991,Rp=gn.length-1,Qi=hn.length-1,m={toStringTag:Qs};m.absoluteValue=m.abs=function(){var e=new this.constructor(this);return e.s&lt;0&amp;&amp;(e.s=1),y(e)};m.ceil=function(){return y(new this.constructor(this),this.e+1,2)};m.clampedTo=m.clamp=function(e,r){var t,n=this,i=n.constructor;i</span>f(e=new i(<span class="fstat-no" title="function not covered" >e),r=new i(r),!e.s||!r.s)return n</span>ew i(<span class="fstat-no" title="function not covered" >NaN);if(e.gt(r))throw Error(He+r);return t=n.cmp(e),t&lt;0?e:n.cmp(r)&gt;0?r:new i(n)};m.comparedTo=m.cmp=function(e){var r,t,n,i,o=this,s=o.d,a=(e=new o.constructor(e)).d,l=o.s,u=e.s;if(!s||!a)return!l||!u?N</span>aN:<span class="fstat-no" title="function not covered" >l!==u?l:s===a?0:!</span>s^l&lt;<span class="fstat-no" title="function not covered" >0?1:-1;if(!s[0]||!a[0])return s</span>[0]?l:a[0<span class="fstat-no" title="function not covered" >]?-u:0;if(l!==u)return l;if(o.e!==e.e)return o.e&gt;e.e^l&lt;0?1:-1;for(n=s.length,i=a.length,r=0,t=n&lt;i?n:i;r&lt;t;++r)if(s[r]!==a[r])return s[r]&gt;a[r]^l&lt;0?1:-1;return n===i?0:n&gt;i^l&lt;0?1:-1};m.cosine=m.cos=function(){var e,r,t=this,n=t.constructor;return t.d?t.d[0]?(e=n.precision,r=n.rounding,n.precision=e+Math.max(t.e,t.sd())+E,n.rounding=1,t=Ap(n,zs(n,t)),n.precision=e,n.rounding=r,y(Ne==2||Ne==3?t.neg():t,e,r,!0)):new n(1):new n(NaN)};m.cubeRoot=m.cbrt=function(){var e,r,t,n,i,o,s,a,l,u,c=this,p=c.constructor;if(!c.isFinite()||c.isZero())return new p(c);for(w=!1,o=c.s*U(c.s*c,1/3</span>),!o||Math.<span class="fstat-no" title="function not covered" >abs(o)==1/0?(t=J(c.d),e=c.e,(o=(e-t.length+1)%3)&amp;&amp;(t+=o==1||o==-2?"0":"00"),o=U(t,1/3),e=X((e+1)/3)-(e%3==(e&lt;0?-1:2)),o==1/0?t="5e"+e:(t=o.toExponential()</span>,t=t.slice(0,t.<span class="fstat-no" title="function not covered" >indexOf("e")+1)+e),n=new p(t),n.s=c.s):n=new p(o.toString()),s=(e=p.precision)+3;;)if(a=n,l=a.times(a).times(a),u=l.p</span>lus(c),<span class="fstat-no" title="function not covered" >n=L(u.plus(c).times(a),u.plus(l),s+2,1),J(a.d).slice(0,s)===(t=J(n.d)).slice(0,s))if(t=t.slice(s-3,s</span>+1),t==<span class="fstat-no" title="function not covered" >"9999"||!i&amp;&amp;t=="4999"){if(!i&amp;&amp;(y(a,e+1,0),a.t</span>imes(a).times(a).<span class="fstat-no" title="function not covered" >eq(c))){n=a;break}s+=4,i=1}else{(!+t||!+t.slice(1)&amp;&amp;t.<span class="fstat-no" title="function not covered" >charAt(0</span>)=="5")&amp;&amp;(y(n,e+1,1),r=!n.times(n).times(n).eq(c));break}return w=!0,y(n,e,p.rounding,r)};m.decimalPlaces=m.dp=function(){var e,r=this.d,t=NaN;if(r){<span class="fstat-no" title="function not covered" >if(e</span>=r.length-1,t=(e-X(this.e/E))*E,<span class="fstat-no" title="function not covered" >e=r</span>[e],e)for(;e%10==0;e/=10)t--;t&lt;0&amp;&amp;(t=0)}return t};m.dividedBy=m.div=function(e){return L(this,new this.constructor(e))};m.dividedToIntegerBy=m.divToInt=function(e){var r=this,t=r.constructor;return y(L(r,new t(e),0,1,1),t.precision,t.rounding)};m.equals=m.eq=function(e){return this.cmp(e)===0};m.floor=function(){return y(new this.constructor(this),this.e+1,3)};m.<span class="fstat-no" title="function not covered" >greaterThan=m</span>.gt=function(e){return this.cmp(e)&gt;0};m.greaterThanOrEqualTo=m.gte=function(e){var r=this.cmp(e);return r==1||r===0};m.hyperbolicCosine=m.cosh=function(){var <span class="fstat-no" title="function not covered" >e,r</span>,t,n,i,o=this,s=o.constructor,a=new s(1);if(!o.isFinite())return new s(o.s?1/0:NaN);if(o.isZero())return a;t=s.precision,n=s.rounding,s.precision=t+Math.max(o.e,o.sd())+4,s.rounding=1,i=o.d.length,i&lt;32?(e=Math.ceil(i/3),r=(1/wn(4</span>,e)).<span class="fstat-no" title="function not covered" >toString()):(e=16,r="2.3283064365386962890625e-10"),o=Pr(s,1,o.times(r),new s(1),!0);for(var l,u=<span class="fstat-no" title="function not covered" >e</span>,c=new s(8);u--;)l=o.times(o),o=a.minus(l.times(c.minus(l.times(c))));return y(o,s.precision=t,<span class="fstat-no" title="function not covered" >s.r</span>ounding=n,!0)};m.hyperbolicSine=m.sinh=function(){var e,r,t,n,i=this,o=i.constructor;i</span>f(!i.isFinite()||i.isZero())return new o(i);if(r=o.precision,t=o.rounding,o.precision=r+Math.max(i.e,i.sd())+4,o.rounding=1,n=i.d.length,n&lt;3)i=Pr(o,2,i,i,!0);else{e=1.4*Math.sqrt(n),e=e&gt;16?16:e|0,i=i.times(1/wn(5,e)),i=Pr(o,2,i,i,!0);for(var s,a=new o(5),l=new o(16),u=new o(20);e--;)s=i.times(i),i=i.times(a.plus(s.times(l.times(s).plus(u))))}return o.precision=r,o.rounding=t,y(i,r,t,!0)};m.hyperbolicTangent=m.tanh=function(){var e,r,t=this,n=t.constructor;return t.isFinite()?t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+7,n.rounding=1,L(t.sinh(),t.cosh(),n.precision=e,n.rounding=r)):new n(t.s)};m.inverseCosine=m.acos=function(){var e=this,r=e.constructor,t=e.abs().cmp(1),n=r.precision,i=r.rounding;return t!==-1?t===0?e.isNeg()?xe(r,n,i):new r(0):new r(NaN):e.isZero()?xe(r,n+4,i).times(.5):(r.precision=n+6,r.rounding=1,e=new r(1).minus(e).div(e.plus(1)).sqrt().atan(),r.precision=n,r.rounding=i,e.times(2))};m.inverseHyperbolicCosine=m.acosh=function(){var e,r,<span class="fstat-no" title="function not covered" >t=this,n=t.constructor;return t.lte(1)?new n(t.eq(1)?0:NaN):t.isFinite()?(e=n.precision,r=n.rounding,n.precision=e+Math.max(Math.abs(t.e),t.sd())+4,n.rounding=1,w=!1,t=t.times(t).minus(1).sqrt().plus(t),w=!0,n.precision=e,n.rounding=r,t.ln()):new n(t)};m.inverseHyperbolicSine=m.asinh=function(){var e,r,t=this,n=t.constructor;return!t.isFinite()||t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+2*Math.max(Math.abs(t.e),t.sd())+6,n.rounding=1,w=!1,t=t.times(t).plus(1).sqrt().plus(t),w=!0,n.precision=e,n.rounding=r,t.ln())};m.inverseHyperbolicTangent=m.atanh=function(){var e,r,t,n,i=this,o=i.constructor;return i.isFinite()?i.e&gt;=0?new o(i.abs().eq(1)?i.s/0:i.isZero()?i:NaN):(e=o.precision,r=o.rounding,n=i.sd(),Math.max(n,e)&lt;2*-i.e-1?y(new o(i),e,r,!0):(o.<span class="fstat-no" title="function not covered" >precision=t</span>=n-i.e,i=L(i.plus(1),new o(1).minus(i),t+e,1),o.precision=e+4,o.rounding=1,i=i.ln(),o.precision=e,o.rounding=r,i.times(.5))):new o(NaN)};m.inverseSine=m.asin=function(){var e,r,t,n,i=this,o=i.constructor;return i.isZero()?new o(i):(r=i.abs().cmp(1),t=o.precision,n=o.rounding,r!==-1?r===0?(e=<span class="fstat-no" title="function not covered" >x</span>e(o,t+4,n).times(.5),e.s=i.s,e):new o(NaN):(<span class="fstat-no" title="function not covered" >o</span>.precision=t+6,o.rounding=1,i=i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).<span class="fstat-no" title="function not covered" >atan()</span>,o.precision=t,o.rounding=n,i.times(2)))};m.<span class="fstat-no" title="function not covered" >inverseTangent=m</span>.atan=function(){var e,r,t,n,i,o,s,a,l,u=this,c=u.constructor,p=c.precision,d=c.<span class="fstat-no" title="function not covered" >r</span>ounding;if(u.isFinite()){if(u.isZero(<span class="fstat-no" title="function not covered" >)</span>)return new c(u);if(u.abs().eq(1)&amp;&amp;p+4&lt;=Qi)return s=xe(c,p+4,d).times(.25),s.s=u.s,s}else{if(!u.s)return new c(NaN);if(p+4&lt;=Qi)return s=xe(c,p+4,d).<span class="fstat-no" title="function not covered" >times(.</span>5),s.s=u.s,s}for(c.<span class="fstat-no" title="function not covered" >precision=a</span>=p+10,c.rounding=1,t=Math.min(28,a/E+2|0),e=t;e;--e)u=u.div(u.times(u).plus(1).sqrt().plus(1));for(w=<span class="fstat-no" title="function not covered" >!1,r</span>=Math.ceil(a/E),n=1,l=u.times(u),s=new c(u),i=u;e!==-1;)if(i=i.times(l),o=s.minus(i.div(n+=2)),i=i.times(l),s=o.plus(i.div(n+=2)),s.d[r]!==void 0)for(e=r;s.d[e]===o.d[e]&amp;&amp;e--;);return t&amp;&amp;(s=s.times(2&lt;&lt;t-1)),w=!0,y(s,c.precision=p,c.rounding=d,!0)};m.isFinite=function(){return!!this.d};m.isInteger=m.isInt=function(){return!!this.d&amp;&amp;X(this.e/E)&gt;this.d.length-2};m.isNaN=function(){return!this.s};m.isNegative=m.isNeg=function(){return this.s&lt;0};m.<span class="fstat-no" title="function not covered" >i</span>sPositive=m.isPos=function(){return this.s&gt;0};m.isZero=function(){return!!this.d&amp;&amp;this.d[0]===0};m.lessThan=m.lt=function(e){return this.cmp(e)&lt;0};m.lessThanOrEqualTo=m.lte=function(e){return this.cmp(e)&lt;1};m.logarithm=m.log=function(e){var r,t,n,i,o,s,a,l,u=this,c=u.constructor,p=c.precision,d=c.rounding,f=5;if(e==null)e=new c(10),r=!0;else{if(e=new c(e),t=e.d,e.s&lt;0||!t||!t[0]||e.eq(1))return new c(NaN);r=e.eq(10)}if(t=u.d,u.s&lt;0||!t||!t[0]||u.eq(1))return new c(t&amp;&amp;!t[0]?-1/0:u.s!=1?NaN:t?0:1/0);if(r)if(t.length&gt;1)o=!0;else{for(i=t[0];i%10===0;)i/=10;o=i!==1}if(w=!1,a=p+f,s=Ke(u,a),n=r?yn(c,a+10):Ke(e,a),l=L(s,n,a,1),lt(l.d,i=p,d))do if(a+=10,s=Ke(<span class="fstat-no" title="function not covered" >u,a</span>),n=r?yn(c,a+10):Ke(e,a),l</span>=L(s,n,a,1),!o){+J(l.d).slice(i+1,i+15)+1==1e14&amp;&amp;(l=y(l,p+1,0<span class="branch-0 cbranch-no" title="branch not covered" >));break}while(lt(l.d,i+=10,d)</span>);<span class="branch-0 cbranch-no" title="branch not covered" >return w=!0,y</span>(l,p,d)};m.minus=<span class="branch-0 cbranch-no" title="branch not covered" >m.s</span>ub=function(e){var r,t,n,i,<span class="branch-0 cbranch-no" title="branch not covered" >o,s</span>,a,l,u,c,p,d,f=this,h=f.constructor;if(<span class="branch-0 cbranch-no" title="branch not covered" >e=new h(e</span>),!f.d||!e.d)return!f.s||!e.s?e=new h(NaN):f.d?e.s=-e.s:e=new h(<span class="branch-0 cbranch-no" title="branch not covered" >e.d||f.s</span>!==e.s?f:NaN),e;if(f.s!=e.s)<span class="branch-0 cbranch-no" title="branch not covered" >return e.s=-e.s,f.p</span>lus(e);if(u=f.<span class="branch-0 cbranch-no" title="branch not covered" >d,d=e.d,a=<span class="branch-0 cbranch-no" title="branch not covered" >h</span>.precision,l=h.rounding,<span class="fstat-no" title="function not covered" >!</span>u[0]||!d[0]){if(d[0])e.s=-e.s;else if(u[0])e=new h(f);else return new h(l===3?-0:0);return w?y(e,a,l):e}if(t=X(e.e/E),c=X(f.e/E),u=u.slice(),o=c-t,o){for(p=o&lt;0,p?(r=u,o=-o,s=d.length):(r=d,t=c,s=u.length),n=Math.max(Math.ceil(a/E),s)+2,o&gt;n&amp;&amp;(o=n,r.length=1),r.reverse(),n=o;n--;)r.push(0);r.reverse()}else{for(n=u.length,s=d.length,p=n&lt;s,p&amp;&amp;(s=n),n=0;n&lt;s;n++)if(u[n]!=d[n]){p=u[n]&lt;d[n];break}o=0}for(p&amp;&amp;(r=u,u=d,d=r,e.<span class="fstat-no" title="function not covered" >s=-</span>e.s),s=u.length,n=d.length-s;n&gt;0;--n)u[s++]=0;for(n=d.length;n&gt;o;){if(u[--n]&lt;d[n]){for(i=n;i&amp;&amp;u[--i]===0;)u[i]=fe-1;--u[i],u[n]+=fe}u[n]-=d[n]}for(;u[--s]===0;)u.<span class="fstat-no" title="function not covered" >pop()</span>;for(;u[0]===0;u.shift())--t;return u[0]?(e.d=u,e.e=En(u,t),w?y(e,a,l):e):new h(l===3?-0:0)};m.modulo=m.mod=function(e){var r,t=this,n=t.constructor;return e=new n(e),!t.d||!e.s||e.d&amp;&amp;!e.d[0]?new n(NaN):!e.d||t.d&amp;&amp;!t.d[0]?y(new <span class="fstat-no" title="function not covered" >n</span>(t),n.precision,n.rounding):(w=!1,n.<span class="fstat-no" title="function not covered" >modulo==9</span>?(r=L(t,e.abs(),0,3,1),r.s*=e.s):r=L(t,e,0,n.modulo,1),r=r.times(e),w=!0,t.minus(r))};m.naturalExponential=m.exp=function(){return Wi(this)};m.naturalLogarithm=m.ln=function(){return Ke(this<span class="fstat-no" title="function not covered" >)}</span>;m.negated=m.neg=function(){var e=new this.constructor(this);return e.s=-e.s,y(e)};m.plus=m.add=function(e){var r,t,n,i,o,s,a,l,u,c,p=this,d=p.constructor;if(e=new d(e),!p.d||!e.d)return!p.s||!e.s?e=new d(NaN):p.d||(e=new d(e.d||p.s===e.s?p:NaN)),e;if(p.s!=e.s)return e.s=-e.s,p.minus(e);if(u=p.d,c=e.d,a=d.precision,l=d.rounding,!u[0]||!c[0])return c[0]||(e=new d(p)),w?y(e,a,l):e;if(o=X(p.e/E),n=X(e.e/E),u=u.slice(),i=o-n,i){for(i&lt;0?(t=u,i=-i,s=c.length):(t=c,n=o,s=u.length),o=Math.ceil(a/E),s=o&gt;s?o+1:s+1,i&gt;s&amp;&amp;(i=s,t.length=1),t.reverse();i--;)t.push(0);t.reverse()}for(s=u.length,i=c.length,s-i&lt;0&amp;&amp;(i=s,t=c,c=u,u=t),r=0;i;)r=(u[--i]=u[i]+c[i]+r)/fe|0,u[i]%=fe;for(r&amp;&amp;(u.unshift(r),++n),s=u.length;u[--s]==0;)u.pop();return e.d=u,e.e=En(u,n),w?y(e,a,l):e};m.precision=m.sd=<span class="fstat-no" title="function not covered" >function(e</span>){var r,t=this;if(e!==<span class="fstat-no" title="function not covered" >void 0&amp;&amp;e</span>!==!!e&amp;&amp;e!==1&amp;&amp;<span class="fstat-no" title="function not covered" >e!==0</span>)throw Error(He+e);return t.<span class="fstat-no" title="function not covered" >d?(r</span>=Js(t.d),e&amp;&amp;t.e+1&gt;r&amp;&amp;(<span class="fstat-no" title="function not covered" >r=t</span>.e+1)):r=NaN,r};m.round=<span class="fstat-no" title="function not covered" >function(){</span>var e=this,r=e.<span class="fstat-no" title="function not covered" >constructor;r</span>eturn y(new r(e),e.e+1,r.<span class="fstat-no" title="function not covered" >r</span>ounding)};m.sine=m.sin=<span class="fstat-no" title="function not covered" >function(){</span>var e,r,t=this,n=t.<span class="fstat-no" title="function not covered" >constructor;r</span>eturn t.isFinite()?t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+Math.max(t.e,t.sd())+E,n.rounding=1,t=Ip(n,zs(n,t)),n.precision=e,n.rounding=r,y(Ne&gt;2?t.neg():t,e,r,!0)):new n(NaN)};m.squareRoot=m.sqrt=function(){var e,r,t,n,i,o,s=this,a=s.d,l=s.e,u=s.s,c=s.constructor;if(u!==1||!a||!a[0])return new c(!u||u&lt;0&amp;&amp;(!a||a[0])?<span class="fstat-no" title="function not covered" >NaN:a</span>?s:1/0);for(w=!1,u=<span class="fstat-no" title="function not covered" >Math.s</span>qrt(+s),u==0||u==1/0?(r=J(a<span class="fstat-no" title="function not covered" >),(r</span>.length+l)%2==0&amp;&amp;(r+="0"),u=Math.sqrt(r</span>),l=X((l+1)/2)-(l&lt;0||<span class="branch-0 cbranch-no" title="branch not covered" >l%2),u==1/0?r="5e"+l:(r</span>=u.toExponential(),r=r.slice(0,r.indexOf("e")+1)+l),n=new c(r)):n=new c(u.toString()),t=(l=c.precision)+3;;)if(o=n,n=o.plus(L(s,o,<span class="branch-0 cbranch-no" title="branch not covered" >t+2,1)).times(.5)</span>,J(o.d).slice(0,t)===(r=J(n.d)).slice(0,t))if(r=r.<span class="branch-0 cbranch-no" title="branch not covered" >slice(t-3,t+1),r=="9999"||!</span>i&amp;&amp;<span class="branch-0 cbranch-no" title="branch not covered" >r=="4999"){if(!</span>i&amp;&amp;(y(o,l+1,0),o.times(o).<span class="branch-0 cbranch-no" title="branch not covered" >eq(s))){n=<span class="branch-0 cbranch-no" title="branch not covered" >o</span>;break}t+=4,i=1}else{(!+r||!+r.slice(1)&amp;&amp;r.charAt(0)=="5")&amp;&amp;(y(n</span>,l+1,1),<span class="branch-0 cbranch-no" title="branch not covered" >e=!n.times(n).eq(s));break}<span class="fstat-no" title="function not covered" ></span>return w=!0,y(n,l,c.rounding,e<span class="fstat-no" title="function not covered" >)</span>};m.tangent=m.tan=function(){var e</span>,r,t=this,n=t.constructor;return t.isFinite()?t.isZero(<span class="branch-0 cbranch-no" title="branch not covered" >)?new n(t):(e=n</span>.precision,r=n.<span class="branch-0 cbranch-no" title="branch not covered" >rounding,n.precision=e+10,n.rounding=1,t=t.sin(),t.s=1,t=L(t,new n(1).minus(t.times(t)).sqrt(),e+10,0),n.precision=e</span>,n.rounding=r,y(<span class="branch-0 cbranch-no" title="branch not covered" >Ne==2||Ne==4?t.neg():t,e,r,!0)):new n(NaN)};m.times=m.mul=function(e){var r,t,n,i,o,s,a,l,u,c=this,p=c.constructor,d=c.d,f=(e=new p(e)).d;if(e.s*=c.s,!d||!d[0]||!f||!f[0])return new p(!e.s||d&amp;&amp;!d[0]&amp;&amp;!f||f&amp;&amp;!</span>f[0]&amp;&amp;!d?NaN:!d||!f?e.s/0:<span class="branch-0 cbranch-no" title="branch not covered" >e.s*0);for(t=X</span>(c.e/<span class="branch-0 cbranch-no" title="branch not covered" >E)+X(e.e/E)</span>,l=d.length,u=f.<span class="branch-0 cbranch-no" title="branch not covered" >length,l&lt;<span class="branch-0 cbranch-no" title="branch not covered" >u</span>&amp;&amp;(o=d,d=f,f=o,s=l,l=u,u=s),o=[],s=l+u,n=s;n--;)o.p</span>ush(0);for(n=u;--n&gt;=0;){for(r=0,i=l+n;i&gt;n;)a=o[i]+f[n]*d[i-n-1]+r,o[i--]=a%fe|0,r=a/fe|0;o[i]=(o[i]+r)%fe|0}for(;!o[--s];)o.pop();return r?++t:o.shift(),e.d=o,e.e=En(o,t),w?y(e,p.precision,p.rounding):e};m.toBinary=function(e,r){return Ji(this,2,e,r)};m.toDecimalPlaces=m.toDP=function(e,r){var t=this,n=t.constructor;return t=new n(t),e===void 0?t:(ie(e,0,Ye),r===void 0?r=n.rounding:ie(r,0,8),y(t,e+t.e+1,r))};m.<span class="branch-0 cbranch-no" title="branch not covered" >toExponential=function(e</span>,r){var t,n=this,i=n.constructor;return e===void 0?t=ve(n,!0):(ie(e,0,Ye),r===void 0?r=i.rounding:ie(<span class="branch-0 cbranch-no" title="branch not covered" >r,0,8),n=y(n</span>ew i(n),e+1,r<span class="fstat-no" title="function not covered" >),t=ve(n,!0,e+1)),n.isNeg()&amp;&amp;!<span class="fstat-no" title="function not covered" >n.i</span>sZero()?"-"+t:t};m.toFixed=<span class="fstat-no" title="function not covered" >f</span>unction(e,r){var t,n,i=this,o=i.<span class="fstat-no" title="function not covered" >c</span>onstructor;return e===void 0?t=ve(i):(ie(e,0,Ye),r===void 0?r=o.rounding:ie(r,0,8),n=y(new o(i),e+i.e+1,r),t=ve(n,!1,e+n.e+1)),i.isNeg()&amp;&amp;!</span>i.isZero()?"-"+t:t};m.toFraction=function(e){<span class="fstat-no" title="function not covered" >var r,t,n,i,o,s,a,l,u,c,p,d,<span class="fstat-no" title="function not covered" >f</span>=this,h=f.d,g=f.constructor;<span class="fstat-no" title="function not covered" >if(!</span>h)return new g(f);if(u=t=new <span class="fstat-no" title="function not covered" >g(1</span>),n=l=new g(0),r=new g(n),o=<span class="fstat-no" title="function not covered" >r.e</span>=Js(h)-f.e-1,s=o%E,r.d[0]=<span class="fstat-no" title="function not covered" >U(1</span>0,s&lt;0?E+s:s),e==null)<span class="fstat-no" title="function not covered" >e=o</span>&gt;0?r:u;else{if(a=new <span class="fstat-no" title="function not covered" >g(e</span>),!a.isInt()||a.lt(u))throw Error(<span class="fstat-no" title="function not covered" >He+a</span>);e=a.gt(r)?o&gt;0?r:<span class="fstat-no" title="function not covered" >u:a</span>}for(w=!1,a=new g(J(h)),c=g.precision,g.precision=o=h.length*E*2;p=L(a,r,0,1,1),i=t.plus(p.times(n)),i.cmp(e)!=1;)t=n,n=i,i=u,u=l.plus(p.times(i)),l=i,i=r,r=a.minus(p.times(i)),a=i;return i=L(e.minus(t),n,0,1,1),l=l.plus(i.times(u)),t=t.plus(i.times(n)),l.s=u.s=f.s,d=L(u,n,o,1).minus(f).abs().cmp(L(l,t,o,1).minus(f).abs())&lt;1?[u,n]:[l,t],g.precision=c,w=!0,d};m.toHexadecimal=m.toHex=function(e,r){return Ji(this,16,e,r)};m.toNearest=function(e,r){var t=this,n=t.constructor;if(t=new n(t),e==null){if(!t.d)return t;e=new n(1),r=n.<span class="fstat-no" title="function not covered" >rounding}</span>else{if(e=new n(e),r===void 0?<span class="fstat-no" title="function not covered" >r=n</span>.rounding:ie(r,0,8),!t.d)return e.s?t:e;if(<span class="fstat-no" title="function not covered" >!</span>e.d)return e.s&amp;&amp;(e.s=t.s),<span class="fstat-no" title="function not covered" >e}</span>return e.d[0]?(w=!1,<span class="fstat-no" title="function not covered" >t</span>=L(t,e,0,r,1).times(e),w=<span class="fstat-no" title="function not covered" >!0,y</span>(t)):(e.s=t.s,t=e),t};<span class="fstat-no" title="function not covered" >m.t</span>oNumber=function(){return+this};m.toOctal=function(e,r){return Ji(this,8,e,r)};m.toPower=m.pow=function(<span class="fstat-no" title="function not covered" >e){</span>var r,t,n,i,o,s,a=this,<span class="fstat-no" title="function not covered" >l=a</span>.constructor,u=+(e=new l(e<span class="fstat-no" title="function not covered" >));i</span>f(!a.d||!e.d||!a.d[0]||!e.d[0])return n</span>ew l(U(+a,u));if(a=new l(a),a.eq(1))return a;if(n=l.precision,o=l.rounding,e.eq(1))return y(a,n,o);if(r=X(e.e/E),r&gt;=e.d.length-1&amp;&amp;(t=u&lt;<span class="branch-0 cbranch-no" title="branch not covered" >0?-</span>u:u)&lt;=Sp)return i=Ks(l,a,t,n),e.s&lt;<span class="branch-0 cbranch-no" title="branch not covered" >0?new l(1).div(i):y(i,n,o);if(s=a.s,s&lt;0){if(r&lt;e.d</span>.length-1)return new l(<span class="fstat-no" title="function not covered" >NaN);if((e</span>.d[r]&amp;1)==<span class="fstat-no" title="function not covered" >0&amp;&amp;(s=<span class="fstat-no" title="function not covered" >1</span>),a.e==0&amp;&amp;a.d[0]==1&amp;&amp;a.d.length==1)return a.s=s,a}</span>return t=U(+a,u),r=t==0||!isFinite(t)?X(u*(Math.log("0."+J(a.d))/Math.LN10+a.e+1)):new l(t+"").e,r&gt;l.maxE+1||r&lt;l.minE-1?new l(r&gt;0?s/0:0):(w=!1,l.rounding=a.s=1,t=Math.min(12,(r+"").length),i=Wi(e.times(Ke(a,n+t)),n),i.d&amp;&amp;(i=y(i,n+5,1),lt(i.d,n,o)&amp;&amp;(r=n+10,i=y(Wi(e.times(Ke(a,r+t)),r),r+5,1),+J(i.d).slice(n+1,n+15)+1==1e14&amp;&amp;(i=y(i,n+1,0)))),i.s=s,w=!0,l.rounding=o,y(i,n,o))};m.toPrecision=function(e,r){var t,n=this,i=n.constructor;<span class="fstat-no" title="function not covered" >return e===v</span>oid 0?t=ve(n,n.e&lt;=i.toExpNeg||n.e&gt;=<span class="fstat-no" title="function not covered" >i.toExpPos):(i</span>e(<span class="fstat-no" title="function not covered" >e,1,Ye),r</span>===void 0?r=i.rounding:ie(r,0,<span class="fstat-no" title="function not covered" >8),n</span>=y(new i(n),e,r),t=<span class="branch-0 cbranch-no" title="branch not covered" >ve(n,e&lt;=n.e||n</span>.e&lt;=i.toExpNeg,e)),n.isNeg(<span class="branch-0 cbranch-no" title="branch not covered" >)&amp;&amp;!n.isZero()?"-"+t:t};m.<span class="fstat-no" title="function not covered" >toSignificantDigits=m</span>.toSD=function(e,r){var t=this,n=t.constructor;return e===void 0?(e=n.precision,r=n.rounding):(ie(e,1,Ye),r===void 0?r=n.rounding:ie(r,0,8)),y(new n(t),e,r</span>)};m.toString=function(){var e=this,r=e.constructor,t=ve(e,e.e&lt;=r.toExpNeg||e.e&gt;=r.toExpPos);return e.isNeg()&amp;&amp;!e.isZero()?"-"+t:t};m.truncated=m.trunc=function(){return y(new this.constructor(this),this.e+1,1)};m.valueOf=m.toJSON=function(){var e=this,r=e.constructor,t=ve(e,e.e&lt;=r.<span class="branch-0 cbranch-no" title="branch not covered" >toExpNeg||e.e</span>&gt;=r.toExpPos);return e.isNeg()?"-"+t:t};function J(e){var r,t,n,i=e.length-1,o="",s=e[0];if(i&gt;0){for(o+=s,r=1;r&lt;i;r++)n=e[r]+"",t=E-n.length,t&amp;&amp;(o+=Je(t)),o+=n;s=e[r],n=s+"",t=E-n.length,t&amp;&amp;(o+=Je(t))}else if(s===0)return"0";for(;s%10===0;)s/=10;return o+s}function ie(e,r,t){if(e!==~~e||e&lt;r||e&gt;t)throw Error(He+e)}function lt(e,r,t,n){var i,o,s,a;for(o=e[0];o&gt;=10;o/=10)--r;return--r&lt;0?(r+=E,i=0):(i=Math.ceil((r+1)/E),r%=E),o=U(10,E-r),a=e[i]%o|0,n==null?r&lt;3?(r==0?a=a/<span class="fstat-no" title="function not covered" >100|0:r==1&amp;&amp;(a=a/10|0),s=t&lt;4&amp;&amp;a==99999||t&gt;3&amp;&amp;a==49999||a==5e4||a==0):s=(t&lt;4&amp;&amp;a+1==o||t&gt;3&amp;&amp;a+1==o/2)&amp;&amp;(e[i+1]/o/100|0)==U(10,r-2)-1||(a</span>==o/<span class="fstat-no" title="function not covered" >2||a==0)&amp;&amp;(e[i+1]/o/100|0)==0:r&lt;4?(r==0?a=a/1e3|0:r==1?a=a/100|0:r==2&amp;&amp;(a=a/10|0),s=(n||t&lt;4)&amp;&amp;a==9999||!n&amp;&amp;t&gt;3&amp;&amp;a==4999):s=((n||t&lt;4)&amp;&amp;a+1==o||!n&amp;&amp;t&gt;3&amp;&amp;a+1==o/2)&amp;&amp;(e[i+1]/o/1e3|0)==U(10,r-3)-1,s}function mn(e,r,t){for(var n,i=[0],o,s=0,a=e.length;s&lt;a;){for(o=i.length;o--;)i[o]*=r;for(i[0]+=Ui.indexOf(e.charAt(s++)),n=0;n&lt;i.length;n++)i[n]&gt;t-1&amp;&amp;(i[n+1]===void 0&amp;&amp;(i[n+1]=0),i[n+1]+=i[n]/t|0,i[n]%=t)}return i.reverse()}function Ap(e,r){var t,n,i;if(r.isZero())return r;n=r.d.length,n&lt;32?(t=Math.ceil(n/3),i=(1/wn(4,t)).toString()):(t=16,i="2.3283064365386962890625e-10"),e.precision+=t,r=Pr(e,1,r.times(i),new e(1));for(var o=t;o--;){var s=r.times(r);r=s.times(s).minus(s).times(8).plus(1)}return e.precision-=t,r}var L=function(){function e(n,i,o){var s,a=0,l=n.length;for(n=n</span>.<span class="fstat-no" title="function not covered" >slice();l--;)s=n[l]*i+a,n[l]=s%o|0,a=s/o|0;return a&amp;&amp;n.unshift(a),n}function r(n,i,o</span>,s){var <span class="fstat-no" title="function not covered" >a,l;if(o!=s)l=o&gt;s?1:-1;else for(a=l</span>=<span class="fstat-no" title="function not covered" >0;a&lt;o;a++)if(n[a]!=i[a]){l=n[a]&gt;i[a]?1:-1;break}r</span>eturn l}function t(n,i,o,s){for(var a=0;o--;)n[o]-=a,a=n[o]&lt;i[o]?1:0,n[o]=a*s+n[o]-i[o];for(;!n[0]&amp;&amp;n.length&gt;1;)n.shift()}return function(n,i,o,s,a,l){var u,c,p,d,f,h,g,D,T,S,b,O,me,ae,Jr,j,te,Ae,K,fr,qt=n.constructor,ti=n.s==i.s?1:-1,H=n.d,_=i.d;if(!H||!H[0]||!_||!_[0])return new qt(!n.s||!i.s||(H?_&amp;&amp;H[0]==_[0]:!_)?NaN:H&amp;&amp;H[0]==0||!_?ti*0:ti/0);for(l?(f=1,c=n.e-i.e):(l=fe,f=E,c=X(n.e/f)-X(i.e/f)),K=_.length,te=H.length,T=new qt(ti),S=T.d=[],p=0;_[p]==(H[p]||0);p++);if(_[p]&gt;(H[p]||0)&amp;&amp;c--,o==null?(ae=o=qt.precision,s=qt.rounding):a?ae=o+(n.e-i.e)+1:ae=o,ae&lt;0)S.push(1),h=!0;else{if(ae=ae/f+2|0,p=0,K==1){for(d=0,_=_[0],ae++;(p&lt;te||d)&amp;&amp;ae--;p++)Jr=d*l+(H[p]||0),S[p]=Jr/_|0,d=Jr%_|0;h=d||p&lt;te}else{for(d=l/(_[0]+1)|0,d&gt;1&amp;&amp;(_=e(_,d,l),H=e(H,d,l),K=_.length,te=H.length),j=K,b=H.slice(0,K),O=b.length;O&lt;K;)b[O++]=0;fr=_.slice(),fr.unshift(0),Ae=_[0],_[1]&gt;=l/2&amp;&amp;++Ae;do d=0,u=r(_,b,K,O),u&lt;0?(me=b[0],K!=O&amp;&amp;(me=me*l+(b[1]||0)),d=me/Ae|0,d&gt;1?(d&gt;=l&amp;&amp;(d=l-1),g=e(_,d,l),D=g.length,O=b.length,u=r(g,b,D,O),u==1&amp;&amp;(d--,t(g,K&lt;D?fr:_,D,l))):(d==0&amp;&amp;(u=d=1),g=_.slice()),D=g.length,D&lt;O&amp;&amp;g.unshift(0),t(b,g,O,l),u==-1&amp;&amp;(O=b.length,u=r(_,b,K,O),u&lt;1&amp;&amp;(d++,t(b,K&lt;O?fr:_,O,l))),O=b.length):u===0&amp;&amp;(d++,b=[0]),S[p++]=d,u&amp;&amp;b[0]?b[O++]=H[j]||0:(b=[H[j]],O=1);while((j++&lt;te||b[0]!==void 0)&amp;&amp;ae--);h=b[0]!==void 0}S[0]||S.shift()}if(f==1)T.e=c,Bs=h;else{for(p=1,d=S[0];d&gt;=10;d/=10)p++;T.e=p+c*f-1,y(T,a?o+T.e+1:o,s,h)}return T}}();function y(e,r,t,n){var i,o,s,a,l,u,c,p,d,f=e.constructor;e:if(r!=null){if(p=e.d,!p)return e;for(i=1,a=p[0];a&gt;=10;a/=10)i++;if(o=r-i,o&lt;0)o+=E,s=r,c=p[d=0],l=c/U(10,i-s-1)%10|0;else if(d=Math.ceil((o+1)/E),a=p.length,d&gt;=a)if(n){for(;a++&lt;=d;)p.push(0);c=l=0,i=1,o%=E,s=o-E+1}else break e;else{for(c=a=p[d],i=1;a&gt;=10;a/=10)i++;o%=E,s=o-E+i,l=s&lt;0?0:c/U(10,i-s-1)%10|0}if(n=n||r&lt;0||p[d+1]!==void 0||(s&lt;0?c:c%U(10,i-s-1)),u=t&lt;4?(l||n)&amp;&amp;(t==0||t==(e.s&lt;0?3:2)):l&gt;5||l==5&amp;&amp;(t==4||n||t==6&amp;&amp;(o&gt;0?s&gt;0?c/U(10,i-s):0:p[d-1])%10&amp;1||t==(e.s&lt;0?8:7)),r&lt;1||!p[0])return p.length=0,u?(r-=e.e+1,p[0]=U(10,(E-r%E)%E),e.e=-r||0):p[0]=e.e=0,e;if(o==0?(p.length=d,a=1,d--):(p.length=d+1,a=U(10,E-o<span class="branch-0 cbranch-no" title="branch not covered" >),p[d]=s&gt;0?(c/U(10,i-s)%U(10,s)|0)*a:0</span>),u)for(;;)if(d==0){for(o=1,s=p[0];s&gt;=10;s/=10)o++;for(s=p[0]+=a,a=1;s&gt;=10;s/=10)a++;o!=a&amp;&amp;(e.e++,p[0]==fe&amp;&amp;(p[0]=1));break}else{if(p[d]+=a,p[d]!=fe)break;p[d--]=0,a=1}for(o=p.length;p[--o]===0;)p.pop()}return w&amp;&amp;(e.e&gt;f.maxE?(e.d=null,e.e=NaN):e.e&lt;f.minE&amp;&amp;(e.e=0,e.d=[0])),e}function ve(e,r,t){if(!e.isFinite())return Ys(e);var n,i=e.e,o=J(e.d),s=o.length;return r?(t&amp;&amp;(n=t-s)&gt;0?o=o.charAt(0)+"."+o.<span class="fstat-no" title="function not covered" >slice(1)+Je(n):s&gt;1&amp;&amp;(o=o.charAt(0)+"."+o.slice(1)),o=o+(e.e&lt;0?"e":"e+")+e.e):i</span>&lt;0?(o=<span class="fstat-no" title="function not covered" >"0."+Je(-i-1)+o,t&amp;&amp;(n=t-s)&gt;0&amp;&amp;(o+=Je(n))):i&gt;=s?(o+=Je(i+1-s),t&amp;&amp;(n=t-i-1)&gt;0&amp;&amp;(o=o+"."+<span class="fstat-no" title="function not covered" >J</span>e(n))):((n=i+1)&lt;s&amp;&amp;(<span class="fstat-no" title="function not covered" >o=o</span>.slice(0,n)+"."+o.slice(n)),t&amp;&amp;(n=<span class="fstat-no" title="function not covered" >t-s</span>)&gt;0&amp;&amp;(i+1===s&amp;&amp;(o+="."),o+=Je(n))),o}function En(<span class="fstat-no" title="function not covered" >e,r</span>){var t=e[0];for(r</span>*=E;<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >t&gt;=10;t/=10)r++;return r}function yn(e,r,t){if(r&gt;Rp)throw w=!0,t&amp;&amp;(e.precision=t),Error(Us);return y(new e(gn),r,1,!0)}function xe(e,r,t){if(r&gt;Qi)throw Error(Us);return y(new e(hn),r,t,!0)}function Js(e){var r=e.length-1,t=r*E+1;if(r=e[r],r){for(;r%10==0;r/=10)t--;for(r=e[0];r&gt;=10;r/=10)t++}return t}function Je(e){for(var r="";e--;)r+="0";return r}function Ks(e,r,t,n){var i,o=new e(1),s=Math.ceil(n/E+4);for(w=!1;;){if(t%2&amp;&amp;(o=o.times(r),Vs(o.d,s)&amp;&amp;(i=!0)),t=X(t/2),t===0){t=o.d.length-1,i&amp;&amp;o.d[t]===0&amp;&amp;++o.d[t];break}r=r.times(r),Vs(r.d,s)}return w=!0,o}function qs(e){return e.d[e.d.length-1]&amp;1}function Hs(e,r,t){for(var n,i</span></span>,o=new e(r[0]),s=0;++s&lt;r.length;){if(i=new <span class="fstat-no" title="function not covered" >e(r[s]),!i.s){<span class="fstat-no" title="function not covered" ></span>o=i;<span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" >b</span>reak}<span class="fstat-no" title="function not covered" ></span>n</span>=o</span>.cmp(i),(<span class="fstat-no" title="function not covered" >n===t</span>||n===<span class="fstat-no" title="function not covered" >0&amp;&amp;o.<span class="fstat-no" title="function not covered" >s===t</span>)&amp;&amp;(o=i)}return o}function Wi(e,r){var t,n,i,o,s,a,l,u=0,c=0,p=0,d=e.constructor,f=d.rounding,<span class="fstat-no" title="function not covered" >h=d</span>.precision;if(!e.d||!e.d[0]||e.e&gt;17)return new d(e.d?e.d[0]?e.s&lt;0?0:1/0:1:e.s?e.s&lt;0?0:e:NaN);for(r==null?(w=!1,l=h):l=r,a=new d(.03125);e.e&gt;-2;)e=e.times(a),p+=5;for(n=Math.log(U(2,p))/Math.LN10*2+5|0,l+=n,t=o=s=new d(1),d.precision=l;;){if(o=y(o.times(e),l,1),t=t.times(++c),a=s.plus(L(o,t,l,1)),J(a.d).slice(0,l)===J(s.d).slice(0,l)){for(i=p;i--;)s=y(s.times(s),l,1);if(r==null)if(u&lt;3&amp;&amp;lt(s.d,l-n,f,u))d.precision=l+=10,t=o=a=new d(1),c=0,u++;else return y(s,d.precision=h,f,w=!0);else return d.precision=h,s}s=a}}function Ke(e,r){var t,n,i,o,s,a,l,u,<span class="fstat-no" title="function not covered" >c,p</span>,d,f=1,h=10,g=e,D=g.d,T=g.constructor,S=T.rounding,b=T.precision;if(g.s&lt;0||!D||!D[0]||!g.e&amp;&amp;D[0]==1&amp;&amp;D.length==1)return new T(D&amp;&amp;!D[0]?-1/0:g.s!=1?NaN:<span class="fstat-no" title="function not covered" >D?0</span>:g);if(r==null?(w=!1,c=b):c=r,T.precision=c+=h,t=J(D),n=<span class="fstat-no" title="function not covered" >t.c</span>harAt(0),Math.abs(o=g.e)&lt;15e14){for(;n&lt;7&amp;&amp;n!=1||n==1&amp;&amp;t.charAt(1)&gt;3;)g=g.times(e),t=J(g.d),n=t.charAt(0),f++;o=g.e,n&gt;1?(g=new T("0."+t),o++):g=new T(n+"."+t.slice(1))}else return u=yn(T,c+2,b).times(o+""),g=Ke(new T(n+"."+t.slice(1)),c-h).plus(u),T.precision=b,r==null?y(g,b,S,w=!0):g;for(p=g,l=s=g=L(g.minus(1),g.plus(1),c,1),d=y(g.times(g),c,1),i=3;;){if(s=y(s.times(d),c,1),u=l.plus(L(s,new T(i),c,1)),J(u.d).<span class="fstat-no" title="function not covered" >s</span>lice(0,c)===J(l.d).slice(0,c))if(l=l.times(2),o!==0&amp;&amp;(l=l.plus(yn(T,c+2,b).times(o+""))),l=L(l,new T(f),c,1),r==<span class="fstat-no" title="function not covered" >n</span>ull)if(lt(l.d,c-h,S,a))T.precision=c+=h,u=s=g=L(p</span>.minus(1),p.<span class="fstat-no" title="function not covered" >plus(1),c,1),d=y(g.times(g),c,1),i=a=1;else return y(l,T.precision=b,S,w=<span class="fstat-no" title="function not covered" >!0)</span>;else return T.precision=b,l;l=u,i+=2}}<span class="fstat-no" title="function not covered" >function Y</span>s(e){return String(e.s*e.s/0)}function fn(e,r){var t,n,i;for((t=r.indexOf("."))&gt;-1&amp;&amp;(r=r.replace(".","")),(n=r.search(/e/i))&gt;0?(t&lt;0&amp;&amp;(t=n),t+=+r.slice(n+1),r=r.substring(0,n)):t&lt;0&amp;&amp;(t=r.length),n=0;r.charCodeAt(n)===48;n++);for(i=<span class="fstat-no" title="function not covered" >r.l</span>ength;r.charCodeAt(i-1)===48;--i);<span class="fstat-no" title="function not covered" >if(r</span>=r.slice(n,i),r){if(i-=n,e.e=t=t-n-1,e.d=[],n=(t+<span class="fstat-no" title="function not covered" >1)%E</span>,t&lt;0&amp;&amp;(n+=E),n&lt;i){for(n&amp;&amp;e.d.push(+r.slice(0,n)),i-=E;n&lt;i;)e.d.push(+r.slice(n,n+=E));r=r.slice(n<span class="fstat-no" title="function not covered" >),n</span>=E-r.length}else n-=i;for(;n--;)r+="0";e.d.push(+r),w&amp;&amp;(e.e&gt;e.constructor.maxE?(e.d=null,e.e=NaN):e.e&lt;e.constructor.minE&amp;&amp;(e</span>.<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >e=0,e.d=[0]))}else e.e=0,e.d=[0];return e}function Cp(e,r){var t,n,i,o,s,a,l,u,c;if(r.indexOf("_")&gt;-1){if(r=r.replace(/(\d)_(?=\d)/g,"$1"),Ws.test(r))return fn(e,r)}else if(r==="Infinity"||r==="NaN")return+r||(e.s=NaN),e.e=NaN,e.d=null,e;if(P</span></span>p.test(r))<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >t=16,r=r.toLowerCase();else if(vp.test(r))t=2;else if(Tp.test(r))t=8;else throw Error(He+r);for(o=r.search(/p/i),o&gt;0?(l=+r.slice(o+1),r=r.substring(2,o)):r=r.slice(2),o=r.indexOf("."),s=o&gt;=0,n=e.constructor,s&amp;&amp;(r=r.replace(".",""),a=r.length,o=a-o,i=Ks(n,new n(t),o,o*2)),u=mn(r,t,fe),c=u.length-1,o=c;u[o]===0;--o)u.pop();return o&lt;0?new n(e.s*0):(e.e=En(u,c),e.d=u,w=!1,s&amp;&amp;(e=L(e,i,a*4)),l&amp;&amp;(e=e.times(Math.abs(l)&lt;54?U(2,l):Le.pow(2,l))),w=!0,e)}function Ip(e,r){var t,n=r.d.length;if(n&lt;3)return r.isZero()?r:Pr(e,2,r,r);t=1.4*Math.sqrt(n),t=t&gt;16?16:t|0,r=r.times(1/wn(5,t)),r=Pr(e,2,r,r);for(var i,o=new e(5),s=new e(16),a=new e(20);t--;)i=r.times(r),r=r.times(o.plus(i.times(s.times(i).minus(a))));return r}function Pr(e,r,t,n,i){var o,s,a,l,u=1,c=e.precision,p=Math.ceil(c/E);for(w=!1,l=t.times(t),a=new e(n);;){if(s=L(a.times(l</span></span>),new e(<span class="fstat-no" title="function not covered" >r++*r++),c,1),a=i?n.<span class="fstat-no" title="function not covered" >plus(s</span>):n.minus(s),n=L(s.<span class="fstat-no" title="function not covered" >t</span>imes(l),new e(r++*r++),c,1),s=a</span>.plus(<span class="fstat-no" title="function not covered" >n),s</span>.d[p]!==void 0){for(o=p;s.d[o]===a.d[o]&amp;&amp;o--;);if(o==-1)<span class="fstat-no" title="function not covered" >break}o=a,a=n,n=s</span>,s=o,<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >u++}return w=!0,s.d.length=p+1,s}function wn(e,r){for(var t=e;--r;)t*=e;return t}function zs(e,r){var t,n=r.s&lt;0,i=xe(e,e.precision,1),o=i.times(.5);if(r=r.abs(),r.lte(o))return Ne=n?4:1,r;if(t=r.divToInt(i),t.isZero())Ne=n?3:2;else{if(r</span></span>=r.minus(<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >t.times(i)),r.lte(o))return Ne=qs(t)?n?2:3:n?4</span></span>:1,r;Ne=qs(t<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >)?n?1:4:n?3:2}return r.minus(i).abs()}function Ji(e,r,t,n){var i,o,s,a,l,u,c,p,d,f=e.constructor,h=t!==void 0;if(h?(ie(t,1,Ye),n===void 0?n=f.rounding:ie(n,0,8)):(t=f.precision,n=f.rounding),!e.isFinite())c=Ys(e);else{for(c=ve(e),s=c.indexOf("."),h?(i=2,r==16?t=t*4-3:r==8&amp;&amp;(t=t*3-2)):i=r,s&gt;=0&amp;&amp;(c=c.replace(".",""),d=new f(1),d.e=c.length-s,d.d=mn(ve(d),10,i),d.e=d.d.length),p=mn(c,10,i),o=l=p.length;p[--l]==0;)p.pop();if(!p[0])c=h?"</span></span>0p+0":"0";else{<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >if(s&lt;0?o--:(e=new f(e),e.d=p,e.e=o,e=L(e,d,t,n,0,i),p=e.d,o=e.e,u=Bs),s=p[t],a=i/2,u=u||p[t+1]!==void 0,u=n&lt;4?(s!==void 0||u)&amp;&amp;(n===0||n===(e.s&lt;0?3:2)):s&gt;a||s===a&amp;&amp;(n===4||u||n===6&amp;&amp;p[t-1]&amp;1||n===(e.s&lt;0?8:7)),p.length=t,u)for(;++p[--t]&gt;i-1;)p[t]=0,t||(++o,p.unshift(1));for(l=p.length;!p[l-1];--l);for(s=0,c="";s&lt;l;s++)c+=Ui.charAt(p[s]);if(h){if(l&gt;1)if(r==16||r==8){for(s=r==16?4:3,--l;l%s;l++)c+="0";for(p=mn(c,i,r),l=p.length;!p[l-1];--l);for(s=1,c="1.";s&lt;l;s++)c+=Ui.charAt(p[s])}else c=c.charAt(0)+"."+c.slice(1);c=c+(o&lt;0?"p":"p+")+o}else if(o&lt;0){for(;++o;)c="0"+c;c="0."+c}else if(++o&gt;l)for(o-=l;o--;)c+="0";else o&lt;l&amp;&amp;(c=c.slice(0,o)+"."+c.slice(o))}c=(r==16?"0x":r==2?"0b":r==8?"0o":"")+c}return e.s&lt;0?"-"+c:c}function Vs(e,r){if(e.length&gt;r)return e.length=r,!0}function Dp(e){return new this(e).abs()}function Op(e){return new this(e).acos()}function kp(e){return new this(e).acosh()}function _p(e,r){return new this(e).plus(r)}function Np(e){return new this(e).asin()}function Lp(e){return new this(e).asinh()}function Fp(e){return new this(e).atan()}function Mp(e){return new this(e).atanh()}function $p(e,r){e=new this(e),r=new this(r);var t,n=this.precision,i=this.rounding,o=n+4;return!e.s||!r.s?t=new this(NaN):!e.d&amp;&amp;!r.d?(t=xe(this,o,1).times(r.s&gt;0?.25:.</span></span>75),t.s=e.<span class="fstat-no" title="function not covered" >s):!r.d||e.isZero()?(t=r.s&lt;<span class="fstat-no" title="function not covered" >0</span>?xe(this,n,i):new this(0),t.s=<span class="fstat-no" title="function not covered" >e</span>.s):!e.d||r.isZero()?(t=xe(this,o,1).times(.5),t.s=e.s):r.s&lt;0?(this.<span class="fstat-no" title="function not covered" >precision=o</span>,this.rounding=1</span>,<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >t=this.atan(L(e,r,o,1)),r=xe(this,o,1),this.precision=n,this.rounding=i,t=e.s&lt;0?t.minus(r):t.plus(r)):t=this.atan(L(e,r,o,1)),t}function qp(e){return new this(e).cbrt()}function Vp(e){return y(e=new this(e),e.e+1,2)}function jp(e,r,t){<span class="fstat-no" title="function not covered" >return n</span></span>ew this(e).clamp(r,t)}function Bp(e){if(!e||typeof e!="object")throw Error(bn+"Object expected");var r,t,n,i=e.defaults===!0,o=["precision",1,Ye,"rounding",0,8,"toExpNeg",-vr,0,"toExpPos",0,vr,"maxE",0,vr,"minE",-vr,0,"modulo",0,9];for(r=0;r&lt;o.length;r+=3)if(t=o[r],i&amp;&amp;(this[t]=Gi[t]),(n=e[t])!==void 0)if(X(n)===n&amp;&amp;n&gt;=o[r+1]&amp;&amp;n&lt;=o[r+2])this[t]=n;else throw Error(He+t+": "+n);if(t="crypto",i&amp;&amp;(this[t]=Gi[t]),(n=e[t])!==void 0)if(n===!0||n===!1||n===0||n===1)<span class="fstat-no" title="function not covered" >if(n</span>)if(typeof crypto&lt;"u"&amp;&amp;crypto&amp;&amp;(crypto.getRandomValues||crypto.randomBytes))this[t]=!0;else throw Error(Gs);else this[t]=!1;else throw Error(He+t+": "+n);return this}function Up(e){return new this(e).cos()}function Gp(e){return new this(e).cosh()}function Zs(e){var r,t,<span class="fstat-no" title="function not covered" >n;f</span>unction i(o){var s,a,l,u=this;if(!(u instanceof i))return new i(o);if(u.constructor=i,js(o)){u.s=o.s,w?!o.d||o.e&gt;i.maxE?(u.e=NaN,u.d=null):o.e&lt;i.minE?(u.e=0,u.d=[0]):(u.e=o.e,u.d=o.d.slice()):(u.e=o.e,u.d=o.d?o.d.slice():o.d);return}if(l=typeof o,l==="number"){if(o===0){u.s=1/o&lt;0?-1:1,u.e=0,u.d=[0];return<span class="fstat-no" title="function not covered" >}</span>if(o&lt;0?(o=-o,u.s=-1):u.s=1,o===~~o&amp;&amp;o&lt;1e7){for(s=0,a=o;a&gt;=10;a/=10)s++;w?s&gt;i.maxE?(u.e=NaN,u.d=null):s&lt;i.minE?(u.e=0,u.d=[0]):(u.e=s,u.d=[o]):(u.e=s,u.d=[o]);return}if(o*0!==0){o||(u.s=NaN),<span class="fstat-no" title="function not covered" >u</span>.e=NaN,u.d=null;return}return fn(u,o.toString())}if(l==="string")return(a=o.charCodeAt(0))===45?(o=o.slice(1),u.s=-1):(a===43&amp;&amp;(o=o.slice(1)),u.s=1),Ws.test(o)?fn(u,o):Cp(u,o);if(l==="bigint")<span class="fstat-no" title="function not covered" >return o</span>&lt;0?(o=-o,u.s=-1):u.s=1,fn(u,o.toString());throw Error(He+o)}if(i.prototype=m,i.ROUND_UP=0,i.ROUND_DOWN=1,i.ROUND_CEIL=2,i.ROUND_FLOOR=3,i.ROUND_HALF_UP=4,i.ROUND_HALF_DOWN=5,i.ROUND_HALF_EVEN=6,i.ROUND_HALF_CEIL=7,i.ROUND_HALF_FLOOR=8,i.EUCLID=9,i.config=i.set=Bp,i.clone=Zs,i.isDecimal=js,i.<span class="fstat-no" title="function not covered" >abs=D</span>p,i.acos=Op,i.acosh=kp,i.add=_p,i.asin=Np,i.asinh=Lp,i.atan=Fp,i.atanh=Mp,i.atan2=$p,i.cbrt=qp,i.ceil=Vp,i.clamp=jp,i.cos=Up,i.cosh=Gp,i.div=Qp,i.exp=Wp,i.floor=Jp,i.hypot=Kp,i.ln=Hp,i.log=Yp,i.log10=Zp,i.log2=zp,i.max=Xp,i.min=ed,i.mod=rd,i.mul=td,i.pow=nd,i.random=id,i.round=od,i.sign=sd,i.sin=ad,i.sinh=ld,i.sqrt=ud,i.sub=cd,i.sum=pd,i.tan=dd,i.tanh=md,i.trunc=fd,e===void 0&amp;&amp;(e={}),e&amp;&amp;e.defaults!==!0)for(n=[<span class="fstat-no" title="function not covered" >"precision","</span>rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],r=0;r&lt;n.length;)e.hasOwnProperty(t=n[r++])||(e[t]=this[t]);return i.config(e),i}function Qp(e,r){return new this(e).div(r)}function Wp(e){return new this(e).exp()}function Jp(e){return y(e=new this(e),e.e+1,3)}function Kp(){var e,r,t=new this(0);for(w=!1,e=0;e&lt;arguments.length;)if(r=new this(<span class="fstat-no" title="function not covered" >arguments[e</span>++]),r.d)t.d&amp;&amp;(t=t.plus(r.times(r)));else{if(r.s)return w=!0,new this(1/0);t=r}return w=!0,t.sqrt()}function js(e){return e instanceof Le||<span class="fstat-no" title="function not covered" >e&amp;&amp;e</span>.toStringTag===Qs||!1}function Hp(e){return new this(e).ln()}function Yp(e,r){return new this(e).log(r)}function zp(e){return new this(e).log(2)}function Zp(e){<span class="fstat-no" title="function not covered" >return n</span>ew this(e).log(10)}function Xp(){return Hs(this,arguments,-1)}function ed(){return Hs(this,arguments,1)}function rd(e,r){return new this(e).mod(r)}function td(e,r){return new this(e).mul(r)}function nd(e,r){return new this(e).pow(<span class="fstat-no" title="function not covered" >r</span>)}function id(e){var r,t,n,i,o=0,s=new this(1),a=[];if(e===void 0?e=this.precision:ie(e,1,Ye),n=Math.ceil(e/E),<span class="fstat-no" title="function not covered" >this.c</span>rypto)if(crypto.getRandomValues)for(r=crypto.getRandomValues(new Uint32Array(n));o&lt;n;)i=r[o],i&gt;=429e7?r[o]=crypto.getRandomValues(new Uint32Array(1))[0]:a[o++]=i%1e7;else if(crypto.randomBytes){for(r=crypto.randomBytes(n*=4);o&lt;n;)i=r[o]+(r[o+1]&lt;&lt;8)+(r[o+2]&lt;&lt;16)+((r[o+3]&amp;127)&lt;&lt;24),i&gt;=214e7?crypto.randomBytes(4).copy(r,o):(a.push(i%1e7),o+=4);o=n/4}else throw Error(Gs);else for(;o&lt;n;)a[o++]=Math.random()*1e7|0;for(n=a[--o],e%=E,n&amp;&amp;e&amp;&amp;(i=U(10,E-e),a[o]=(n/i|0)*i);a[o]===0;o--)a.pop();if(o&lt;0)t=0,a=[0];else{for(t=-1;a[0]===0;t-=E)a.shift();for(n=1,i=a[0];i&gt;=10;i/=10)n++;n&lt;E&amp;&amp;(t-=E-n)}return s.e=t,s.d=a,s}function od(e){return y(e=new this(e),e.<span class="fstat-no" title="function not covered" >e+1</span>,this.rounding)}function sd(e){return e=new this(e<span class="fstat-no" title="function not covered" >),e</span>.d?e.d[0]?e.s:0*e.s:e.s||NaN}function ad(e){return new this(e).sin()}function ld(e){return new this(e).sinh()}function ud(e){return new this(e).sqrt()}function cd(e,r){return new this(e).sub(r)}function pd(){var e=0,r=arguments,t=new this(r[e]);for(w=<span class="fstat-no" title="function not covered" >!1;t</span>.s&amp;&amp;++e&lt;r.length;)t=t.plus(r[e]);return w=!0,y(t,this.precision,this.rounding)}function dd(e){return new this(e).tan()}function md(e){return new this(e).tanh()}function fd(e){return y(e=new this(e),e.e+1,1)}m[Symbol.for("nodejs.util.inspect.custom")]=m.toString;m[Symbol.toStringTag]="Decimal";var Le=m.constructor=Zs(Gi);gn=new Le(gn);hn=new Le(<span class="fstat-no" title="function not covered" >hn)</span>;var Fe=Le;function Tr(e){return Le.isDecimal(e)?!0:e!==null&amp;&amp;typeof e=="object"&amp;&amp;typeof e.s=="number"&amp;&amp;typeof e.e=="number"&amp;&amp;typeof e.toFixed=="function"&amp;&amp;Array.isArray(e.d)}var ut={};tr(ut,{ModelAction:()=&gt;Sr,datamodelEnumToSchemaEnum:()=&gt;gd});function gd(e){return{name:e.name,<span class="fstat-no" title="function not covered" >values:e</span>.values.map(r=&gt;r.name)}}var Sr=(b=&gt;(b.findUnique="findUnique",b.findUniqueOrThrow="findUniqueOrThrow",b.findFirst="findFirst",b.findFirstOrThrow="findFirstOrThrow",b.findMany="findMany",b.create="create",b.createMany="createMany",b.createManyAndReturn="createManyAndReturn",b.update="update",b.updateMany="updateMany",b.updateManyAndReturn="updateManyAndReturn",b.upsert="upsert",b.delete="delete",b.deleteMany="deleteMany",b.groupBy="groupBy",b.count="count",b.aggregate="aggregate",b.findRaw="findRaw",b.aggregateRaw="aggregateRaw",b))(Sr||{});var na=A(Di());<span class="fstat-no" title="function not covered" >var t</span>a=A(require("node:fs"));var Xs={keyword:De,entity:De,value:e=&gt;W(nr(e)),punctuation:nr,directive:De,function:De,variable:e=&gt;W(nr(e)),string:e=&gt;W(qe(e)),boolean:Ie,number:De,comment:Kr};var hd=e=&gt;e,xn={},yd=0,v={manual:xn.Prism&amp;&amp;xn.Prism.manual,disableWorkerMessageHandler:xn.Prism&amp;&amp;xn.Prism.disableWorkerMessageHandler,util:{encode:function(e){if(e instanceof ge){let r=e;return new ge(r.type,v.util.encode(r.content),r.alias)}else return Array.isArray(e)?e.map(v.util.encode):e.replace(/&amp;/g,"&amp;amp;").replace(/&lt;/g,"&amp;lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){<span class="fstat-no" title="function not covered" >return e</span>.__id||Object.defineProperty(e,"__id",{value:++yd}),e.__id},clone:<span class="fstat-no" title="function not covered" >function e</span>(r,t){let n,i,o=v.util.type(r);switch(t=t||{},o){case"Object":if(i=v.util.<span class="fstat-no" title="function not covered" >objId(r</span>),t[i])return t[i];n={},t[i]=n;for(let s in r)r.hasOwnProperty(s)&amp;&amp;(n[s]=e(r[s<span class="fstat-no" title="function not covered" >],t</span>));return n;case"Array":return i=v.util.objId(r),t[i]?t[i]:(n=[],t[i]=n,<span class="fstat-no" title="function not covered" >r.f</span>orEach(function(s,a){n[a]=e(s,t)}),n);default:return r}}},languages:{extend:function(e,r){let t=v.util.clone(v.languages[e]);for(let n in r)t[n]=r[n];return t},insertBefore:function(e,r,t,n){n=n||v.languages;let i=n[e],o={};for(let a in i)if(i.hasOwnProperty(a)){if(a==r)for(let l in t)t.hasOwnProperty(l)&amp;&amp;(o[l]=t[l]);t.hasOwnProperty(a)||(o[a]=i[a])}let s=n[e];return n[e<span class="fstat-no" title="function not covered" >]=o</span>,v.languages.DFS(v.languages,function(a,l){l===s&amp;&amp;a!=e&amp;&amp;(this[a]=o)}),o},DFS:function e(r,t,n,i){<span class="fstat-no" title="function not covered" >i=i</span>||{};let o=v.util.objId;for(let s in r)if(r.hasOwnProperty(s)){t.call(<span class="fstat-no" title="function not covered" >r,s</span>,r[s],n||s);let a=r[s],l=v.util.type(a);l==="Object"&amp;&amp;!i[o(a)]?(i[o(a)]=!0,e(a,<span class="fstat-no" title="function not covered" >t,n</span>ull,i)):l==="Array"&amp;&amp;!i[o(a)]&amp;&amp;(i[o(a)]=!0,e(a,t,s,i))}}},plugins:{},highlight:<span class="fstat-no" title="function not covered" >f</span>unction(e,r,t){let n={code:e,grammar:r,language:t};return v.hooks.run("before-tokenize",n<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" ></span>),n.tokens=v.tokenize(n.code,n.grammar),v.hooks.run("after-tokenize",n),ge.stringify(v.util.encode(n.tokens),n.language)},matchGrammar:function(e,r,t,n,i,o,s){for(let g in t){if(!t.hasOwnProperty(g)||!t[g])continue;if(g==s)return;let D</span></span>=t[g];D=v.util.type(D)==="Array"?D:[D];for(let T=0;T&lt;D.length;++T){let S=D[T],b=S.inside,<span class="branch-0 cbranch-no" title="branch not covered" >O=!!S.lookbehind,me=!!S.greedy,ae=0,Jr=S.alias;if(me&amp;&amp;!</span>S.pattern.global){let j=S.<span class="fstat-no" title="function not covered" >pattern.toString().match(/[imuy]*$/)</span>[0];S.<span class="fstat-no" title="function not covered" >pattern=RegExp(S.pattern.source,j+"</span>g")}S=S.pattern||S;for(let j=n,te=i;j&lt;r.length;te+=r[j].length,++j){let Ae=r[j];if(r.length&gt;e.length)return;if(Ae instanceof ge)continue;if(me&amp;&amp;j!=r.length-1){S.lastIndex=te;var p=S.exec(e);if(!p)break;<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >var c=p.index+(O?p[1].length:0),d=p.index+p[0].length,a=j,l=te;for(let _=r.length;a&lt;_&amp;&amp;(l&lt;d||!r[a].type&amp;&amp;!r[a-1].greedy);++a)l+=r[a].length,c&gt;=l&amp;&amp;(++j,te=l);if(r[j]instanceof ge)continue;u=a-j,Ae=e.slice(t</span></span>e,l),p.<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >index-=te}else{S.lastIndex=0;var p=S.exec(Ae),u=1}if(!p){if(o)break;continue}O&amp;&amp;(ae=p[1]?p[1].<span class="fstat-no" title="function not covered" >length:0</span></span>);var c=p.<span class="fstat-no" title="function not covered" >index+a</span>e,p=p[0].slice(ae),d=c+p.length,f=Ae.slice(0,c),h=Ae.slice(d);let K=[j,u];<span class="fstat-no" title="function not covered" >f&amp;&amp;(+</span>+j,te+=f.length,K.push(f));let fr=new ge(g,b?v.tokenize(p,b):p,Jr,p,me);if(K.push(fr),h&amp;&amp;K.push(h),Array.prototype.splice.apply(r,K),u!=1&amp;&amp;v.matchGrammar(e,r,t,j,te,!0,g),o)break}}}},tokenize:function(e,r){let t=[e],n=r.rest;if(n){for(let i in n)r[i]=n[i];delete r.rest}return v.matchGrammar(e,t,r,0,0,!1),t},hooks:{all:{},add:function(e,r){let t=v.hooks.all;t[e]=t[e]||[],t[e].push(r)},run:function(e,r){let t=v.hooks.all[e];if(!(!t||!t.length))for(var n=0,i;i=t[n++];)i(r)}},Token:ge};v.languages.clike={comment:[{pattern:<span class="fstat-no" title="function not covered" >/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,l</span>ookbehind:!0},{pattern:<span class="fstat-no" title="function not covered" >/(^|[^\\:])\/\/.*/,l</span>ookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},<span class="fstat-no" title="function not covered" >"class-name":{</span>pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,boolean:/</span>\b(?:true|false)\b/,function:/\w+(?=\()/,<span class="fstat-no" title="function not covered" >number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/--?|\+\+?|!=?=?|&lt;=?|&gt;=?|==?=?|&amp;&amp;?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/<span class="fstat-no" title="function not covered" >};v</span>.languages.javascript=v.languages.extend("clike",{"class-name":[v.languages.clike["class-name"],{pattern:<span class="fstat-no" title="function not covered" >/(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,l</span>ookbehind:!0}],keyword:[{pattern:/((?:^|})\s*)(?:catch|finally)\b/,lookbehind:!0},<span class="fstat-no" title="function not covered" >{</span>pattern:<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" ><span class="branch-0 cbranch-no" title="branch not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >/(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,l</span></span></span>ookbehind:!0}],number:/\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,function:/[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,operator:/-[-=]?|\+[+=]?|!=?=?|&lt;&lt;?=?|&gt;&gt;?&gt;?=?|=(?:==?|&gt;)?|&amp;[&amp;=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/});v.languages.javascript["class-name"][0].pattern=/(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;v.languages.insertBefore("javascript","keyword",{regex:{pattern:/((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/,lookbehind:!0,greedy:!0},"function-variable":{pattern:/[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=&gt;))/,alias:"function"},parameter:[{pattern:/(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,lookbehind:!0,inside:v.languages.javascript},{pattern:/[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=&gt;)/i,inside:v.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=&gt;)/,lookbehind:!0,inside:v.languages.javascript},{pattern:<span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,l</span></span></span></span></span>ookbehind:!0,i</span>nside:v.languages.javascript}],<span class="branch-0 cbranch-no" title="branch not covered" >constant:<span class="fstat-no" title="function not covered" >/\b[A-Z](?:[A-Z_]|\dx?)*\b/}</span>);v.languages.markup&amp;&amp;v.languages.markup.tag.addInlined("script",<span class="fstat-no" title="function not covered" >"javascript")</span>;v.languages.js=v.languages.javascript;v.languages.typescript=v</span>.languages.<span class="fstat-no" title="function not covered" >extend("javascript",{keyword:<span class="fstat-no" title="function not covered" ><span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >/</span>\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/,b</span></span></span>uiltin:/\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/});v.languages.ts=v.languages.typescript;function ge(e,r,t,n,i){this.type=e,this.content=r,this.alias=t,this.length=(n||"").length|0,this.greedy=!!i}ge.stringify=function(e,r){return typeof e=="string"?e:Array.isArray(e)?e.map(function(t){return ge.stringify(t,r)}).join(""):bd(e.type)(e.content)};function bd(e){return Xs[e]||hd}function ea(e){return Ed(e,v.languages.javascript)}function Ed(e,r){return v.tokenize(e,r).map(n=&gt;ge.stringify(n)).join("")}function ra(e){return Ci(e)}var vn=class e{firstLineNumber;lines;static read(r){let t;try{t=ta.default.readFileSync(r,"utf-8")}catch{return null}return e.fromContent(t)}static fromContent(r){let t=r.split(/\r?\n/);return new e(1,t)}constructor(r,t){this.firstLineNumber=r,<span class="branch-0 cbranch-no" title="branch not covered" >this.lines=t}get lastLineNumber(){return this.firstLineNumber+this.lines.length-1}mapLineAt(r,t){if(r&lt;<span class="branch-0 cbranch-no" title="branch not covered" >t</span>his.firstLineNumber||r&gt;this.lines.length+this.firstLineNumber)return this;let n=r-this.firstLineNumber,i=[...this.l</span>ines];return i[n]=t(i[n]),new e(this.firstLineNumber,i)}mapLines(r){return new e(this.firstLineNumber,this.lines.map((t,n)=&gt;r(t,this.firstLineNumber+n)))}lineAt(r){<span class="branch-0 cbranch-no" title="branch not covered" >return t</span>his.lines[r-this.firstLineNumber]}<span class="branch-0 cbranch-no" title="branch not covered" >prependSymbolAt(r,t){return t</span>his.mapLines((n,i)=&gt;i===r?`${t<span class="branch-0 cbranch-no" title="branch not covered" >} ${n}`:`  ${n}`)}slice(r,t){let n=this.lines.slice(r-1,t).join(`</span>
<span class="cstat-no" title="statement not covered" >`);return new e(r,ra(n).split(`</span>
`))}highlight(){<span class="branch-0 cbranch-no" title="branch not covered" >let r</span>=ea(this.<span class="branch-0 cbranch-no" title="branch not covered" >toString());return new e(this.firstLineNumber,r</span>.split(`
`))}toString(){return this.lines.join(`
`)}};var wd={red:ce,gray:Kr,dim:Ce,bold:<span class="branch-0 cbranch-no" title="branch not covered" >W,underline:Y</span>,highlightSource:e=&gt;e.<span class="branch-0 cbranch-no" title="branch not covered" >highlight()},xd={</span>red:e=&gt;e,gray:e=&gt;e,dim:e=&gt;e,bold:e=&gt;e,underline:e=&gt;e,<span class="branch-0 cbranch-no" title="branch not covered" >highlightSource:e=&gt;e</span>};function vd({message:e,originalMethod:<span class="branch-0 cbranch-no" title="branch not covered" >r,isPanic:t</span>,callArguments:n}){<span class="branch-0 cbranch-no" title="branch not covered" >return{functionName:`</span>prisma.${r}()`,message:<span class="branch-0 cbranch-no" title="branch not covered" >e,isPanic:t??!</span>1,callArguments:n}}function Pd({callsite:e,message:r,originalMethod:t,isPanic:n,callArguments:i},o){let s=vd({message:r,originalMethod:t,<span class="branch-0 cbranch-no" title="branch not covered" >isPanic:n,callArguments:i});if(!</span>e||typeof window&lt;"u"||process.env.NODE_ENV===<span class="branch-0 cbranch-no" title="branch not covered" >"production")return s;let a=e.getLocation();if(!a||!a.lineNumber||!a.columnNumber)return s;let l=Math.max(1,a.lineNumber-3),u=vn.read(a.fileName)?.slice(l,a.lineNumber),c=u?.lineAt(a.lineNumber);if(u&amp;&amp;c</span>){<span class="branch-0 cbranch-no" title="branch not covered" >let p=Sd(c),d=Td(c);if(!</span>d)<span class="branch-0 cbranch-no" title="branch not covered" >return s;s.functionName=`${d.code})`,s.location=a,n||(u=u.m</span>apLineAt(a.lineNumber,h=&gt;h.slice(0,d.<span class="branch-0 cbranch-no" title="branch not covered" >openingBraceIndex))),u=o.highlightSource(u);let f=String(u.lastLineNumber).length;if(s.contextLines=u.mapLines((</span>h,<span class="branch-0 cbranch-no" title="branch not covered" >g)=&gt;o.gray(String(g</span>).<span class="branch-0 cbranch-no" title="branch not covered" >padStart(f))+" "+h).mapLines(h=&gt;o.dim(h</span>)).<span class="branch-0 cbranch-no" title="branch not covered" >prependSymbolAt(a.lineNumber,o.bold(o.red("\u2192"))),i){let h=p+f+1;h+=2,s.callArguments=(0,na.default)(i,h</span>).<span class="branch-0 cbranch-no" title="branch not covered" >slice(h)}}return s</span>}function Td(e){let <span class="branch-0 cbranch-no" title="branch not covered" >r=Object.keys(Sr).join("|"),n=new RegExp(String.raw`\.(${r})\(`).exec(e);if(n){let i=n.index+n[0].length,o=e.lastIndexOf(" ",n.index)+1;return{code:e.slice(o,i),openingBraceIndex:i}}return null}function Sd(e){let r=0;for(let t=0;t&lt;e.length;t++){if(e</span>.charAt(t)!==" ")<span class="branch-0 cbranch-no" title="branch not covered" >return r;r++}return r</span>}function Rd({functionName:e,location:r,message:t,isPanic:n,<span class="branch-0 cbranch-no" title="branch not covered" >contextLines:i,callArguments:o},s){let a=[""],l=r?" in":":";if(n?(a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)),a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)</span>} invocation${l}`))):a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)),r&amp;&amp;a.push(s.underline(Ad(r))),<span class="branch-0 cbranch-no" title="branch not covered" >i){a.push("");let u=[i.toString()];o&amp;&amp;(u.push(o),u.push(s.dim(")"))),a.push(u.join("")),o&amp;&amp;a.push("")}else a.push(""),o&amp;&amp;a.push(o),a.push("");return a.push(t),a.join(`</span>
`)}function Ad(e){let r=[e.fileName];return e.lineNumber&amp;&amp;r.push(String(e.lineNumber)),e.columnNumber&amp;&amp;r.push(String(e.columnNumber)),r.join(":")}function Pn(e){let r=e.showColors?wd:xd,t;return t=Pd(e,r),Rd(t,r)}var da=A(Ki());function aa(e,r,t){let n=la(e),<span class="branch-0 cbranch-no" title="branch not covered" >i=Cd(n),o=Dd(i);o?Tn(o,r,t):r.addErrorMessage(()=&gt;"Unknown error")}function la(e){return e.errors.flatMap(r=&gt;r.kind==="Union"?l</span>a(r):[r])}function Cd(e){let r=new Map,t=[];for(let n of e){if(n.kind!==<span class="branch-0 cbranch-no" title="branch not covered" >"InvalidArgumentType"){t.push(n);continue}let i=`${n</span>.<span class="fstat-no" title="function not covered" >selectionPath.join(".")}:${n.argumentPath.join(".")}`,o=r.get(i);o?r.set(i,{...n,argument:{...n.argument,typeNames:Id(o.argument.typeNames,n.argument.typeNames)}}):r.set(i,n)}return t.push(...r.values()),t}function Id(e,r){<span class="fstat-no" title="function not covered" >return[</span>...new Set(e.concat(r))]}function Dd(<span class="fstat-no" title="function not covered" >e){</span>return ji(e,(r,t)=&gt;{let n=oa(r<span class="fstat-no" title="function not covered" >)</span>,i=oa(t);return n!==i?n-i:sa(r)-sa(t)})}function oa(e){<span class="fstat-no" title="function not covered" >let r</span>=0;return Array.isArray(e.selectionPath)&amp;&amp;(r+=e.selectionPath.length),Array.isArray(e.argumentPath)&amp;&amp;(r+=e.argumentPath.length),r}function sa(e){switch(e.kind){case"</span>InvalidArgumentValue":case"ValueTooLarge":return 20;case"InvalidArgumentType":return <span class="fstat-no" title="function not covered" >10;case"RequiredArgumentMissing":return-10;default:return 0</span>}}var ue=class{constructor(r,t){this.name=r;this.value=t}isRequired=!1;makeRequired(){return this.isRequired=!0,this}write(r){let{colors:{green:t}}=r.context;r.addMarginSymbol(t(this.isRequired?"+":"?")),r.write(t(this.name)),this.isRequired||r.write(t("?")),r.write(t(": ")),typeof this.value=="string"?r.write(t(this.value)):r.write(this.<span class="branch-0 cbranch-no" title="branch not covered" >value)}};ca();var Rr=c</span>lass{constructor(r=0,t){this.context=t;<span class="branch-0 cbranch-no" title="branch not covered" >this.currentIndent=r</span>}lines=[];currentLine="";currentIndent=0;marginSymbol;afterNextNewLineCallback;write(r){return typeof r=="string"?this.currentLine+=r:r.write(<span class="branch-0 cbranch-no" title="branch not covered" >this),this}writeJoined(r,t,n=(i,o)=&gt;o.write(i)){let i</span>=t.length-1;for(let o=0;o&lt;t.length;o++)n(t[o],this),o!==i&amp;&amp;this.write(r);return <span class="branch-0 cbranch-no" title="branch not covered" >this}writeLine(r){return this.write(r).newLine()</span>}newLine(){this.lines.push(this.indentedCurrentLine()),this.currentLine=<span class="fstat-no" title="function not covered" >"",this.marginSymbol=void 0;let r=this.afterNextNewLineCallback;return this.afterNextNewLineCallback=void 0,r?.(),this}withIndent(r){return t</span>his.indent(),r(this),this.unindent(),this<span class="fstat-no" title="function not covered" >}afterNextNewline(r){return this.afterNextNewLineCallback=r,this}indent(){<span class="fstat-no" title="function not covered" >return t</span>his.currentIndent++,this}unindent(){return this.currentIndent&gt;0</span>&amp;&amp;this.currentIndent--,this}addMarginSymbol(r){<span class="fstat-no" title="function not covered" >return this.<span class="fstat-no" title="function not covered" >marginSymbol=r</span>,this}toString(){return this.lines.concat(this.indentedCurrentLine()<span class="fstat-no" title="function not covered" >).j</span>oin(`</span>
`)}getCurrentLineLength(){return this.currentLine.length}indentedCurrentLine(){let <span class="fstat-no" title="function not covered" >r=this.currentLine.padStart(this.currentLine.length+2*this.currentIndent);return <span class="fstat-no" title="function not covered" >t</span>his.marginSymbol?this.<span class="fstat-no" title="function not covered" >marginSymbol+r</span>.slice(1):r}};ua();var <span class="fstat-no" title="function not covered" >Sn=c</span>lass{constructor(r){this.<span class="fstat-no" title="function not covered" >value=r</span>}write(r){r.write(this.v</span>alue)}markAsError(){this.value.markAsError()}};var Rn=e=&gt;e,An={bold:Rn,red:Rn,green:Rn,dim:Rn,enabled:!1},pa={bold:W,red:ce,<span class="branch-0 cbranch-no" title="branch not covered" >green:qe,dim:Ce,enabled:!0},Ar={write(e){e.writeLine(",")}};var Pe=class{constructor(r){this.contents=r}</span>isUnderlined=!1;color=r=&gt;r;underline(){return this.isUnderlined=!0,this}setColor(r){return this.color=r,this}<span class="branch-0 cbranch-no" title="branch not covered" >write(r){let t=r.getCurrentLineLength();r.write(this.color(this.contents)),this.isUnderlined&amp;&amp;r.afterNextNewline(()=&gt;{r.write(" ".repeat(t)).writeLine(this.color("~".repeat(this.contents.length))<span class="fstat-no" title="function not covered" >)}</span>)}};var ze=class{hasError=!1;markAsError(){return this.hasError=!0,<span class="fstat-no" title="function not covered" >this}</span>};var Cr=class extends ze{items=[];addItem(r){return this.items.push(new Sn(r)),<span class="fstat-no" title="function not covered" >this}</span>getField(r){return this.items[r]}getPrintWidth(){return this.items.length===0?<span class="fstat-no" title="function not covered" >2:M</span>ath.max(...this.items.map(t=&gt;t.value.getPrintWidth()))+2}write(r){if(<span class="fstat-no" title="function not covered" >t</span>his.items.length===0){this.writeEmpty(r);return}this.writeWithItems(r)}writeEmpty(r){let t=new Pe("[]");this.hasError&amp;&amp;t.setColor(r.context.colors.red).underline(),r</span>.write(t)}writeWithItems(r){let{<span class="fstat-no" title="function not covered" >colors:t}=r.context;r.writeLine("</span>[").withIndent(()=&gt;r.writeJoined(Ar,this.items).<span class="fstat-no" title="function not covered" >newLine()).write("]"),this.hasError&amp;&amp;r</span>.afterNextNewline(()=&gt;{r.writeLine(t.red("~".repeat(this.getPrintWidth())))})}asObject(){}};var Ir=class e extends ze{fields={};suggestions=[];addField(r){this.fields[r.name]=r}addSuggestion(r){this.suggestions.push(r)}getField(r){return this.fields[r]}getDeepField(r){let[t,...n<span class="fstat-no" title="function not covered" >]=r,i=this.getField(t</span>);if(!i)return;<span class="fstat-no" title="function not covered" >let <span class="fstat-no" title="function not covered" >o</span>=i;for(let <span class="fstat-no" title="function not covered" >s</span> of n){let a;if(o.<span class="fstat-no" title="function not covered" >value instanceof e</span>?a=o</span>.value.getField(s):o.value instanceof Cr&amp;&amp;(a=o.value.getField(Number(s))),!a)return;o=a}<span class="branch-0 cbranch-no" title="branch not covered" >return o}getDeepFieldValue(r</span>){return r.length===0?<span class="fstat-no" title="function not covered" >this:this.getDeepField(r)?.value}hasField(r){return!!this.getField(r)<span class="fstat-no" title="function not covered" >}</span>removeAllFields(){this.fields={}}removeField(r){delete this.fields[r]}getFields(){</span>return this.<span class="branch-0 cbranch-no" title="branch not covered" >fields}isEmpty(){return Object.<span class="branch-0 cbranch-no" title="branch not covered" >k</span>eys(t</span>his.fields).length===0}getFieldValue(r){return this.getField(r)?.value}getDeepSubSelectionValue(r){<span class="branch-0 cbranch-no" title="branch not covered" >let t=this;f</span>or(let n of r){if(!(t instanceof e))return;let i=t.<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >getSubSelectionValue(n</span>);if(!i)return;t=i}return t}<span class="fstat-no" title="function not covered" ></span>getDeepSelectionParent(r){let t</span>=<span class="fstat-no" title="function not covered" >this.getSelectionParent();if(!t)return;let n</span>=t;for(let i of r){let o=n.value.getFieldValue(i);if(!o||!(<span class="fstat-no" title="function not covered" >o instanceof e))return;let s=o.getSelectionParent();if(!</span>s)return;n=s}<span class="fstat-no" title="function not covered" >return n}<span class="fstat-no" title="function not covered" >getSelectionParent(){<span class="fstat-no" title="function not covered" ></span>let r</span>=this.getField("select")?.value.asObject();if(r)return{kind:"select",value:r};let <span class="fstat-no" title="function not covered" >t=t</span>his.getField("include")?.value.asObject();if(t)return{kind:"include",value:t}}<span class="fstat-no" title="function not covered" >g</span>etSubSelectionValue(r){return this.getSelectionParent()?.value.fields[r].value}getPrintWidth(){let r=Object.values(this.fields);return r.length==0?2:Math.max(...r.map(n=&gt;n.getPrintWidth()))+2}<span class="fstat-no" title="function not covered" >write(r</span>){let t=Object.values(this.fields);if(t.length===0&amp;&amp;this.suggestions.length===0){this.writeEmpty(r);return}this.writeWithContents(r,t)}asObject(){return this}writeEmpty(r</span>){<span class="fstat-no" title="function not covered" >let t=new Pe("{}");this.hasError&amp;&amp;t.setColor(r.context.colors.red).underline(),r.write(t)}writeWithContents(r,t){r.w</span>riteLine("{").withIndent(()=&gt;{r.writeJoined(Ar,[...t,...this.suggestions]).newLine()}),r.write("}"),this.hasError&amp;&amp;r.afterNextNewline(()=&gt;{r.<span class="fstat-no" title="function not covered" >writeLine(r.context.colors.red("~".repeat(this.getPrintWidth())))})}};var Q=class extends ze{constructor(t){super();this.text=t}getPrintWidth(){return this.text.length}write(t){let n=new Pe(this.text);this.hasError&amp;&amp;n.underline().setColor(t.context.c</span>olors.red),t.write(n)}asObject(){}};var ct=class{fields=[];addField(r,t){return <span class="fstat-no" title="function not covered" >this.fields.push({write(n){let{green:i,dim:o}=n.context.colors;n.write(i(o(`${r}: ${t}`))).addMarginSymbol(i(o("</span>+")))}}),this}write(r){let{colors:{green:t}}=r.context;r.writeLine(t("{")).withIndent(()=&gt;{r.writeJoined(Ar,this.fields).newLine()}).write(<span class="fstat-no" title="function not covered" >t("}")).addMarginSymbol(t("+"))}};function Tn(e,r,t){switch(e.kind){case"MutuallyExclusiveFields":Od(e,r);break;case"IncludeOnScalar":kd(e,r);break;case"EmptySelection":_d(e,r,t);break;c</span>ase"UnknownSelectionField":Md(e,r);<span class="fstat-no" title="function not covered" >break;case"InvalidSelectionValue":$d(e,r);break;case"UnknownArgument":qd(e,r);break;case"UnknownInputField":V</span>d(e,r);break;case"RequiredArgumentMissing":jd(e,r<span class="fstat-no" title="function not covered" >);break;case"InvalidArgumentType":Bd(e,r);break;case"InvalidArgumentValue":Ud(e,r);<span class="fstat-no" title="function not covered" >break;c</span>ase"ValueTooLarge":Gd(e</span>,r);break;case<span class="fstat-no" title="function not covered" >"SomeFieldsMissing":Qd(e,r);break;case"TooManyFieldsGiven":Wd(e,r);break;case"Union":aa(e,r,t);break;default:throw new Error("not implemented: "+e.kind)}}function Od(e,r){let t=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();t&amp;&amp;(t.getField(e.firstField)?.markAsError(),t.getField(e.secondField)?.markAsError()),r.addErrorMessage(n=&gt;`Please ${n.bold("either")} use ${n.green(`\`${e.firstField}\``)} or ${n.green(`\`${e.secondField}\``)}, but ${n.red("not both")} at the same time.`)}function k</span>d(e,r){let[t,n]=Dr(<span class="branch-0 cbranch-no" title="branch not covered" >e.selectionPath),i=e.outputType,o=r.arguments.getDeepSelectionParent(t</span>)?.value;if(o&amp;&amp;(o.getField(n)?.markAsError(),i))<span class="fstat-no" title="function not covered" >for(let s of i.fields)s.isRelation&amp;&amp;o.addSuggestion(new ue(s.name,"true"));r.addErrorMessage(s=&gt;{let a=<span class="fstat-no" title="function not covered" >`Invalid scalar field ${s</span>.red(`\`${n}\``)} for ${s.bold("include")} statement`;return i?<span class="fstat-no" title="function not covered" >a+=`</span> on model ${s.bold(i.name)}. ${pt(s)}`:a+=".",a+=`</span>
Note that ${s.bold(<span class="fstat-no" title="function not covered" >"include")} statements only accept relation fields.`,a})}function _d(e,r,t){<span class="fstat-no" title="function not covered" >let n</span>=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(n){let i=n.getField(<span class="fstat-no" title="function not covered" >"omit")</span>?.value.asObject();if(i){Nd(e,r,i);return}if(n.<span class="fstat-no" title="function not covered" >hasField("</span>select")){Ld(e,r);return}}if(t?.[We(e.<span class="fstat-no" title="function not covered" >o</span>utputType.name)]){Fd(e,r);return}r.addErrorMessage(()=&gt;`Unknown field at "${e.selectionPath.join(".")} selection"`)}function Nd(e,<span class="fstat-no" title="function not covered" >r,t</span>){t.removeAllFields();for(let n of e.outputType.fields)t.addSuggestion(new ue(n.name,<span class="fstat-no" title="function not covered" >"false")</span>);r.addErrorMessage(n=&gt;`The ${n.red("omit")<span class="fstat-no" title="function not covered" >} statement includes every field of the model ${n</span>.bold(e.outputType.name)}. At least one field must be included in the result`)}function Ld(<span class="fstat-no" title="function not covered" >e</span>,r){let t=e.outputType,n=r.arguments.getDeepSelectionParent(e.selectionPath)?.value,i=n?.isEmpty()??!1;n&amp;&amp;(n.removeAllFields(),ga(n,t)),r.addErrorMessage(o=&gt;i?`The ${o.red("`select`")} statement for type ${o</span>.bold(t.name)<span class="branch-0 cbranch-no" title="branch not covered" >} must not be empty. ${p</span>t(o)}`:`The ${o.red("`select`")<span class="fstat-no" title="function not covered" >} statement for type ${o.bold(t.name)} needs ${o.bold("at least one truthy value")}.`)}function F</span>d(e,r){let t=new <span class="branch-0 cbranch-no" title="branch not covered" >ct;for(let <span class="branch-0 cbranch-no" title="branch not covered" >i</span> of e.outputType.f</span>ields)i.isRelation||t.addField(i.<span class="branch-0 cbranch-no" title="branch not covered" >name,"false");let n</span>=new ue("omit",t).makeRequired();if(e.selectionPath.length===0)r.arguments.addSuggestion(n);else{let[i,o]=Dr(e.selectionPath),a=r.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o);if(a){let l=a?.<span class="branch-0 cbranch-no" title="branch not covered" >value.asObject()??new Ir;l.addSuggestion(n),a</span>.value=l}}r.addErrorMessage(i=&gt;`The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(e.outputType.name)}. At least one field must be included in the result`)}function Md(e,r){let t=ha(e.selectionPath,r);if(t.parentKind!=="unknown"){t.field.markAsError();let n=t.parent;switch(t.parentKind){case"select":ga(n,e.outputType);break;case"include":Jd(n,e.outputType);break;case"omit":Kd(n,e.outputType);break}}r.addErrorMessage(n=&gt;{let i=[`Unknown field ${n.red(`\`${t.fieldName}\``)}`];return t.parentKind!=="unknown"&amp;&amp;i.push(`for ${n.bold(t.parentKind)} statement`),i.push(`on model ${n.bold(`\`${e.outputType.name}\``)}.`),i.push(pt(n)),i.join(" ")<span class="branch-0 cbranch-no" title="branch not covered" >})}function $</span>d(e,r){let t=ha(e.selectionPath,r);t.parentKind!=="unknown"&amp;&amp;t.field.value.markAsError(),r.addErrorMessage(n=&gt;`Invalid value for selection field \`${n.red(t.fieldName)}\`: ${e.underlyingError}`)}function qd(e,r){let t=e.argumentPath[0],n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.<span class="branch-0 cbranch-no" title="branch not covered" >asObject();n&amp;&amp;(n</span>.getField(t)?.markAsError(),Hd(n,e.arguments)),r.addErrorMessage(i=&gt;ma(i,t,e.arguments.map(o=&gt;o.name)))}function Vd(e,r){let[t,n]=Dr(e.argumentPath),i=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(i){i.getDeepField(e.argumentPath)?.markAsError();let o=i.getDeepFieldValue(t)?.asObject();o&amp;&amp;ya(o,e.inputType<span class="branch-0 cbranch-no" title="branch not covered" >)}r.addErrorMessage(o=&gt;ma(o,n,e.inputType.f</span>ields.map(s=&gt;s.name)))}function ma(<span class="branch-0 cbranch-no" title="branch not covered" >e,r,t){let n=[</span>`Unknown argument \`${e.red(r)<span class="branch-0 cbranch-no" title="branch not covered" >}\`.`<span class="fstat-no" title="function not covered" >],i</span>=zd(r,t);return i&amp;&amp;n.push(`Did you mean \`${e.green(i)}\`?`),t.length&gt;0&amp;&amp;n.push(pt(e)),n.join(" ")}function jd(e,r){let t;r.addErrorMessage(l=&gt;t?.value instanceof Q&amp;&amp;t.value.text==="null"?`Argument \`${l.green(o)}\` must not be ${l.red("null")}.`:`Argument \`${l.green(o)}\` is missing.`);let n=r.arguments.<span class="fstat-no" title="function not covered" >getDeepSubSelectionValue(e</span>.selectionPath)?.asObject();if(!n)return;let[i,o]=Dr(e.argumentPath),s=new ct,a=n.getDeepFieldValue(i)?.asObject();if(a){if(t=a.getField(o),t&amp;&amp;a.removeField(o),e.inputTypes.length===1&amp;&amp;e.inputTypes[0].kind==="object"){for(let l of e.inputTypes[0].fields)s.addField(l.name,l.typeNames.join(" | "));a.addSuggestion(new ue(o,s).<span class="fstat-no" title="function not covered" >makeRequired()</span>)}else{let l=e.<span class="fstat-no" title="function not covered" >inputTypes.m</span>ap(fa).join(" | ");a.addSuggestion(new <span class="fstat-no" title="function not covered" >ue(o</span>,l).makeRequired())}if(e.dependentArgumentPath){n.getDeepField(e.dependentArgumentPath)?.markAsError();let[,l]=Dr(e.dependentArgumentPath);r.addErrorMessage(u=&gt;`Argument \`${u.green(o)}\` is required because argument \`${u.green(l)}\` was provided.`)}}}function fa(e){return e.kind==="list"?`${fa(e.elementType)}[]`:e.name}function Bd(<span class="fstat-no" title="function not covered" >e,r</span>){let t=e.argument.name,n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&amp;&amp;n.getDeepFieldValue(e.argumentPath)?.markAsError(),r.addErrorMessage(i=&gt;{let o=Cn("or",e.argument.typeNames.map(s=&gt;i.green(s)));return`Argument \`${i.bold(t)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e</span>.inferredType)}.`})}function Ud(e,r){let t=e.argument.name,n=r.arguments.<span class="branch-0 cbranch-no" title="branch not covered" >getDeepSubSelectionValue(e.selectionPath)?.asObject(<span class="branch-0 cbranch-no" title="branch not covered" >)</span>;n&amp;&amp;n.getDeepFieldValue(e.argumentPath)?.markAsError(),<span class="fstat-no" title="function not covered" >r.addErrorMessage(i=&gt;{let o=[`Invalid value for argument \`${i.bold(t)}\``];if(e.underlyingError&amp;&amp;o.push(`: ${e</span></span>.underlyingError}`),o.push("."),e.argument.typeNames.length&gt;0)<span class="fstat-no" title="function not covered" >{let s=Cn("or",e.argument.typeNames.map(a=&gt;i.green(a)));o.push(` Expected ${s}.`)}return o.join("")})}function Gd(e,r){let t=e.argument.name,n=<span class="fstat-no" title="function not covered" >r.a</span>rguments.getDeepSubSelectionValue(e.<span class="fstat-no" title="function not covered" >selectionPath)</span>?.asObject(),i;if(n){let s=<span class="fstat-no" title="function not covered" >n</span>.getDeepField(e.argumentPath)?.value;s?.markAsError(),s instanceof Q&amp;&amp;(i=s.text)}r.addErrorMessage(o=&gt;{let s=["Unable to fit value"];return i&amp;&amp;s.push(o.red(i)),s.push(`into a 64-bit signed integer for field \`${o.bold(t)}\``),s.join(" ")})}function Qd(e,r){let t=e.argumentPath[e.argumentPath.length-1],n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(n){let <span class="fstat-no" title="function not covered" >i=n</span>.getDeepFieldValue(e.argumentPath)?.asObject();i&amp;&amp;ya(i,e.inputType)}r.addErrorMessage(i=&gt;{let o=[`Argument \`${i.bold(t)}\` of type ${i.bold(e.inputType.name)} needs`];return e.constraints.minFieldCount===1?e.constraints.requiredFields?o.push(`${i.green("at least one of")} ${Cn("or",e.constraints.requiredFields.map(s=&gt;`\`${i.bold(s)}\``))} arguments.`):o.push(`${i.green("at least one")</span>} argument.`):o.push(`${i.green(`at least ${e.constraints.<span class="branch-0 cbranch-no" title="branch not covered" >minFieldCount}</span>`)} arguments.`),o.push(pt(i)),o.join(" "<span class="branch-0 cbranch-no" title="branch not covered" >)})}function Wd(e,r){let t=e.argumentPath[e</span>.argumentPath.length-1],n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i=[];if(n){let o=n.<span class="fstat-no" title="function not covered" >getDeepFieldValue(e.argumentPath)?.asObject();o&amp;&amp;(o.markAsError(),i=Object.keys(o.getFields()))}r.addErrorMessage(o=&gt;{let s=[`Argument \`${o.bold(t)}\` of type ${o.bold(e.inputType.name)} needs`];return e.constraints.minFieldCount===1&amp;&amp;e.constraints.maxFieldCount==1?s.push(`${o.green("exactly one")} argument,`):e.constraints.maxFieldCount==1?s.push(`</span>${<span class="fstat-no" title="function not covered" >o.<span class="fstat-no" title="function not covered" >green("</span>at most one")} argument,`):s.push(`${o</span>.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`),s.push(`but you provided ${Cn("and",i.map(a=&gt;o.red(a)))}. Please choose`),e.constraints.maxFieldCount===1?s.push("one."):s.<span class="branch-0 cbranch-no" title="branch not covered" >push(`${e.<span class="branch-0 cbranch-no" title="branch not covered" >constraints.m</span>axFieldCount}.`),s.join(" ")})}function ga(e,r){for(let t of r.fields)e.hasField(t.name)||e.addSuggestion(new ue(t.name,"true"))}function Jd(e,r){for(let t of r.fields)t.isRelation&amp;&amp;!e.hasField(t.name)&amp;&amp;e.addSuggestion(new ue(t.name,"true"))}function Kd(e,r){for(let t of r.fields)!e.h</span>asField(t.name)&amp;&amp;!t.isRelation&amp;&amp;<span class="branch-0 cbranch-no" title="branch not covered" >e.addSuggestion(n</span>ew ue(t.<span class="branch-0 cbranch-no" title="branch not covered" >name,"true"))}function Hd(e,r)<span class="branch-0 cbranch-no" title="branch not covered" >{<span class="fstat-no" title="function not covered" ></span>for(let t</span> of r)e.hasField(t.name)||e.<span class="fstat-no" title="function not covered" >addSuggestion(n</span>ew ue(t.name,t.typeNames.join(" | ")))}function ha(<span class="fstat-no" title="function not covered" >e</span>,r){let[t,n]=D</span>r(<span class="fstat-no" title="function not covered" >e),i=r.arguments.<span class="fstat-no" title="function not covered" >getDeepSubSelectionValue(t</span>)?.asObject();if(!i)return{<span class="fstat-no" title="function not covered" >parentKind:"</span>unknown",fieldName:n};let o=i.getFieldValue(<span class="fstat-no" title="function not covered" >"select")</span>?.asObject(),s=i.getFieldValue("include")?.asObject(),a=i.getFieldValue("omit")?.asObject(),l=o?.getField(n);return o&amp;&amp;l?{p</span>arentKind:"select",parent:o,field:l,fieldName:n}:(l=s?.getField(n),s&amp;&amp;l?{parentKind:"include",field:l,parent:s,fieldName:n}:(l=a?.getField(n),a&amp;&amp;l?{parentKind:"omit",field:l,parent:a,fieldName:n}:{parentKind:"unknown",fieldName:n}))}<span class="fstat-no" title="function not covered" >function ya(e,r){if(r.kind==="object")for(let t of r.fields)e.hasField(t.name)||e.addSuggestion(new ue(t.n</span>ame,t.typeNames.join(" | ")))}function Dr(e){<span class="fstat-no" title="function not covered" >let r=[...e],t=r.pop();if(!t)throw new Error("unexpected empty path");return[r,t]}function pt({green:e,enabled:r}){return<span class="fstat-no" title="function not covered" >"Available options are "+(r</span>?`listed in ${e("green")}`:"marked with ?")+"."}function Cn(e,r){if(r.length===1)return r[0];let t=[...r],n=<span class="fstat-no" title="function not covered" >t.p</span>op();return`${t.join(", ")} ${e} ${n}`}var Yd=3;function zd(e,r){let t=1/0,n;for(let i of <span class="fstat-no" title="function not covered" >r</span>){let o=(0,da.default)(e,i);o&gt;Yd||o&lt;t&amp;&amp;(t=o,n=i)}return n}var dt=class{modelName;name;<span class="fstat-no" title="function not covered" >t</span>ypeName;isList;isEnum;constructor(r,t,n,i,o){this.modelName=r,this.name=t,this.typeName=n,this.isList=i,this.isEnum=o}_toGraphQLInputType(){<span class="fstat-no" title="function not covered" >let r</span>=this.isList?"List":"",t=this.isEnum?"Enum":"";return`${r}${t}${this.typeName}FieldRefInput&lt;${this.modelName}&gt;`}};function Or(e){<span class="fstat-no" title="function not covered" >return e</span> instanceof dt}var In=Symbol(),Yi=new WeakMap,Me=class{constructor(r){r===In?Yi.set(this,`Prisma.${this._getName()}`):Yi.set(this,<span class="fstat-no" title="function not covered" >`new Prisma.${t</span>his._getNamespace()}.${this._getName()}()`)}_getName(){return this.constructor.name}toString(){return Yi.get(this)}},mt=class extends Me{_getNamespace(){return"NullTypes"}},ft=class extends mt{#e};zi(ft,"DbNull");var gt=class extends <span class="fstat-no" title="function not covered" >mt{</span>#e};zi(gt,"JsonNull");var ht=class extends mt{#e};zi(ht,"AnyNull");var Dn={classes:{DbNull:ft,JsonNull:gt,AnyNull:ht},instances:{DbNull:new ft(In),JsonNull:new gt(In),AnyNull:new ht(In)}};function zi(e,<span class="fstat-no" title="function not covered" >r){</span>Object.defineProperty(e,"name",{value:r,configurable:!0})}var ba=": ",On=class{constructor(r,t){this.name=r;this.value=t}hasError=!1;markAsError(){this.hasError=!0}getPrintWidth(){return this.name.length+this.value.getPrintWidth()</span>+ba.length}write(r){let t=new Pe(<span class="fstat-no" title="function not covered" >this.name);this.hasError&amp;&amp;t.underline().setColor(r</span>.context.colors.red),r.write(t).write(ba).write(this.value)}};var Zi=class{arguments;errorMessages=[];constructor(r){this.<span class="branch-0 cbranch-no" title="branch not covered" >arguments=r</span>}write(r){r.write(this.arguments)}addErrorMessage(r){this.<span class="branch-0 cbranch-no" title="branch not covered" >errorMessages.push(r</span>)}renderAllMessages(r)<span class="branch-0 cbranch-no" title="branch not covered" >{return this.errorMessages.map(t=&gt;t(r)).join(`</span>
`)}};function kr(e){return new Zi(Ea(e))}function Ea(e){let r=new Ir;for(let[t,n]of Object.entries(e)){let i=new On(t,wa(n));r.addField(i)}return r}function wa(e){if(typeof e=="string")return new Q(JSON.stringify(e)<span class="branch-0 cbranch-no" title="branch not covered" >);if(typeof e=="number"||typeof e</span>=="boolean")return new Q(String(e));if(typeof e=="bigint")return new Q(`${e}n`);if(e===null)return new Q("null");<span class="branch-0 cbranch-no" title="branch not covered" >if(e===v</span>oid 0)return new Q("undefined");if(Tr(e))return new Q(`new Prisma.Decimal("${e.toFixed()}")`);if(<span class="branch-0 cbranch-no" title="branch not covered" >e instanceof Uint8Array)return B</span>uffer.isBuffer(e)?new Q(`Buffer.alloc(${e.byteLength})`):new Q(`new Uint8Array(${e.byteLength})`);if(<span class="branch-0 cbranch-no" title="branch not covered" >e instanceof Date){let r=dn(e)?e.toISOString()</span>:"Invalid Date";return new Q(<span class="branch-0 cbranch-no" title="branch not covered" >`new Date("${r}")`)}return e instanceof Me?n</span>ew Q(<span class="fstat-no" title="function not covered" >`Prisma.${e._getName()}`):Or(e)?new Q(`prisma.${We(e.modelName)}.$fields.${e.name}`):Array.isArray(e<span class="fstat-no" title="function not covered" >)?Z</span>d(e):typeof e=="object"?Ea(e):new Q(Object.prototype.toString.call(e))}function Zd(e){let r=new Cr;for(let t of e)r.addItem(wa(t));return r</span>}<span class="fstat-no" title="function not covered" >function kn(e,r){let t=r==="pretty"?pa:An,n=e.renderAllMessages(t),i=new Rr(0,{colors:t}).write(e).toString();return{<span class="fstat-no" title="function not covered" >message:n</span>,args:i}}function _n({args:e,errors:r,errorFormat:t,callsite:n,originalMethod:i,clientVersion:o,globalOmit:s}){let a=kr(e);for(let p of r)Tn(p,a,s);let{message:l,args:u}=kn(a,t),c=Pn({message:l,callsite:n,originalMethod:i,showColors:t==="pretty",callArguments:u});throw new Z(c,{clientVersion:o})}function Te(e){return e.replace(/^./,r=&gt;r.toLowerCase())}function va(e,r,t){let n=Te(t);return!r.result||!(r.result.$allModels||r.result[n])?e:Xd({...e,...xa(r.name,e,r.result.$allModels),...xa(r.name,e,r.result[n])})}function Xd(e){let r=new we,t=(n,i)=&gt;r.getOrCreate(n,()=&gt;i.has(n)?[n]:(i.add(n),e[n]?e[n].needs.flatMap(o=&gt;t(o,i)):[n]));return cn(e,n=&gt;({...n,needs:t(n.name,new Set)}))}function xa(e,r,t){return t?cn(t,({needs:n,compute:i},o)=&gt;({name:o,needs:n?Object.keys(n).filter(s=&gt;n[s]):[],compute:em(r,o,i)})):{}}function em(e,r,t){let n=e?.[r]?.compute;return n?i=&gt;t({...i,[r<span class="fstat-no" title="function not covered" >]:n</span>(i)}):t}function Pa(e,r){</span>if(!r)return e;let t={...e};for(let n of Object.values(r))if(e[n.name])for(let i of n.needs)t[i]=!0;return t}function Ta(e,r){if(!r)return e;let t={...e};for(let n of Object.values(r))if(!e[n.name])for(let i of n.needs)delete t[<span class="branch-0 cbranch-no" title="branch not covered" >i];r</span>eturn t}var Nn=class{constructor(r,t)<span class="branch-0 cbranch-no" title="branch not covered" >{this.extension=r;this.previous=t}computedFieldsCache=new we;modelExtensionsCache=new we;queryCallbacksCache=n</span>ew we;<span class="branch-0 cbranch-no" title="branch not covered" >clientExtensions=at(()=&gt;this.extension.client?{...this.previous?.getAllClientExtensions(),...this.extension.c</span>lient}:this.previous?.getAllClientExtensions());batchCallbacks=at(()=&gt;{let r=this.previous?.getAllBatchQueryCallbacks(<span class="branch-0 cbranch-no" title="branch not covered" >)??[</span>],t=this.<span class="branch-0 cbranch-no" title="branch not covered" >extension.<span class="branch-0 cbranch-no" title="branch not covered" >q</span>uery?.<span class="branch-0 cbranch-no" title="branch not covered" >$</span>__internalBatch;return t</span>?r.concat(t):r});getAllComputedFields(r){<span class="branch-0 cbranch-no" title="branch not covered" >return this.computedFieldsCache.getOrCreate(r,()=&gt;va(this.previous?.<span class="branch-0 cbranch-no" title="branch not covered" >getAllComputedFields(r</span>),this.extension,r))}getAllClientExtensions(){return this.c</span>lientExtensions.get()}<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >getAllModelExtensions(r){return this.modelExtensionsCache.getOrCreate(r,()=&gt;{let t=Te(r);return!this.extension.model||!(this.e</span></span>xtension.model[t<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >]||this.extension.model.$allModels)?this.previous?.getAllModelExtensions(r):<span class="fstat-no" title="function not covered" >{</span></span>...this.previous?.getAllModelExtensions(r)</span>,...this.extension.<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >model.$allModels,...this.extension.model[t]}})}getAllQueryCallbacks(r</span></span>,t){return this.<span class="fstat-no" title="function not covered" >queryCallbacksCache.getOrCreate(`${r}:${t}`,()=&gt;{let n=this.previous?.getAllQueryCallbacks(r,t)??[],i=[],o=this.extension.query;return!o||!(o[r]||o.$allModels||o[t]||o.$allOperations)?n:(o[r]!==void 0&amp;&amp;(o[r][t]!==void 0&amp;&amp;i.push(o[r][t]),o[r].$allOperations!==void 0&amp;&amp;i.push(o[r].$allOperations)),r!=="$none"&amp;&amp;o.$allModels!==void 0&amp;&amp;(o.$allModels[t]!==void 0&amp;&amp;i.push(o.$allModels[t]),o.$allModels.$allOperations!==void 0&amp;&amp;i.push(o.$allModels.$allOperations)),o[t]!==void 0&amp;&amp;i.push(o[t]),o.$allOperations!==void 0&amp;&amp;i.push(o.$allOperations),n.concat(i))})}getAllBatchQueryCallbacks(){return this.batchCallbacks.get()}},_r=class e{constructor(r){this.head=r}static empty(){return new e</span>}static <span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >single(r){return new e(new Nn(r))}isEmpty(){return this.head===void 0}append(r){return new e(new Nn(r,this.head))}getAllComputedFields(r){return this.head?.getAllComputedFields(r)}getAllClientExtensions(){return this.head?.getAllClientExtensions()}getAllModelExtensions(r){return this.head?.getAllModelExtensions(r)}getAllQueryCallbacks(r,t){return this.head?.getAllQueryCallbacks(r,t)??[]}getAllBatchQueryCallbacks(){return this.head?.getAllBatchQueryCallbacks()??[]}};var Ln=class{constructor(r){this.name=r}};function Sa(e){return e instanceof Ln}function Ra(e){return new Ln(e)}var Aa=Symbol(),yt=class{<span class="fstat-no" title="function not covered" >constructor(r</span></span>){if(r!==Aa)throw new Error(<span class="fstat-no" title="function not covered" >"</span>Skip instance can not be constructed directly")</span>}<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >ifUndefined(r){return r===void 0?Fn:r}},Fn=new yt(Aa);function Se(e){return e instanceof y</span></span>t}var rm={findUnique:<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >"findUnique",findUniqueOrThrow:"findUniqueOrThrow",findFirst:"findFirst",findFirstOrThrow:"</span></span>findFirstOrThrow",findMany:"findMany",<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >count:"aggregate",create:"createOne",createMany:"createMany",createManyAndReturn:"createManyAndReturn",update:"updateOne",updateMany:"updateMany",updateManyAndReturn:"updateManyAndReturn",u</span></span>psert:<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >"upsertOne",delete:"deleteOne",deleteMany:"deleteMany",executeRaw:"executeRaw",queryRaw:"queryRaw",a</span></span>ggregate:"aggregate",groupBy:"groupBy",runCommandRaw:"runCommandRaw",findRaw:"findRaw",<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >aggregateRaw:"aggregateRaw"},Ca="explicitly `undefined` values are not allowed";function Mn({modelName:e</span></span>,action:r,args:t,<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >runtimeDataModel:n,extensions:i=_r.empty(),callsite:o,clientMethod:s,errorFormat:a,clientVersion:l,previewFeatures:u,globalOmit:c}){let p</span></span>=new Xi({runtimeDataModel:n,modelName:<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >e,action:r,rootArgs:t,callsite:o,extensions:i,selectionPath:[],argumentPath:[],originalMethod:s</span></span>,errorFormat:a,clientVersion:l,<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >previewFeatures:u,globalOmit:c});return{modelName:e,action:rm[r],query:bt(t,p)}}function bt({select:e</span></span>,include:r,...t}={},n){let i=t.omit;return delete t.omit,{<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >arguments:Da(t,n),selection:tm(e,r,i,n)}}function tm(e,r,t,n){</span></span>return e?(r?n.throwValidationError({kind:"MutuallyExclusiveFields",<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >firstField:"include",secondField:"select",selectionPath:n.getSelectionPath()}):t&amp;&amp;n.t</span></span>hrowValidationError({kind:"MutuallyExclusiveFields",firstField:"omit",secondField:<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >"select",selectionPath:n.getSelectionPath()}),sm(e,n)):nm(n,r,t)}function n</span></span>m(e,r,t){let n={};return e.modelOrType&amp;&amp;!e.isRawAction()&amp;&amp;(n.<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >$composites=!0,n.$scalars=!0),r&amp;&amp;im(n,r,e),om(n,t,e),n}</span></span>function im(e,r,t){for(let[n,i]of Object.entries(r)){<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >if(Se(i))continue;let o=t.nestSelection(n);if(eo(i,o),i===!1||i===v</span></span>oid 0){e[n]=!1;continue}let s=t.findField(n);<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >if(s&amp;&amp;s.kind!=="object"&amp;&amp;t.throwValidationError({kind:"IncludeOnScalar",s</span></span>electionPath:t.getSelectionPath().concat(n),outputType:t.<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >getOutputTypeDescription()}),s){e[n]=bt(i===!0?{}:i,o);continue}</span></span>if(i===!0){<span class="fstat-no" title="function not covered" >e[n]=!0;continue}e[n]=bt(i,o)}}function om(e,r,t){let n=t.getComputedFields(),i={...t.getGlobalOmit(),...r},o=Ta(i,n);for(let[s,a]of Object.entries(o)){if(Se(a))continue;eo(a,t.nestSelection(s));let l=t.findField(s);n?.[s]&amp;&amp;!l||(e[s]=!a)}}function sm(e,r){let t={},n=r.getComputedFields(),i=Pa(e,n);for(let[o,s]of Object.entries(i)){if(Se(s))continue;let a=r.nestSelection(o);eo(s,a);let l=r.findField(o);if(!(n?.[o]&amp;&amp;!l)){if(s===!1||s===void 0||Se(s)){t[o]=!1;continue}if(s===!0){l?.kind==="object"?t[o]=bt({},a<span class="fstat-no" title="function not covered" >):t</span>[o]=!0;continue}t[o]=bt(s,a)}}return t}function Ia(e,r){if(e===null)return null;if(typeof e=="string"||typeof e=="number"||typeof e=="boolean")return e;if(typeof e=="bigint")return{$type:"BigInt",value:String(e)};if(xr(e)){if(dn(e))return{$type:"DateTime",value:e.toISOString()};r.throwValidationError({kind:"InvalidArgumentValue",selectionPath:r.getSelectionPath(),argumentPath:r.getArgumentPath(),argument:{name:r.getArgumentName(),typeNames:["Date"]},underlyingError:"Provided Date object is invalid"})}if(Sa(e))return{$type:"Param",value:e.name};if(Or(e))return{$type:"FieldRef",value:{_ref:e.name,_container:e.modelName}};if(Array.isArray(e))return am(e,r);if(ArrayBuffer.isView(e)){let{buffer:t,byteOffset:n,byteLength:i}=e;return{$type:"Bytes",value:Buffer.from(t,n,i).toString("base64")}}if(lm(e))return e.values;if(Tr(e))return{$type:"Decimal",value:e.toFixed()};if(e instanceof Me){if(e!==Dn.instances[e._getName()])throw new Error("Invalid ObjectEnumValue");return{$type:"Enum",value:e._getName()}}if(um(e))return e.toJSON();if(typeof e=="object")return Da(e,r);r.throwValidationError({kind:"InvalidArgumentValue",selectionPath:r.getSelectionPath(),argumentPath:r.getArgumentPath(),argument:{name:r.getArgumentName(),typeNames:[]},underlyingError:<span class="fstat-no" title="function not covered" >`We could not serialize ${O</span>bject.prototype.toString.call(e)<span class="fstat-no" title="function not covered" >} value. Serialize the object to JSON or implement a ".toJSON()" method on it`}</span>)}function Da(e,r){if(e.$type)return{$type:"Raw",value:e};let t</span>={};for(let n in e){let i=e[n],o=r.nestArgument(n);<span class="fstat-no" title="function not covered" >Se(i)||(i!==void 0?t[n]=Ia(i,o):r.isPreviewFeatureOn("strictUndefinedChecks")&amp;&amp;r.throwValidationError({kind:"InvalidArgumentValue",argumentPath:o.getArgumentPath(),selectionPath:r.getSelectionPath(),argument:{name:r.getArgumentName(),typeNames:[]},underlyingError:Ca}))}return t}function am(e,r){let t=[];for(let n=0;n&lt;<span class="fstat-no" title="function not covered" >e.l</span>ength;n++){let i=r.nestArgument(String(n)),o=e[n];if(o===void 0||Se(o)){let s=o===void 0?"undefined":"Prisma.skip";r.throwValidationError({kind:"InvalidArgumentValue",selectionPath:i.getSelectionPath(),argumentPath:i.getArgumentPath(),argument:{name:`${r.getArgumentName()</span>}[${n}]`,typeNames:[]},underlyingError:`Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values`})}t.push(Ia(o,i))}return t}function lm(e){return <span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >typeof e=="object"&amp;&amp;e!==null&amp;&amp;e.__prismaRawParameters__===!0}function um(e){return t</span></span>ypeof e==<span class="fstat-no" title="function not covered" >"object"&amp;&amp;e!==null&amp;&amp;typeof e.toJSON=="function"}function eo(e,r){e===void 0&amp;&amp;r.isPreviewFeatureOn("strictUndefinedChecks")&amp;&amp;r.throwValidationError({kind:"</span>InvalidSelectionValue",selectionPath:r.getSelectionPath(),<span class="fstat-no" title="function not covered" >underlyingError:Ca})}var Xi=class e{constructor(r){this.params=r;this.params.modelName&amp;&amp;(this.modelOrType=this.params.runtimeDataModel.models[this.params.modelName]??this.params.runtimeDataModel.types[this.params.modelName])}modelOrType;throwValidationError(r){_n({errors:[r],originalMethod:this.params.originalMethod,args:this.params.rootArgs??{},callsite:this.params.callsite,errorFormat:this.params.errorFormat,clientVersion:this.params.clientVersion,globalOmit:this.params.globalOmit})}getSelectionPath(){return this.params.selectionPath}getArgumentPath(){return this.params.argumentPath}getArgumentName(){return this.params.argumentPath[this.params.argumentPath.length-1]}getOutputTypeDescription(){if(!(!this.params.modelName||!this.modelOrType))return{name:this.params.modelName,fields:this.modelOrType.fields.map(r=&gt;({name:r.name,typeName:"boolean",isRelation:r.kind==="object"}))}}isRawAction(){<span class="fstat-no" title="function not covered" >return[</span>"executeRaw","queryRaw","runCommandRaw","findRaw",<span class="fstat-no" title="function not covered" >"aggregateRaw"]</span>.includes(this.params.action)}isPreviewFeatureOn(r){return t</span>his.params.previewFeatures.includes(r)}<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >getComputedFields(){if(this.params.modelName)return this.params.extensions.getAllComputedFields(this.params.modelName)}findField(r){return this.modelOrType?.fields.find(t=&gt;t.name===r)}nestSelection(r){let t=this.findField(r),n=t?.kind==="object"?t.type:void 0;return new e({...this.params,modelName:n,selectionPath:this.params.selectionPath.concat(r)})}getGlobalOmit(){return this.params.modelName&amp;&amp;this.shouldApplyGlobalOmit()?this.params.globalOmit?.[We(this.params.modelName)]??{}:{}}shouldApplyGlobalOmit(){switch(this.params.action){case"findFirst":case"findFirstOrThrow":case"findUniqueOrThrow":case"findMany":case"upsert":case"findUnique":case"createManyAndReturn":case"create":case"update":case"updateManyAndReturn":case"delete":return!0;case"executeRaw":case"aggregateRaw":case"runCommandRaw":case"findRaw":case"createMany":case"deleteMany":case"groupBy":case"updateMany":case"count":case"aggregate":case"queryRaw":return!1;default:ar(this.params.action,"Unknown action")}}nestArgument(r){return new e({...this.params,argumentPath:this.params.argumentPath.concat(r)})}};function Oa(e){if(!e._hasPreviewFlag("metrics"))throw new Z("`metrics` preview feature must be enabled in order to access metrics API",{clientVersion:e._clientVersion})}var Nr=class{_client;constructor(r){this._client=r}prometheus(r){return Oa(this._client),this._client._engine.metrics({format:"prometheus",...r})}json(r){return Oa(this._client),this._client._engine.metrics({format:"json",...r})}};function ka(e,r){let t=at(()=&gt;cm(r));Object.defineProperty(e,"dmmf",{get:()=&gt;t.get()})}function cm(e){return{datamodel:{models:ro(e.models),enums:ro(e.enums),types:ro(e.types)}}}function ro(e){return Object.entries(e).map(([r,t])=&gt;({name:r,...t}))}var to=new WeakMap,$n="$$PrismaTypedSql",Et=class{constructor(r,t){to.set(this,{sql:r,values:t}),Object.defineProperty(this,$n,{value:$n})}get sql(){return to.get(this).sql}get values(){return to.get(this).values}};function _a(e){return(...r)=&gt;new Et(e,r)}function qn(e){return e!=null&amp;&amp;e[$n]===$n}var fu=A(Ti());var gu=require("node:async_hooks"),hu=require("node:events"),yu=A(require("node:fs")),ri=A(require("node:path"));var oe=class e{constructor(r,t){if(r.length-1!==t.length)throw r.length===0?new TypeError("Expected at least 1 string"):new TypeError(`Expected ${r.length} strings to have ${r.length-1} values`);let n=t.reduce((s,a)=&gt;s+(a instanceof e?a.values.length:1),0);this.values=new Array(n),this.strings=new Array(n+1),this.strings[0]=r[0];let i=0,o=0;for(;i&lt;t.length;){let s=t[i++],a=r[i];if(s instanceof e){this.strings[o]+=s.strings[0];let l=0;for(;l&lt;s.values.length;)this.values[o++]=s.values[l++],this.strings[o]=s.strings[l];this.strings[o]+=a}else this.values[o++]=s,this.strings[o]=a}}get sql(){let r=this.strings.length,t=1,n=this.strings[0];for(;t&lt;r;)n+=`?${this.strings[t++]}`;return n}get statement(){let r=this.strings.length,t=1,n=this.strings[0];for(;t&lt;r;)n+=`:${t}${this.strings[t++]}`;return n}get text(){let r=this.strings.length,t=1,n=this.strings[0];for(;t&lt;r;)n+=`$${t}${this.strings[t++]}`;return n}inspect(){return{sql:this.sql,statement:this.statement,text:this.text,values:this.values}}};function Na(e,r=",",t="",n=""){if(e.length===0)throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");return new oe([t,...Array(e.length-1).fill(r),n],e)}function no(e){return new oe([e],[])}var La=no("");function io(e,...r){return new oe(e,r)}function wt(e){return{getKeys(){return Object.keys(e)},getPropertyValue(r){return e[r]}}}function re(e,r){return{getKeys(){return[e]},getPropertyValue(){return r()}}}function lr(e){let r=new we;return{getKeys(){return e.getKeys()},getPropertyValue(t){return r.getOrCreate(t,()=&gt;e.getPropertyValue(t))},getPropertyDescriptor(t){return e.getPropertyDescriptor?.(t)}}}var Vn={enumerable:!0,configurable:!0,writable:!0};function jn(e){let r=new Set(e);return{getPrototypeOf:()=&gt;Object.prototype,getOwnPropertyDescriptor:()=&gt;Vn,has:(t,n)=&gt;r.has(n),set:(t,n,i)=&gt;r.add(n)&amp;&amp;Reflect.set(t,n,i),ownKeys:()=&gt;[...r]}}var Fa=Symbol.for("nodejs.util.inspect.custom");function he(e,r){let t=pm(r),n=new Set,i=new Proxy(e,{get(o,s){if(n.has(s))return o[s];let a=t.get(s);return a?a.getPropertyValue(s):o[s]},has(o,s){if(n.has(s))return!0;let a=t.get(s);return a?a.has?.(s)??!0:Reflect.has(o,s)},ownKeys(o){let s=Ma(Reflect.ownKeys(o),t),a=Ma(Array.from(t.keys()),t);return[...new Set([...s,...a,...n])]},set(o,s,a){return t.get(s)?.getPropertyDescriptor?.(s)?.writable===<span class="fstat-no" title="function not covered" >!1?!</span></span>1:(n.add(s),Reflect.set(o,s,a))},getOwnPropertyDescriptor(o</span>,s){let a=Reflect.getOwnPropertyDescriptor(o,s);if(a&amp;&amp;!a.configurable)return a;let l=t.get(s);return l?l.getPropertyDescriptor?{...Vn,...l?.<span class="branch-0 cbranch-no" title="branch not covered" >getPropertyDescriptor(s)</span>}:Vn:a},defineProperty(o,s,a){return n.add(s),Reflect.defineProperty(o,s,a)},getPrototypeOf:()=&gt;Object.prototype});return i[Fa]=function(){let o={...this};return delete o[Fa],o},i}function pm(e){let r=new Map;for(let t of e){let n=t.getKeys();for(let i of n)r.set(i,t<span class="branch-0 cbranch-no" title="branch not covered" >)}return r}function Ma(e,r){return e.filter(t=&gt;r.get(t)?.h</span>as?.(t)??<span class="fstat-no" title="function not covered" >!0)}function Lr(e){return{getKeys(){return e},has(){return!1},getPropertyValue(){}}}function Fr(e,r){return{batch:e,transaction:r?.kind==="batch"?{isolationLevel:r.options.isolationLevel}:void 0}}function $a(e){if(e===void 0)return"";let r=kr(e);return new Rr(0,{colors:An}).write(r).toString()}var dm="P2037";function Mr({error:e,user_facing_error:r},t,n){return r.error_code?new z(mm(r,n),{code:r.error_code,clientVersion:t,meta:r.meta,batchRequestIdx:r.batch_request_idx}):new V(e,{clientVersion:t,batchRequestIdx:r.batch_request_idx})}function mm(e,r){let t=e.message;return(r==="postgresql"||r==="postgres"||r</span>==="mysql")&amp;&amp;e.error_code===dm&amp;&amp;(<span class="fstat-no" title="function not covered" >t+=<span class="fstat-no" title="function not covered" >`</span></span>
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`),t}var xt="&lt;unknown&gt;";function qa(e){var r=e.split(`
`);return r.reduce(function(t,<span class="branch-0 cbranch-no" title="branch not covered" >n){var i</span>=hm(n)||bm(n)||xm(n)||Sm(n)||Pm(n);return i&amp;&amp;t.push(i),t},[])}var fm=/^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|&lt;anonymous&gt;|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,gm=/\((\S*)(?::(\d+))(?::(\d+))\)/;function hm(e){var r=fm.exec(e);if(!r)return null;var t=r[2]&amp;&amp;r[2].indexOf("native")===0,n=r[2]&amp;&amp;r[2].indexOf("eval"<span class="branch-0 cbranch-no" title="branch not covered" >)===0,i=gm.exec(r[2]);return n</span>&amp;&amp;i!=null&amp;&amp;(r[2]=i[1],r[3]=i[2],r[4]=i[3]),{file:t?null:r[2],methodName:r[1]||xt,arguments:t?[r[2]]:[],lineNumber:r[3]?+r[3]:null,column:r[4]?+r[4]:null}}var <span class="branch-0 cbranch-no" title="branch not covered" >ym=<span class="branch-0 cbranch-no" title="branch not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >/^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;f</span></span>unction bm(e){var r=ym.exec(e)</span>;return r?{file:r[2],methodName:r[1]||xt,arguments:[],lineNumber:+r[3],column:r[4]?+r[4]:null}:null<span class="branch-0 cbranch-no" title="branch not covered" >}var Em=/</span>^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i,wm=/(\S+) line (\d+)(?: &gt; eval line \d+)* &gt; eval/i;function xm(e){var r=Em.exec(e);if(!r)return null;var t=r[3]&amp;&amp;r[3].indexOf(" &gt; eval")&gt;-1,n=wm.exec(r[3]);return t&amp;&amp;n!=null&amp;&amp;(r[3]=n[1],r[4]=n[2],r[5]=null),{file:r[3],methodName:r[1]||xt,<span class="branch-0 cbranch-no" title="branch not covered" >arguments:r</span>[2]?r[2].split(","):[],lineNumber:r[4]?+r[4]:null,column:r[5]?+r[5]:null}}var vm=<span class="branch-0 cbranch-no" title="branch not covered" >/^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;function Pm(e){var r=vm.exec(e);return r?{file:r[3],<span class="fstat-no" title="function not covered" >methodName:r</span>[1]||xt,arguments:[],lineNumber:+r[4],column:r[5]?+r[5]:null}:null}var Tm=/^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;f</span>unction Sm(e){var r=Tm.exec(e);return r?{file:r[2],methodName:r[1]||xt,arguments:[],lineNumber:+r[3],column:r[4]?+r[4]:null}:null}var oo=class{getLocation(){return null}<span class="branch-0 cbranch-no" title="branch not covered" >},so=class{_error;constructor(){this._error=new Error}</span>getLocation(){let r=<span class="branch-0 cbranch-no" title="branch not covered" >this._error.stack;if(!r)return null;let n=qa(r).find(i=&gt;{if(!i.file)return!1;let o=Li(i.file);return o!=="&lt;anonymous&gt;"&amp;&amp;!</span>o.includes("@prisma")&amp;&amp;!o.<span class="branch-0 cbranch-no" title="branch not covered" >includes("/packages/client/src/runtime/")&amp;&amp;!o.endsWith("/runtime/binary.js")</span>&amp;&amp;!o.endsWith("/runtime/library.js")&amp;&amp;!o.endsWith("/runtime/edge.js")&amp;&amp;!<span class="branch-0 cbranch-no" title="branch not covered" >o.endsWith("/runtime/edge-esm.js")&amp;&amp;!o.s</span>tartsWith("internal/")&amp;&amp;!i.methodName.includes("new ")&amp;&amp;!i.methodName.includes("getCallSite")&amp;&amp;!i.methodName.includes("Proxy.")&amp;&amp;i.methodName.split(".").length&lt;4});return!n||!n.<span class="branch-0 cbranch-no" title="branch not covered" >file?null:{fileName:n.f</span>ile,lineNumber:n.lineNumber,columnNumber:n.column}}};function Ze(e){<span class="branch-0 cbranch-no" title="branch not covered" >return e==="minimal"?typeof $EnabledCallSite=="function"&amp;&amp;e!=="minimal"?new $EnabledCallSite:new oo:new so}var Va={_avg:!0,_count:!0,_sum:!0,_min:!0,_max:!0};function $r(e={}){let r=Am(e);return Object.e</span>ntries(r).reduce((n,[i,o])=&gt;(<span class="branch-0 cbranch-no" title="branch not covered" >Va[i]!==void 0?n.select[i]={select:o}:n[i]=o,n),{select:{}})}function Am(e</span>={}){return <span class="branch-0 cbranch-no" title="branch not covered" >typeof e._count=="boolean"?{...e,_count:{_all:e._count}}:e}function Bn(e={}){return r</span>=&gt;(typeof e._count=="boolean"&amp;&amp;(r._count=r._count._all),r)}function ja(e,r){let t=Bn(e);return r({action:"aggregate",unpacker:t,argsMapper:$r})(e)}function Cm(e={}){let{select:r,...t}=e;return typeof <span class="branch-0 cbranch-no" title="branch not covered" >r==<span class="branch-0 cbranch-no" title="branch not covered" >"object"?$</span>r({.</span>..t,_count:r}):$r({...t,<span class="branch-0 cbranch-no" title="branch not covered" >_count:{_all:!0}})}function Im(e</span>={}){return typeof e.select=="object"?r=&gt;Bn(e)(r)._count:r=&gt;Bn(e)(r)._count._all}function Ba(e,r){return r({action:"count",unpacker:Im(e),argsMapper:Cm})(e)}function Dm(e={}){let r=$r(e);if(Array.isArray(r.by))for(let t of r.by)typeof t=="string"&amp;&amp;(r.select[t]=!0);else <span class="branch-0 cbranch-no" title="branch not covered" >typeof r.by=="string"&amp;&amp;(r.select[r.by]=!0);return r}function Om(e={}){return r=&gt;(typeof e?._count==<span class="fstat-no" title="function not covered" >"boolean"&amp;&amp;r</span>.forEach(t=&gt;{t._count=t._count._all}),r)}function Ua(e,r){return r({action:"groupBy",unpacker:Om(e),argsMapper:Dm})(e)}function Ga(e,r,t){if(r==="aggregate")return n=&gt;ja(n,t);if(r==="count")return n=&gt;Ba(n,t);if(r==="groupBy")return n=&gt;Ua(n,t)}function Qa(e,r){let t=r.fields.filter(i=&gt;!i.relationName),n=Ms(t,"name");return new Proxy({},{get(<span class="fstat-no" title="function not covered" >i,o</span>){if(o in i||typeof o=="symbol")return i[o];<span class="fstat-no" title="function not covered" >let s</span>=n[o];if(s)return new dt(e,o,s.type,s.<span class="fstat-no" title="function not covered" >isList,s</span>.kind==="enum")},...jn(Object.keys(n))})}var Wa=e=&gt;Array.isArray(e)?e:e.split("."),ao=(e,r)=&gt;Wa(r).reduce((t,n)=&gt;t&amp;&amp;t[n],e),Ja=(e,r,t)=&gt;Wa(r).reduceRight((n,i,o,s)=&gt;Object.assign({</span>},ao(e,s.slice(0,o)),{[i]:n}),t);<span class="branch-0 cbranch-no" title="branch not covered" >function km(e,r){return e===void 0||r===void 0?[</span>]:[...r,"select",e]}function _m(e,r,t){return r===void 0?e??{}:Ja(r,t,<span class="branch-0 cbranch-no" title="branch not covered" >e||!0)}function lo(e,r,t,n,i,o){let a=e._runtimeDataModel.models[r].fields.reduce((l,u)=&gt;({</span>...l,[u.name]:u}),{});return l=&gt;{let u=Ze(e._errorFormat),c=km(n,i),p=_m(l,o,c),d=t({dataPath:c,callsite:u})(p),f=Nm(e,r);return new Proxy(d,{get(h,g){if(!f.includes(g))return h[g];let <span class="branch-0 cbranch-no" title="branch not covered" >T=[a[g].<span class="branch-0 cbranch-no" title="branch not covered" >t</span>ype,t,g</span>],S=[c,p];return lo(e,...T,...S<span class="branch-0 cbranch-no" title="branch not covered" >)},...jn([...f,...Object.getOwnPropertyNames(d)])})}}function Nm(e,r){return e._runtimeDataModel.models[r].fields.f</span>ilter(t=&gt;t.kind==="object").map(t=&gt;t.name)}var Lm=["findUnique","findUniqueOrThrow","findFirst","findFirstOrThrow","create",<span class="fstat-no" title="function not covered" >"update","upsert","delete"],Fm=["aggregate","count","groupBy"];function uo(e,r){let t=e._extensions.getAllModelExtensions(r)??{},n=[Mm(e,r),qm(e,r),wt(t),re("name",()=&gt;r),re("$name",()=&gt;r),re("$parent",()=&gt;e._appliedParent)];return he({},n)}function Mm(e,r){let t=Te(r),n=Object.keys(Sr).concat("count");return{getKeys(){return n},getPropertyValue(i){let o=i,s=a=&gt;l=&gt;{let u=Ze(e._errorFormat);return e._createPrismaPromise(c=&gt;{let p={args:l,dataPath:[],action:o,model:r,clientMethod:`${t}.${i}`,jsModelName:t,transaction:c,callsite:u};return e._request({...p,...a})},{action:o,args:l,model:r})};return Lm.includes(o)?lo(e,r,s):$m(i)?Ga(e,i,s):s({})}}}function $</span>m(e){return Fm.includes(e)}function qm(e,r){return lr(re(<span class="branch-0 cbranch-no" title="branch not covered" >"fields",<span class="fstat-no" title="function not covered" >()=&gt;{</span>let t=e._runtimeDataModel.models[r];r</span>eturn Qa(r,t)}))}function Ka(e){return e.replace(/^./,r=&gt;r.toUpperCase())}var co=Symbol();function vt(e){let r=[Vm(e),jm(e),re(co,()=&gt;e),re("$parent",()=&gt;e._appliedParent)],t=e._extensions.getAllClientExtensions();return t&amp;&amp;r.push(wt(t)),he(e,r)}function Vm(e){let r=Object.getPrototypeOf(e.<span class="branch-0 cbranch-no" title="branch not covered" >_originalClient),t=[...new Set(Object.getOwnPropertyNames(r))];return{getKeys(){return t},getPropertyValue(n){return e[n]}}}function j</span>m(e){let r=<span class="branch-0 cbranch-no" title="branch not covered" >Object.keys(e._runtimeDataModel.m</span>odels<span class="branch-0 cbranch-no" title="branch not covered" >),t=r.map(Te),n=[...new Set(r.concat(t))];return lr({getKeys(){return n},getPropertyValue(i){let o=Ka(i);if(e._runtimeDataModel.models[o]!==void 0)return uo(e,o);if(e._runtimeDataModel.models[i]!==void 0)return uo(e,i)},getPropertyDescriptor(<span class="fstat-no" title="function not covered" >i</span>){if(!t.includes(i))return{enumerable:!1}}})}function Ha(e){return e[co]?e[co]:e}function Ya(e){if(typeof e=="function")return e(this);if(e.client?.__AccelerateEngine){let t=e.client.__AccelerateEngine;this._originalClient._engine=new t(this._originalClient._accelerateEngineConfig)}let r=Object.create(this._originalClient,{_extensions:{value:this._extensions.append(e)},_appliedParent:{value:this,configurable:!0},$on:{value:void 0}});return vt(r)}function za({result:e,modelName:r,select:t,omit:n,extensions:i}){let o=i.getAllComputedFields(r);if(!o)return e;let s=[],a=[];for(let l of <span class="fstat-no" title="function not covered" >Object.v</span>alues(o)){if(n){if(n[l.name])continue;let u=l.needs.filter(c=&gt;n[c]);u.length&gt;0&amp;&amp;a.push(Lr(u))}else if(t){if(!t[l.name])continue;let u=l.needs.filter(c=&gt;!t[c]);u.length&gt;0&amp;&amp;a.push(<span class="fstat-no" title="function not covered" >Lr(u</span>))}Bm(e,l.needs)&amp;&amp;s.push(Um(l,he(e,s)))}return s.length&gt;0||a.length&gt;0?he(e,[...s,...a]):e}function Bm(e,r){return r.every(t=&gt;Vi(e,t))}function Um(e,r){return lr(re(e.<span class="fstat-no" title="function not covered" >n</span>ame,()=&gt;e.compute(r)))}function Un({visitor:e,result:r,args:t,runtimeDataModel:n,modelName:i}){if(Array.isArray(r)){for(let s</span>=0;s&lt;r.length;s++)r[s]=Un({result:r[s],args:t,<span class="fstat-no" title="function not covered" >modelName:i,runtimeDataModel:n,visitor:e});return r}let o=e(r,i,t)??r;return t.include&amp;&amp;Za({includeOrSelect:t.include,result:o,parentModelName:i,runtimeDataModel:n</span>,visitor:e}),t.select&amp;&amp;Za({includeOrSelect:t.<span class="fstat-no" title="function not covered" >select,result:o,parentModelName:i,<span class="fstat-no" title="function not covered" >runtimeDataModel:n</span>,visitor:e}),o}function Za({includeOrSelect:e</span>,result:r,parentModelName:t,<span class="branch-0 cbranch-no" title="branch not covered" >runtimeDataModel:n,visitor:i}){for(let[o,s]of Object.entries(e)){if(!s||r[o]==null||Se(s))continue;let l=n</span>.models[t].<span class="branch-0 cbranch-no" title="branch not covered" >fields.find(c=&gt;c.name===o);if(!l||l.kind!=="object"||!l.relationName)continue;let u=typeof s=="object"?s:{};r[o]=Un({visitor:i,result:r[o],args:u,modelName:l.type,runtimeDataModel:n})}}function Xa({result:e,modelName:r,args:t,extensions:n,runtimeDataModel:i,globalOmit:o}){return n.isEmpty()||e==null||typeof e!="object"||!i.models[r]?e:Un({result:e,args:t??{},modelName:r,runtimeDataModel:i,visitor:(a,l,u)=&gt;{let c=Te(l);return za({result:a,modelName:c,select:u.select,omit:u.select?void 0:{...o?.[c],...u.omit},extensions:n}</span>)}})}var Gm=["$connect","$disconnect","$on","$transaction","$extends"],<span class="branch-0 cbranch-no" title="branch not covered" >el=Gm;function rl(e){if(e instanceof oe)r</span>eturn Qm(e);if(qn(e))return Wm(e);if(Array.isArray(e)){let t=[e[0]];for(let n=1;n&lt;e.length;n++)t[n]=Pt(e[n]);return t}let r={};for(let t in e)r[t]=Pt(e[t]);<span class="branch-0 cbranch-no" title="branch not covered" >return r}</span>function Qm(e){return new oe(e.strings,e.values)}function Wm(e){return new Et(e.sql,e.values)}<span class="branch-0 cbranch-no" title="branch not covered" >function Pt(e){<span class="branch-0 cbranch-no" title="branch not covered" ></span>if(typeof e!="object"||e==null||e instanceof Me||Or(e))r</span>eturn e;if(Tr(e))return new Fe(e.toFixed());if(xr(e))return <span class="branch-0 cbranch-no" title="branch not covered" >new Date(+e);i</span>f(ArrayBuffer.<span class="branch-0 cbranch-no" title="branch not covered" >isView(e)</span>)return e.slice(0);if(<span class="branch-0 cbranch-no" title="branch not covered" >Array.isArray(e)){let r</span>=e.length,t;for(t=Array(r);r--;)<span class="branch-0 cbranch-no" title="branch not covered" >t[r]=P</span>t(<span class="fstat-no" title="function not covered" >e[r]);return t<span class="fstat-no" title="function not covered" ></span>}if(typeof e=="object"){let r={<span class="fstat-no" title="function not covered" ></span>};for(let t in e)t==="__proto__"?Object.<span class="fstat-no" title="function not covered" >defineProperty(r</span>,t,{value:Pt(e[t]),configurable:!0,<span class="fstat-no" title="function not covered" >enumerable:!</span>0,writable:!0}):r[t]=Pt(e[t]);return r}ar(e,"Unknown value")}function nl(e,r,t,n=0){return e._createPrismaPromise(i=&gt;{let o=r.customDataProxyFetch;return"transaction"in r&amp;&amp;i!==void 0&amp;&amp;(r.transaction?.kind==="batch"&amp;&amp;r.transaction.lock.then(),r.transaction=i),n===t.length?e._executeRequest(r):t[n]({model:r.model,operation:r.model?r.action:r.clientMethod,args:rl(r.args??{}),__internalParams:r,query:(s,a=r)=&gt;{let l=a.customDataProxyFetch;return a.customDataProxyFetch=al(o,l),a.args=s,nl(e,a,t,n+1)<span class="fstat-no" title="function not covered" >}</span>})})}function il(e,r){let{jsModelName:t,action:n,clientMethod:i}=r,o=t?n:i;if(e._extensions.isEmpty())return e._executeRequest(r);let s=e.<span class="fstat-no" title="function not covered" >_extensions.g</span>etAllQueryCallbacks(t??"$none",o);return nl(e,r,s)}function ol(e){return r=&gt;{let t={requests:r},n=r[0].extensions.getAllBatchQueryCallbacks();return n.<span class="fstat-no" title="function not covered" >length?s</span>l(t,n,0,e):e(t)}}function sl(e,r,t,n){</span>if(t===r.length)return n(e);<span class="fstat-no" title="function not covered" >let i=e.customDataProxyFetch,o=e.requests[0].transaction;return r[t]({args:{queries:e.requests.map(s=&gt;({model:s.modelName,operation:s.action,args:s.args})),transaction:o?{isolationLevel:o.kind==="batch"?o.isolationLevel:void 0}:void 0},__internalParams:e,query(s,a=e){let l=a.customDataProxyFetch;return a.customDataProxyFetch=al(i,l),sl(a,r,t+1,n)}})}var tl=e=&gt;e;function al(e=tl,r</span>=<span class="fstat-no" title="function not covered" >tl){return t=&gt;e(r(t))}var ll=N("prisma:client"),ul={Vercel:"vercel","Netlify CI":"netlify"};function cl({postinstall:e,ciName:r,clientVersion:t}){if(ll("checkPlatformCaching:postinstall",e),ll("checkPlatformCaching:ciName",r),e===!0&amp;&amp;r&amp;&amp;r in ul){let n=`Prisma has detected that this project was built on ${r}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.</span>
&nbsp;
Learn how: https://pris.ly/d/${ul[r]}-build`;throw console.error(n),new P(n,t)}}function pl(e,r){<span class="fstat-no" title="function not covered" >return e?e.datasources?e.datasources:e.<span class="fstat-no" title="function not covered" >datasourceUrl?{</span>[r[0]]:{url:e.datasourceUrl}}:{}:{}}var J</span>m=<span class="fstat-no" title="function not covered" >()=&gt;globalThis.process?.release?.<span class="fstat-no" title="function not covered" >name==="</span>node",Km=()=&gt;!!globalThis.Bun||!!g</span>lobalThis.process?.versions?.bun,Hm=()=&gt;!!globalThis.Deno,Ym=()=&gt;typeof globalThis.Netlify==<span class="branch-0 cbranch-no" title="branch not covered" >"object",<span class="branch-0 cbranch-no" title="branch not covered" >z</span>m=()=&gt;typeof globalThis.<span class="fstat-no" title="function not covered" >EdgeRuntime=="</span>object",Zm=()=&gt;g</span>lobalThis.navigator?.<span class="fstat-no" title="function not covered" >userAgent==="Cloudflare-Workers";<span class="fstat-no" title="function not covered" >function X</span>m(){return[[Ym,<span class="fstat-no" title="function not covered" >"netlify"]</span>,[zm,"edge-light"],[Zm,"workerd"],[Hm,"deno"],[Km,"bun"],[Jm,"node"]].flatMap(t</span>=&gt;t[0]()?[t[1]]:[]).at(0)??""}var ef={node:"Node.js",workerd:<span class="branch-0 cbranch-no" title="branch not covered" >"Cloudflare Workers",d</span>eno:"Deno and Deno Deploy",netlify:"Netlify Edge Functions","edge-light":<span class="fstat-no" title="function not covered" >"Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)"}</span>;function Gn(){let e=Xm();return{id:e,<span class="fstat-no" title="function not covered" >prettyName:ef[e]||e,isEdge:["workerd","deno","netlify","edge-light"].includes(e</span>)}}var hl=A(require("node:fs")),Tt=A(require("node:path"));function Qn(e){let{runtimeBinaryTarget:r}=e;return`Add "${r}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:
&nbsp;
${rf(e)}`}function <span class="branch-0 cbranch-no" title="branch not covered" >rf(e){<span class="branch-0 cbranch-no" title="branch not covered" ></span>let{generator:r</span>,<span class="fstat-no" title="function not covered" >generatorBinaryTargets:t,runtimeBinaryTarget:n}=e,i={fromEnvVar:null,value:n},o=[...t,i];return <span class="fstat-no" title="function not covered" >ki({</span>...r,binaryTargets:o})}function Xe(e){let{runtimeBinaryTarget:r}=e;return`Prisma Client could not locate the Query Engine for runtime "${r</span>}".`}<span class="fstat-no" title="function not covered" >function er(e){let{searchedLocations:r}=e;return`</span>The following locations have been searched:
${[...new Set(r)].map(i=&gt;`  ${i}`).join(`
`)}`}function dl(e){let{runtimeBinaryTarget:r}=e;return`${Xe(e)}
&nbsp;
This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${r}".
${Qn(e)}
&nbsp;
${er(e)}`}function Wn(e){return`We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${e}`}function Jn(e){let{errorStack:r}=e;return r?.match(/\/\.next|\/next@|\/next\//)?`
&nbsp;
We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.`:""}function ml(e){let{queryEngineName:r}=e;return`${Xe(e)}${Jn(e)}
&nbsp;
This is likely caused by a bundler that has not copied "${r}" next to the resulting bundle.
Ensure that "${r}" has been copied next to the bundle or in "${e.expectedLocation}".
&nbsp;
${Wn("engine-not-found-bundler-investigation")}
&nbsp;
${er(e)}`}function fl(e){let{runtimeBinaryTarget:r,generatorBinaryTargets:t}=e,n=t.find(i=&gt;i.native);return`${Xe(e)}
&nbsp;
This happened because Prisma Client was generated for "${n?.value??<span class="branch-0 cbranch-no" title="branch not covered" >"unknown"}", but the actual deployment required "${r</span>}".
${Qn(<span class="branch-0 cbranch-no" title="branch not covered" >e)}</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >${er(e)}`}function gl(e){let{queryEngineName:r}=e;return`${Xe(e)}${Jn(e)}</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >This is likely caused by tooling that has not copied "${r}" to the deployment folder.</span>
<span class="cstat-no" title="statement not covered" >Ensure that you ran \`prisma generate\` and that "${r}" has been copied to "${e.expectedLocation}".</span>
&nbsp;
${Wn(<span class="fstat-no" title="function not covered" >"engine-not-found-tooling-investigation")}</span>
&nbsp;
${er(e)}`}var tf=N(<span class="fstat-no" title="function not covered" >"prisma:client:engines:resolveEnginePath"),nf=()=&gt;new RegExp("runtime[\\\\/]library\\.m?js$");async function yl(e,r){let t={binary:process.env.PRISMA_QUERY_ENGINE_BINARY,library:process.env.PRISMA_QUERY_ENGINE_LIBRARY}[e]??r.prismaPath;if(t!==void 0)return t;let{enginePath:n,searchedLocations:i}=await of(e,r);if(tf("enginePath",n),n!==void 0&amp;&amp;e==="binary"&amp;&amp;Ri(n),n!==void 0)return r.prismaPath=n;let o=await ir(),s=r.generator?.binaryTargets??[],a=s.some(d=&gt;d.native),l=!s.some(d=&gt;d.value===o),u=__filename.match(nf())===null,c={<span class="fstat-no" title="function not covered" >searchedLocations:i</span>,generatorBinaryTargets:s,generator:r.generator,runtimeBinaryTarget:o,queryEngineName:bl(e,o),expectedLocation:Tt.default.relative(process.<span class="fstat-no" title="function not covered" >cwd()</span>,r.dirname),errorStack:new Error().stack},p;throw a&amp;&amp;l?p=fl(c):l?p=d</span>l(c):u?p=ml(c):p=gl(c),new P(p,r.clientVersion)}async function of(e,r){let t=await ir(),n=[],i=[r.dirname,Tt.default.resolve(__dirname,".."),r.generator?.output?.value??__dirname,Tt.default.resolve(__dirname,"../../../.prisma/client"),"/tmp/prisma-engines",r.cwd];__filename.includes("resolveEnginePath")&amp;&amp;i.push(fs());for(let o of i){let s=bl(e,t),a=Tt.default.join(o,s);if(n.push(o),hl.default.existsSync(a))return{enginePath:a,searchedLocations:n}}return{enginePath:void 0,searchedLocations:n}}function bl(e,r){return e==="library"?Ut(r,"fs"):`query-engine-${r}${r==="windows"?".exe":""}`}var po=A(Ni());function El(e){return e?e.replace(/".*"/g,'"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g,r=&gt;`${r[0]}5`):""}function wl(e){return e.split(`
`).map(r=&gt;r.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/,"").replace(<span class="fstat-no" title="function not covered" >/\+\d+\s*ms$/,"")).join(`</span>
`)}var xl=A(Ls());function vl({title:e,user:r="prisma",repo:t="prisma",template:n="bug_report.yml",body:i}){return(0,xl.default)({<span class="branch-0 cbranch-no" title="branch not covered" >user:r,repo:t,template:n,title:e,body:i})}function Pl({version:e,binaryTarget:r,title:t,description:n,engineVersion:i,database:o,query:s}){let a=Uo(6e3-(s?.length??0</span>)),l=wl((0,po.default)(a)),u=n?`# Description
\`\`\`
${n}
\`\`\``:"",c=(0,po.default)(<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >`Hi Prisma Team! My Prisma Client just crashed. This is the report:</span></span>
## Versions
&nbsp;
| Name            | Version            |
|-----------------|--------------------|
<span class="cstat-no" title="statement not covered" >| Node            | ${process.version?.padEnd(19)<span class="fstat-no" title="function not covered" >}| </span></span>
<span class="cstat-no" title="statement not covered" >| OS              | ${r?.padEnd(19)}|</span>
<span class="cstat-no" title="statement not covered" >| Prisma Client   | ${e?.padEnd(19)}|</span>
<span class="cstat-no" title="statement not covered" >| Query Engine    | ${i?.padEnd(19)}|</span>
<span class="cstat-no" title="statement not covered" >| Database        | ${o?.padEnd(19)}|</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >${u}</span>
&nbsp;
## Logs
\`\`\`
<span class="cstat-no" title="statement not covered" >${l}</span>
\`\`\`
&nbsp;
## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`
&nbsp;
## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`
&nbsp;
## Prisma Engine Query
\`\`\`
<span class="cstat-no" title="statement not covered" >${s?El(s):""}</span>
\`\`\`
<span class="cstat-no" title="statement not covered" >`),p=vl({title:t,body:c});return`${t}</span>
&nbsp;
This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.
&nbsp;
<span class="cstat-no" title="statement not covered" >${Y(p)}</span>
&nbsp;
If you want the Prisma team to look into it, please open the link above \u{1F64F}
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`}function Tl(e,r){throw new Error(r)}function sf(e){return e!==null&amp;&amp;typeof e=="object"&amp;&amp;typeof e.$type=="string"}function af(e,r){let t={};for(let n of Object.keys(e))t[n]=r(<span class="fstat-no" title="function not covered" >e[n],n);return t}function qr(e){return e===null?e:Array.isArray(e)?e.map(qr):t</span>ypeof e=="object"?sf(e)?lf(e<span class="branch-0 cbranch-no" title="branch not covered" >):e.constructor!==n</span>ull&amp;&amp;e.constructor.name!=="Object"?e:af(e,qr):e}function lf({$type:e,<span class="branch-0 cbranch-no" title="branch not covered" >value:r}){</span>switch(<span class="branch-0 cbranch-no" title="branch not covered" >e)<span class="fstat-no" title="function not covered" >{c</span>ase"BigInt":return BigInt(r);case<span class="fstat-no" title="function not covered" >"</span>Bytes":{let{buffer:t,byteOffset:n,byteLength:i}=Buffer.from(r,"base64");return new Uint8Array(t,n,i)}case"DateTime":return new Date(r);case"</span>Decimal":return new Le(r);case<span class="fstat-no" title="function not covered" >"Json":return JSON.parse(r);default:Tl(r,<span class="fstat-no" title="function not covered" >"Unknown tagged value")</span>}}var Sl="6.15.0";function Vr({<span class="fstat-no" title="function not covered" >inlineDatasources:e</span>,overrideDatasources:r,env:t,clientVersion:n}){let i,o=Object.keys(e)[0],s=e[o]?.url,a=r[o]?.url;if(o===void 0?i=void 0:a?i=a:s?.v</span>alue?i=s.value:s?.fromEnvVar&amp;&amp;(i=t[s.<span class="fstat-no" title="function not covered" >fromEnvVar]),s?.fromEnvVar!==void 0&amp;&amp;i===void 0)throw new P(`error: Environment variable not found: ${s.fromEnvVar}.`,n);<span class="fstat-no" title="function not covered" >if(i</span>===void 0)throw new P("error: Missing URL environment variable, value, or override.",n</span>);return i}var Kn=class extends Error{clientVersion;cause;constructor(r,t){super(r),this.clientVersion=t.clientVersion,this.cause=t.cause}get[Symbol.toStringTag](){return this.<span class="fstat-no" title="function not covered" >name}};var se=class extends Kn{isRetryable;constructor(r,t){super(r,t),this.isRetryable=t.isRetryable??!0}};function R(e,r){return{...e,isRetryable:r}}var ur=class extends se{name="InvalidDatasourceError";code="P6001";constructor(r,t){super(r,R(t,!1))}};x(ur,"InvalidDatasourceError");function Rl(e){let r={clientVersion:e.clientVersion},t=Object.keys(e.inlineDatasources)[0],n=Vr({inlineDatasources:e.inlineDatasources,overrideDatasources:e.overrideDatasources,clientVersion:e.clientVersion,env:{...e.env,...typeof process&lt;"u"?process.env:{}}}),i;try{i=new URL(n)}catch{throw new ur(`Error validating datasource \`${t}\`: the URL must start with the protocol \`prisma://\``,r)}let{protocol:o,searchParams:s}=i;if(o!=="prisma:"&amp;&amp;o!==on)throw new ur(`Error validating datasource \`${t<span class="fstat-no" title="function not covered" >}\`: the URL must start with the protocol \`prisma://\` or \`prisma+postgres://\``,r</span>);let a=s.get("api_key");if(a===null||a.length&lt;1)throw new ur(`Error validating datasource \`${t}\`: the URL must contain a valid API key`,r);let l=Ii(i)?"http:":"https:",u=new URL(i.href.replace(o,l));return{apiKey:a,url:u}}var Al=A(nn()),Hn=class{apiKey;tracingHelper;logLevel;logQueries;engineHash;constructor({apiKey:r,tracingHelper:t,logLevel:n,logQueries:i,engineHash:o}){this.apiKey=r,this.tracingHelper=t,this.logLevel=n,this.logQueries=i,this.engineHash=o}</span>build({<span class="fstat-no" title="function not covered" >traceparent:r,transactionId:t}={}){let n={Accept:"application/json",Authorization:`Bearer ${this.apiKey}`,"Content-Type":"application/json","Prisma-Engine-Hash":t</span>his.<span class="fstat-no" title="function not covered" >engineHash,"Prisma-Engine-Version":Al.enginesVersion};this.tracingHelper.isEnabled()&amp;&amp;(n.traceparent=r??this.tracingHelper.getTraceParent()),t&amp;&amp;(n["X-Transaction-Id"]=t);let i=this.#e();return i.length&gt;0&amp;&amp;(n["X-Capture-Telemetry"<span class="fstat-no" title="function not covered" >]</span>=i.join(", ")),n}#e(){let r=[];return this.tracingHelper.isEnabled()&amp;&amp;r.push("tracing"),this.logLevel&amp;&amp;r.push(this.logLevel),this.logQueries&amp;&amp;r.push("query"),r}};function cf(e){return e[0]*1e3+e[1]/1e6}function mo(e){return new Date(cf(e))}var jr=class extends se{name="ForcedRetryError";code="P5001";constructor(r){super("This request must be retried",R(r,!0))}};x(jr,"ForcedRetryError");var cr=class extends se{name="NotImplementedYetError";code="P5004";constructor(r,t){super(r,R(t,!1))}};x(cr,"NotImplementedYetError");var $=class extends s</span>e{<span class="fstat-no" title="function not covered" >response;constructor(r,t){super(r,t),this.response=t.response;let n=this.response.headers.get("prisma-request-id");if(n){let i=`(The request id was: ${n})`;this.message=this.message+" "+i}}};var pr=class extends ${name="SchemaMissingError";code="P5005";constructor(r){super(<span class="fstat-no" title="function not covered" >"Schema needs to be uploaded",R</span>(r,!0))}};x(pr,"SchemaMissingError");var fo="This request could not be understood by the server",St=class extends ${name="BadRequestError";code="P5000";constructor(r,t,n){super(t||fo,R(r,!1)),n&amp;&amp;(this.code=n)}};x(St,"BadRequestError");var Rt=class extends ${name="HealthcheckTimeoutError";code="P5013";logs;constructor(r,t){super("Engine not started: healthcheck timeout",R(r,!0)),this.logs=t}};x(Rt,"HealthcheckTimeoutError");var At=class extends ${name="EngineStartupError";code="P5014";l</span>ogs;<span class="fstat-no" title="function not covered" >constructor(r,t,n){super(t,R(r,!0)),this.logs=n}};x(At,"EngineStartupError");var Ct=class extends ${name="EngineVersionNotSupportedError";code="P5012";constructor(r){super("Engine version is not supported",R(r,!1))}};x(Ct,"EngineVersionNotSupportedError");var go="Request timed out",It=<span class="fstat-no" title="function not covered" >class extends $</span>{name="GatewayTimeoutError";code="P5009";constructor(r,t=go){super(t,R(r,!1))}};x(It,"GatewayTimeoutError");var pf="Interactive transaction error",Dt=class extends ${name="InteractiveTransactionError";code="P5015";constructor(r,t=pf){super(t,R(<span class="fstat-no" title="function not covered" >r</span>,!1))}};x(Dt,"InteractiveTransactionError");var df="Request parameters are invalid",Ot=<span class="fstat-no" title="function not covered" >class extends $</span>{name="InvalidRequestError";code="P5011";constructor(r,t=df){super(t,R(r,!1))}};x(Ot,"InvalidRequestError");var ho=<span class="fstat-no" title="function not covered" >"Requested resource does not exist",k</span>t=class extends ${name=<span class="fstat-no" title="function not covered" >"NotFoundError";c</span>ode="P5003";constructor(r,t=ho){super(t,R(r,!1)<span class="fstat-no" title="function not covered" >)</span>}};x(kt,"NotFoundError");var yo="Unknown server error",Br=class extends ${name="ServerError";code="P5006";logs;constructor(r,t,n){super(t||yo,R(r,!0)),this.logs=n}};x(Br,"ServerError");var bo="Unauthorized, check your connection string",_t=class extends ${name="UnauthorizedError";code="P5007";constructor(r,t=bo){super(t,R(r,!1))}};x(_t,"UnauthorizedError");var Eo="Usage exceeded, retry again later",Nt=class extends ${name="UsageExceededError";code="P5008";constructor(r,t=Eo){super(t,R(r,!0))}};x(Nt,"UsageExceededError");async function mf(e){let r;try{r=await e.text()}catch{return{type:"EmptyError"}}try{let t=JSON.parse(r);if(typeof <span class="fstat-no" title="function not covered" >t</span>=="string")switch(t){case"InternalDataProxyError":return{type:"DataProxyError",body:t};default:return{type:"UnknownTextError",body:t}}if(typeof t=="object"&amp;&amp;t!==null){if("is_panic"in t&amp;&amp;"message"in t&amp;&amp;"error_code"in t)return{type:"</span>QueryEngineError",body:t};if("EngineNotStarted"in t||"InteractiveTransactionMisrouted"in t||"InvalidRequestError"in t){let n=Object.values(t)[0].reason;return typeof <span class="fstat-no" title="function not covered" >n=="string"&amp;&amp;!["SchemaMissing","</span>EngineVersionNotSupported"].includes(n)?{type:"UnknownJsonError",body:t}:{type:"DataProxyError",body:t}}}return{type:"UnknownJsonError",body:t}}catch{return r===""?{type:"EmptyError"}:{type:"UnknownTextError",body:r}}}async function Lt(e,r){<span class="branch-0 cbranch-no" title="branch not covered" >if(e.ok)return;let t={<span class="branch-0 cbranch-no" title="branch not covered" >c</span>lientVersion:r,response:e</span>},n=await mf(e);if(n.type==="QueryEngineError")throw new z(n.body.message,{code:n.body.error_code,<span class="branch-0 cbranch-no" title="branch not covered" >clientVersion:r}</span>);if(n.type==="DataProxyError"){if(n.<span class="branch-0 cbranch-no" title="branch not covered" >body==="InternalDataProxyError")t</span>hrow new Br(t,"Internal Data Proxy error");if(<span class="branch-0 cbranch-no" title="branch not covered" >"EngineNotStarted"in n.body){if(n.body.EngineNotStarted.reason==="SchemaMissing")r</span>eturn new pr(t);if(n.body.EngineNotStarted.reason==="EngineVersionNotSupported")throw new <span class="branch-0 cbranch-no" title="branch not covered" >Ct(t);<span class="branch-0 cbranch-no" title="branch not covered" >if("</span>EngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,logs:o}=n.body.EngineNotStarted.reason.EngineStartupError;throw new At(t,i,o)}if("KnownEngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,error_code:o}=n.body.EngineNotStarted.reason.KnownEngineStartupError;throw new P(i,r,o)}if("HealthcheckTimeout"in n.body.EngineNotStarted.reason){let{logs:i}=n.body.EngineNotStarted.reason.HealthcheckTimeout;throw new Rt(t</span>,i)}}if(<span class="branch-0 cbranch-no" title="branch not covered" >"InteractiveTransactionMisrouted"in n</span>.body){let i={IDParseError:<span class="branch-0 cbranch-no" title="branch not covered" >"Could not parse interactive transaction ID",N</span>oQueryEngineFoundError:<span class="branch-0 cbranch-no" title="branch not covered" >"Could not find Query Engine for the specified host and transaction ID",T</span>ransactionStartError:"Could not start interactive transaction"};throw new Dt(<span class="branch-0 cbranch-no" title="branch not covered" >t,i[n.body.InteractiveTransactionMisrouted.r</span>eason])}if(<span class="branch-0 cbranch-no" title="branch not covered" >"InvalidRequestError"in n.body)t</span>hrow new Ot(t,<span class="branch-0 cbranch-no" title="branch not covered" >n.body.InvalidRequestError.reason)</span>}if(e.status===401||e.status===403)throw new _t(t,Ur(bo,n));if(e.status===404)return new kt(t,Ur(ho,n));if(e.status===429)throw new Nt(t,Ur(Eo,n));if(e.status===504)throw new It(t,Ur(go,n));if(e.status&gt;=500)throw new Br(t,Ur(yo,n));<span class="branch-0 cbranch-no" title="branch not covered" >if(e.status&gt;=4</span>00)throw <span class="branch-0 cbranch-no" title="branch not covered" >new St(t,Ur(fo,n))}function Ur(e,r){return r.type==="EmptyError"?e:`${e}: ${JSON.stringify(r</span>)}`}<span class="branch-0 cbranch-no" title="branch not covered" >function C</span>l(e){let r=Math.pow(2,e)*50,t=Math.ceil(Math.random()*r)-Math.ceil(r/2),n=r+t;return new Promise(i=&gt;setTimeout(()=&gt;i(n),n))}var $e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";function Il(e){let r=new TextEncoder().encode(e),t="",n=r.byteLength,i=n%3,o=n-i,s,a,l,u,c;for(let p=0;p&lt;o;p=p+3)c=r[p]&lt;&lt;16|<span class="branch-0 cbranch-no" title="branch not covered" >r[p+1]&lt;&lt;8</span>|r[p+2],s=(c&amp;<span class="branch-0 cbranch-no" title="branch not covered" >16515072)&gt;&gt;18,a</span>=(c&amp;258048)&gt;&gt;12,l=(c&amp;<span class="branch-0 cbranch-no" title="branch not covered" >4032)&gt;&gt;6,u=c&amp;63,t</span>+=$e[s]+$e[a]+$e[l]+$e[u];return i==1?(c=r[o],s=(c&amp;252)&gt;&gt;2,a=(c&amp;3)&lt;&lt;4,t+=$e[s]+$e[a]+"=="):i==2&amp;&amp;(c=r[o]&lt;&lt;8|r[o+1],s=(c&amp;64512)&gt;&gt;10,a=(c&amp;1008)&gt;&gt;4,l=(c&amp;15)&lt;&lt;2,t+=$e[s]+$e[a]+$e[l]+"="),t}function Dl(e){if(!!e.generator?.previewFeatures.some(t=&gt;t.toLowerCase().includes("metrics")))throw new P(<span class="branch-0 cbranch-no" title="branch not covered" >"The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate",e.clientVersion)}var Ol={"@prisma/debug":<span class="branch-0 cbranch-no" title="branch not covered" >"workspace:*","</span>@prisma/engines-version":"6.15.0-5.85179d7826409ee107a6ba334b5e305ae3fba9fb","</span>@prisma/fetch-engine":"workspace:*",<span class="fstat-no" title="function not covered" >"@prisma/get-platform":"workspace:*"};var Ft=class extends se{name="RequestError";code="P5010";<span class="fstat-no" title="function not covered" >constructor(r</span>,t){super(`Cannot fetch data from service:</span>
${r}`,R(t,!0))}};x(Ft,<span class="fstat-no" title="function not covered" >"RequestError");async function dr(e,r,t=n=&gt;n){let{clientVersion:n,...i}=r,o=t(fetch);try{<span class="fstat-no" title="function not covered" >return a</span>wait o(e,i)}catch(s){let a=s.message??"Unknown error";throw new Ft(a,{clientVersion:n,cause:s})}}var gf=/^[1-9][0-9]*\.[0-9]+\.[0-9]+$/,kl=N("prisma:client:dataproxyEngine");async function hf(e,<span class="fstat-no" title="function not covered" >r){</span>let t=Ol["@prisma/engines-version"],n=r.clientVersion??"unknown";if(process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION||globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION||globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;if(e.includes("accelerate")&amp;&amp;n!=="0.0.0"&amp;&amp;n!=="in-memory")return n;let[i,o]=n?.split("-")??[];if(o===void 0&amp;&amp;gf.test(i))return i;if(o!==void 0||n==="0.0.0"||n==="in-memory"){let[s]=t.split("-")??[],[a,l,u]=s.split("."),c=yf(`&lt;=${a}.${l}.${u}`),p=await dr(c,{<span class="fstat-no" title="function not covered" >clientVersion:n</span>});if(!p.ok)throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p.status} ${p.statusText}, response body: ${await p.text()||"&lt;empty body&gt;"}`);let <span class="fstat-no" title="function not covered" >d</span>=await p.text();kl("length of body fetched from unpkg.com",d.length);let f;try{f=JSON.parse(d)}catch(h){throw console.error("JSON.parse error: body fetched from unpkg.com: ",d),h}return f.version}throw new cr("Only `major.minor.patch` versions are supported by Accelerate.",{clientVersion:n})}<span class="fstat-no" title="function not covered" >async function _</span>l(e,r){let t=await hf(e,r);return kl("version",t),t}function yf(e){return encodeURI(`https://unpkg.com/prisma@${e}/package.json`)}var Nl=3,Mt=N("prisma:client:dataproxyEngine"),$t=class{name=<span class="fstat-no" title="function not covered" >"DataProxyEngine";i</span>nlineSchema;inlineSchemaHash;inlineDatasources;config;logEmitter;env;clientVersion;engineHash;tracingHelper;remoteClientVersion;host;headerBuilder;startPromise;protocol;constructor(r){Dl(r),this.config=r,this.env=r.env,this.inlineSchema=Il(r.inlineSchema),this.inlineDatasources=r.inlineDatasources,this.inlineSchemaHash=r.inlineSchemaHash,this.clientVersion=r.clientVersion,this.engineHash=r.engineVersion,this.<span class="fstat-no" title="function not covered" >logEmitter=r</span>.logEmitter,this.tracingHelper=r.tracingHelper}apiKey(){return this.headerBuilder.apiKey}version(){return this.engineHash}async start(){this.startPromise!==void 0&amp;&amp;await this.startPromise,this.startPromise=(<span class="fstat-no" title="function not covered" >async()=&gt;{</span>let{apiKey:r,url:t}=this.getURLAndAPIKey();this.host=t.host,this.protocol=t.<span class="fstat-no" title="function not covered" >protocol,t</span>his.headerBuilder=new Hn({apiKey:r,tracingHelper:this.tracingHelper,logLevel:this.config.logLevel??"error",logQueries:this.config.logQueries,engineHash:this.engineHash}),this.remoteClientVersion=await _l(this.host,this.config),Mt("host",this.host),Mt("protocol",this.protocol)})(),await this.startPromise}async stop(){}propagateResponseExtensions(r){r?.logs?.length&amp;&amp;r.logs.forEach(t=&gt;{switch(t.level){case"debug":case"trace":Mt(t</span>);break;case"error":case"warn":case"info":{this.logEmitter.emit(<span class="branch-0 cbranch-no" title="branch not covered" >t.level,{t</span>imestamp:mo(t.timestamp),message:t.attributes.<span class="branch-0 cbranch-no" title="branch not covered" >message??"",t</span>arget:t.target});break}case<span class="branch-0 cbranch-no" title="branch not covered" >"query":{this.l</span>ogEmitter.emit("query",{query:t.attributes.query??"",timestamp:mo(t.timestamp),duration:t.attributes.duration_ms??0,params:t.attributes.params??"",target:t.target});<span class="branch-0 cbranch-no" title="branch not covered" >break}default:t.level}}),r?.traces?.length&amp;&amp;t</span>his.tracingHelper.dispatchEngineSpans(r.traces)}onBeforeExit(){throw new Error('"beforeExit" hook is not applicable to the remote query engine')}async url(r){return await this.start(),`${this.protocol}//${this.host}/${this.<span class="branch-0 cbranch-no" title="branch not covered" >remoteClientVersion}</span>/${this.<span class="branch-0 cbranch-no" title="branch not covered" >inlineSchemaHash<span class="fstat-no" title="function not covered" >}/${r}`}async uploadSchema(){let r={name:"schemaUpload",internal:!0};return this.tracingHelper.runInChildSpan(r,async()=&gt;{let t=await dr(await this.url("schema"),{method:"PUT",headers:this.h</span></span>eaderBuilder.build(),body:this.inlineSchema,<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >clientVersion:this.clientVersion});t.ok||Mt("schema response status",t</span></span>.status);let n=await Lt(t,this.clientVersion);if(n)throw this.logEmitter.emit("warn",{message:`Error while uploading schema: ${n.message}`,timestamp:new Date,target:""}),n;this.logEmitter.emit("info",{message:`Schema (re)uploaded (hash: ${this.inlineSchemaHash})`,timestamp:new Date,target:""})})}request(r,{traceparent:t,<span class="branch-0 cbranch-no" title="branch not covered" >interactiveTransaction:n</span>,customDataProxyFetch:i}){return this.requestInternal({body:r,traceparent:t,interactiveTransaction:n,customDataProxyFetch:i}<span class="branch-0 cbranch-no" title="branch not covered" >)}async requestBatch(r</span>,{traceparent:t,transaction:n,customDataProxyFetch:i}){let o=n?.kind==="itx"?n.options:void 0,s=Fr(r,n);return(await this.requestInternal({<span class="branch-0 cbranch-no" title="branch not covered" >body:s</span>,customDataProxyFetch:i,interactiveTransaction:o,traceparent:t})).map(l=&gt;(l.extensions&amp;&amp;this.propagateResponseExtensions(l.extensions),"errors"in l?this.convertProtocolErrorsToClientError(l.errors):l))}requestInternal({body:r,traceparent:t,customDataProxyFetch:n,<span class="branch-0 cbranch-no" title="branch not covered" >interactiveTransaction:i</span>}){return this.withRetry({actionGerund:"querying",callback:async({logHttpCall:o})=&gt;{let s=i?`${i.payload.endpoint}/graphql`:await this.url("graphql");o(s);let a=await dr(s,{method:"POST",headers:this.headerBuilder.build({traceparent:t,transactionId:i?.id}),body:JSON.stringify(r),<span class="branch-0 cbranch-no" title="branch not covered" >clientVersion:this.clientVersion},n);a.ok||Mt("graphql response status",a.status),await this.handleError(await L</span>t(a,this.<span class="branch-0 cbranch-no" title="branch not covered" >clientVersion));let l=await a.json();if(l.extensions&amp;&amp;this.propagateResponseExtensions(l.extensions),"errors"in l)throw this.convertProtocolErrorsToClientError(l.errors);return"batchResult"in l?l.batchResult:l}})}async transaction(r,t,n){let i={start:"starting",commit:"committing",rollback:"</span>rolling back"};<span class="fstat-no" title="function not covered" >return this.withRetry({actionGerund:`${i[r]} transaction`,callback:<span class="fstat-no" title="function not covered" >async({</span>logHttpCall:o})=&gt;{if(r==="start"){let s=JSON.s</span>tringify({<span class="fstat-no" title="function not covered" >max_wait:n.maxWait,timeout:n.timeout,isolation_level:<span class="fstat-no" title="function not covered" >n.i</span>solationLevel}),a=await this.url("transaction/start");o(a</span>);let l=await dr(a,{method:"POST",headers:this.headerBuilder.build({traceparent:t.traceparent}),body:s,clientVersion:this.clientVersion}<span class="fstat-no" title="function not covered" >);await this.handleError(await Lt(l,this.clientVersion));let u=await l.json(),{e</span>xtensions:c}=u;c&amp;&amp;this.<span class="branch-0 cbranch-no" title="branch not covered" >propagateResponseExtensions(c);let p=u.id,d=u["data-proxy"].endpoint;return{id:p,payload:{endpoint:d}}}else{let s=`${n.payload.endpoint}/${r}`;o(s);let a=await dr(s,{method:"POST",headers:this.headerBuilder.build({traceparent:t.traceparent}),clientVersion:this.clientVersion});await this.handleError(await Lt(a,this.clientVersion));let l=await a.json(),{extensions:u}=l;u&amp;&amp;t</span>his.propagateResponseExtensions(u);return}}})}getURLAndAPIKey(){return Rl({clientVersion:this.clientVersion,env:this.env,inlineDatasources:this.inlineDatasources,overrideDatasources:this.config.overrideDatasources})}metrics(){throw new cr("Metrics are not yet supported for Accelerate",{clientVersion:this.clientVersion})}async withRetry(r){for(let t=0;;t++){let n=i=&gt;{this.logEmitter.emit("info",{message:`Calling ${i} (n=${t})`,timestamp:new Date,target:""})};try{return await r.callback({logHttpCall:n})}catch(i){if(!(i instanceof se)||!i.isRetryable)throw i;if(t&gt;=Nl)throw i instanceof jr?i.cause:i;this.logEmitter.emit("warn",{message:`Attempt ${t+1}/${Nl} failed for ${r.actionGerund}: ${i.message??"(unknown)"}`,timestamp:new Date,target:""});let o=await Cl(t);this.logEmitter.emit("warn",{message:`Retrying after ${o}ms`,timestamp:new Date,target:""})}}}async handleError(r){if(r instanceof pr)throw await this.uploadSchema(),new jr({clientVersion:this.clientVersion,cause:r});if(r)throw r}convertProtocolErrorsToClientError(r){return r.length===1?Mr(r[0],this.config.clientVersion,this.config.activeProvider):new V(JSON.stringify(r),{clientVersion:this.config.clientVersion})}applyPendingMigrations(){throw new Error("Method not implemented.")}};function Ll(e){if(e?.kind==="itx")return e.options.id}var xo=A(require("node:os")),Fl=A(require("node:path"));var wo=Symbol("PrismaLibraryEngineCache");function bf(){let e=globalThis;return e[wo]===void 0&amp;&amp;(e[wo]={}),e[wo]}function Ef(e){let r=bf();if(r[e]!==void 0)return r[e];let t=Fl.default.toNamespacedPath(e),n={exports:{}},i=0;return process.platform!=="win32"&amp;&amp;(i=xo.default.constants.dlopen.RTLD_LAZY|xo.default.constants.dlopen.RTLD_DEEPBIND),process.dlopen(n,t,i),r[e]=n.exports,n.exports}var Ml={async loadLibrary(e){let r=await fi(),t=await yl("library",e);try{return e.tracingHelper.runInChildSpan({name:"loadLibrary",internal:!0},()=&gt;Ef(t))}catch(n){let i=Ai({e:n,platformInfo:r,id:t});throw new P(i,e.clientVersion)}}};var vo,$l={async loadLibrary(e){let{clientVersion:r,adapter:t,engineWasm:n}=e;if(t===void 0)throw new P(`The \`adapter\` option for \`PrismaClient\` is required in this context (${Gn().prettyName})`,r);if(n===void 0)throw new P("WASM engine was unexpectedly `undefined`",r);vo===void 0&amp;&amp;(vo=(async()=&gt;{let o=await n.getRuntime(),s=await n.getQueryEngineWasmModule();if(s==null)throw new P("The loaded wasm module was unexpectedly `undefined` or `null` once loaded",r);let a={"./query_engine_bg.js":o},l=new WebAssembly.Instance(s,a),u=l.exports.__wbindgen_start;return o.__wbg_set_wasm(l.exports),u(),o.QueryEngine})());let i=await vo;return{debugPanic(){return Promise.reject("{}")},dmmf(){return Promise.resolve("{}")},version(){return{commit:"unknown",version:"unknown"}},QueryEngine:i}}};var wf="P2036",Re=N("prisma:client:libraryEngine");function xf(e){return e.item_type==="query"&amp;&amp;"query"in e}function vf(e){return"level"in e?e.level==="error"&amp;&amp;e.message==="PANIC":!1}var ql=[...li,"native"],Pf=0xffffffffffffffffn,Po=1n;function Tf(){let e=Po++;return Po&gt;Pf&amp;&amp;(Po=1n),e}var Gr=class{name="LibraryEngine";engine;libraryInstantiationPromise;libraryStartingPromise;libraryStoppingPromise;libraryStarted;executingQueryPromise;config;QueryEngineConstructor;libraryLoader;library;logEmitter;libQueryEnginePath;binaryTarget;datasourceOverrides;datamodel;logQueries;logLevel;lastQuery;loggerRustPanic;tracingHelper;adapterPromise;versionInfo;constructor(r,t){this.libraryLoader=t??Ml,r.engineWasm!==void 0&amp;&amp;(this.libraryLoader=t??$l),this.config=r,this.libraryStarted=!1,this.logQueries=r.logQueries??!1,this.logLevel=r.logLevel??"error",this.logEmitter=r.logEmitter,this.datamodel=r.inlineSchema,this.tracingHelper=r.tracingHelper,r.enableDebugLogs&amp;&amp;(this.logLevel="debug");let n=Object.keys(r.overrideDatasources)[0],i=r.overrideDatasources[n]?.url;n!==void 0&amp;&amp;i!==void 0&amp;&amp;(this.datasourceOverrides={[n]:i}),this.libraryInstantiationPromise=this.instantiateLibrary()}wrapEngine(r){return{applyPendingMigrations:r.applyPendingMigrations?.bind(r),commitTransaction:this.withRequestId(r.commitTransaction.bind(r)),connect:this.withRequestId(r.connect.bind(r)),disconnect:this.withRequestId(r.disconnect.bind(r)),metrics:r.metrics?.bind(r),query:this.withRequestId(r.query.bind(r)),rollbackTransaction:this.withRequestId(r.rollbackTransaction.bind(r)),sdlSchema:r.sdlSchema?.bind(r),startTransaction:this.withRequestId(r.startTransaction.bind(r)),trace:r.trace.bind(r),free:r.free?.bind(r)}}withRequestId(r){return async(...t)=&gt;{let n=Tf().toString();try{return await r(...t,n)}finally{if(this.tracingHelper.isEnabled()){let i=await this.engine?.trace(n);if(i){let o=JSON.parse(i);this.tracingHelper.dispatchEngineSpans(o.spans)}}}}}async applyPendingMigrations(){throw new Error("Cannot call this method from this type of engine instance")}async transaction(r,t,n){await this.start();let i=await this.adapterPromise,o=JSON.stringify(t),s;if(r==="start"){let l=JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel});s=await this.engine?.startTransaction(l,o)}else r==="commit"?s=await this.engine?.commitTransaction(n.id,o):r==="rollback"&amp;&amp;(s=await this.engine?.rollbackTransaction(n.id,o));let a=this.parseEngineResponse(s);if(Sf(a)){let l=this.getExternalAdapterError(a,i?.errorRegistry);throw l?l.error:new z(a.message,{code:a.error_code,clientVersion:this.config.clientVersion,meta:a.meta})}else if(typeof a.message=="string")throw new V(a.message,{clientVersion:this.config.clientVersion});return a}async instantiateLibrary(){if(Re("internalSetup"),this.libraryInstantiationPromise)return this.libraryInstantiationPromise;ai(),this.binaryTarget=await this.getCurrentBinaryTarget(),await this.tracingHelper.runInChildSpan("load_engine",()=&gt;this.loadEngine()),this.version()}async getCurrentBinaryTarget(){{if(this.binaryTarget)return this.binaryTarget;let r=await this.tracingHelper.runInChildSpan("detect_platform",()=&gt;ir());if(!ql.includes(r))throw new P(`Unknown ${ce("PRISMA_QUERY_ENGINE_LIBRARY")} ${ce(W(r))}. Possible binaryTargets: ${qe(ql.join(", "))} or a path to the query engine library.
You may have to run ${qe("prisma generate")} for your changes to take effect.`,this.config.clientVersion);return r}}parseEngineResponse(r){if(!r)throw new V("Response from the Engine was empty",{clientVersion:this.config.clientVersion});try{return JSON.parse(r)}catch{throw new V("Unable to JSON.parse response from engine",{clientVersion:this.config.clientVersion})}}async loadEngine(){if(!this.engine){this.QueryEngineConstructor||(this.library=await this.libraryLoader.loadLibrary(this.config),this.QueryEngineConstructor=this.library.QueryEngine);try{let r=new WeakRef(this);this.adapterPromise||(this.adapterPromise=this.config.adapter?.connect()?.then(rn));let t=await this.adapterPromise;t&amp;&amp;Re("Using driver adapter: %O",t),this.engine=this.wrapEngine(new this.QueryEngineConstructor({datamodel:this.datamodel,env:process.env,logQueries:this.config.logQueries??!1,ignoreEnvVarErrors:!0,datasourceOverrides:this.datasourceOverrides??{},logLevel:this.logLevel,configDir:this.config.cwd,engineProtocol:"json",enableTracing:this.tracingHelper.isEnabled()},n=&gt;{r.deref()?.logger(n)},t))}catch(r){let t=r,n=this.parseInitError(t.message);throw typeof n=="string"?t:new P(n.message,this.config.clientVersion,n.error_code)}}}logger(r){let t=this.parseEngineResponse(r);t&amp;&amp;(t.level=t?.level.toLowerCase()??"unknown",xf(t)?this.logEmitter.emit("query",{timestamp:new Date,query:t.query,params:t.params,duration:Number(t.duration_ms),target:t.module_path}):vf(t)?this.loggerRustPanic=new le(To(this,`${t.message}: ${t.reason} in ${t.file}:${t.line}:${t.column}`),this.config.clientVersion):this.logEmitter.emit(t.level,{timestamp:new Date,message:t.message,target:t.module_path}))}parseInitError(r){try{return JSON.parse(r)}catch{}return r}parseRequestError(r){try{return JSON.parse(r)}catch{}return r}onBeforeExit(){throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.')}async start(){if(this.libraryInstantiationPromise||(this.libraryInstantiationPromise=this.instantiateLibrary()),await this.libraryInstantiationPromise,await this.libraryStoppingPromise,this.libraryStartingPromise)return Re(`library already starting, this.libraryStarted: ${this.libraryStarted}`),this.libraryStartingPromise;if(this.libraryStarted)return;let r=async()=&gt;{Re("library starting");try{let t={traceparent:this.tracingHelper.getTraceParent()};await this.engine?.connect(JSON.stringify(t)),this.libraryStarted=!0,this.adapterPromise||(this.adapterPromise=this.config.adapter?.connect()?.then(rn)),await this.adapterPromise,Re("library started")}catch(t){let n=this.parseInitError(t.message);throw typeof n=="string"?t:new P(n.message,this.config.clientVersion,n.error_code)}finally{this.libraryStartingPromise=void 0}};return this.libraryStartingPromise=this.tracingHelper.runInChildSpan("connect",r),this.libraryStartingPromise}async stop(){if(await this.libraryInstantiationPromise,await this.libraryStartingPromise,await this.executingQueryPromise,this.libraryStoppingPromise)return Re("library is already stopping"),this.libraryStoppingPromise;if(!this.libraryStarted){await(await this.adapterPromise)?.dispose(),this.adapterPromise=void 0;return}let r=async()=&gt;{await new Promise(n=&gt;setImmediate(n)),Re("library stopping");let t={traceparent:this.tracingHelper.getTraceParent()};await this.engine?.disconnect(JSON.stringify(t)),this.engine?.free&amp;&amp;this.engine.free(),this.engine=void 0,this.libraryStarted=!1,this.libraryStoppingPromise=void 0,this.libraryInstantiationPromise=void 0,await(await this.adapterPromise)?.dispose(),this.adapterPromise=void 0,Re("library stopped")};return this.libraryStoppingPromise=this.tracingHelper.runInChildSpan("disconnect",r),this.libraryStoppingPromise}version(){return this.versionInfo=this.library?.version(),this.versionInfo?.version??"unknown"}debugPanic(r){return this.library?.debugPanic(r)}async request(r,{traceparent:t,interactiveTransaction:n}){Re(`sending request, this.libraryStarted: ${this.libraryStarted}`);let i=JSON.stringify({traceparent:t}),o=JSON.stringify(r);try{await this.start();let s=await this.adapterPromise;this.executingQueryPromise=this.engine?.query(o,i,n?.id),this.lastQuery=o;let a=this.parseEngineResponse(await this.executingQueryPromise);if(a.errors)throw a.errors.length===1?this.buildQueryError(a.errors[0],s?.errorRegistry):new V(JSON.stringify(a.errors),{clientVersion:this.config.clientVersion});if(this.loggerRustPanic)throw this.loggerRustPanic;return{data:a}}catch(s){if(s instanceof P)throw s;if(s.code==="GenericFailure"&amp;&amp;s.message?.startsWith("PANIC:"))throw new le(To(this,s.message),this.config.clientVersion);let a=this.parseRequestError(s.message);throw typeof a=="string"?s:new V(`${a.message}
${a.backtrace}`,{clientVersion:this.config.clientVersion})}}async requestBatch(r,{transaction:t,traceparent:n}){Re("requestBatch");let i=Fr(r,t);await this.start();let o=await this.adapterPromise;this.lastQuery=JSON.stringify(i),this.executingQueryPromise=this.engine?.query(this.lastQuery,JSON.stringify({traceparent:n}),Ll(t));let s=await this.executingQueryPromise,a=this.parseEngineResponse(s);if(a.errors)throw a.errors.length===1?this.buildQueryError(a.errors[0],o?.errorRegistry):new V(JSON.stringify(a.errors),{clientVersion:this.config.clientVersion});let{batchResult:l,errors:u}=a;if(Array.isArray(l))return l.map(c=&gt;c.errors&amp;&amp;c.errors.length&gt;0?this.loggerRustPanic??this.buildQueryError(c.errors[0],o?.errorRegistry):{data:c});throw u&amp;&amp;u.length===1?new Error(u[0].error):new Error(JSON.stringify(a))}buildQueryError(r,t){if(r.user_facing_error.is_panic)return new le(To(this,r.user_facing_error.message),this.config.clientVersion);let n=this.getExternalAdapterError(r.user_facing_error,t);return n?n.error:Mr(r,this.config.clientVersion,this.config.activeProvider)}getExternalAdapterError(r,t){if(r.error_code===wf&amp;&amp;t){let n=r.meta?.id;an(typeof n=="number","Malformed external JS error received from the engine");let i=t.consumeError(n);return an(i,"External error with reported id was not registered"),i}}async metrics(r){await this.start();let t=await this.engine.metrics(JSON.stringify(r));return r.format==="prometheus"?t:this.parseEngineResponse(t)}};function Sf(e){return typeof e=="object"&amp;&amp;e!==null&amp;&amp;e.error_code!==void 0}function To(e,r){return Pl({binaryTarget:e.binaryTarget,title:r,version:e.config.clientVersion,engineVersion:e.versionInfo?.commit,database:e.config.activeProvider,query:e.lastQuery})}function Vl({url:e,adapter:r,copyEngine:t,targetBuildType:n}){let i=[],o=[],s=g=&gt;{i.push({_tag:"warning",value:g})},a=g=&gt;{let D=g.join(`
`);o.push({_tag:"error",value:D})},l=!!e?.startsWith("prisma://"),u=sn(e),c=!!r,p=l||u;!c&amp;&amp;t&amp;&amp;p&amp;&amp;s(["recommend--no-engine","In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)"]);let d=p||!t;c&amp;&amp;(d||n==="edge")&amp;&amp;(n==="edge"?a(["Prisma Client was configured to use the `adapter` option but it was imported via its `/edge` endpoint.","Please either remove the `/edge` endpoint or remove the `adapter` from the Prisma Client constructor."]):t?l&amp;&amp;a(["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.","Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."]):a(["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.","Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."]));let f={accelerate:d,ppg:u,driverAdapters:c};function h(g){return g.length&gt;0}return h(o)?{ok:!1,diagnostics:{warnings:i,errors:o},isUsing:f}:{ok:!0,diagnostics:{warnings:i},isUsing:f}}function jl({copyEngine:e=!0},r){let t;try{t=Vr({inlineDatasources:r.inlineDatasources,overrideDatasources:r.overrideDatasources,env:{...r.env,...process.env},clientVersion:r.clientVersion})}catch{}let{ok:n,isUsing:i,diagnostics:o}=Vl({url:t,adapter:r.adapter,copyEngine:e,targetBuildType:"library"});for(let p of o.warnings)st(...p.value);if(!n){let p=o.errors[0];throw new Z(p.value,{clientVersion:r.clientVersion})}let s=Er(r.generator),a=s==="library",l=s==="binary",u=s==="client",c=(i.accelerate||i.ppg)&amp;&amp;!i.driverAdapters;return i.accelerate?new $t(r):(i.driverAdapters,a?new Gr(r):(i.accelerate,new Gr(r)))}function Yn({generator:e}){return e?.previewFeatures??[]}var Bl=e=&gt;({command:e});var Ul=e=&gt;e.strings.reduce((r,t,n)=&gt;`${r}@P${n}${t}`);function Qr(e){try{return Gl(e,"fast")}catch{return Gl(e,"slow")}}function Gl(e,r){return JSON.stringify(e.map(t=&gt;Wl(t,r)))}function Wl(e,r){if(Array.isArray(e))return e.map(t=&gt;Wl(t,r));if(typeof e=="bigint")return{prisma__type:"bigint",prisma__value:e.toString()};if(xr(e))return{prisma__type:"date",prisma__value:e.toJSON()};if(Fe.isDecimal(e))return{prisma__type:"decimal",prisma__value:e.toJSON()};if(Buffer.isBuffer(e))return{prisma__type:"bytes",prisma__value:e.toString("base64")};if(Rf(e))return{prisma__type:"bytes",prisma__value:Buffer.from(e).toString("base64")};if(ArrayBuffer.isView(e)){let{buffer:t,byteOffset:n,byteLength:i}=e;return{prisma__type:"bytes",prisma__value:Buffer.from(t,n,i).toString("base64")}}return typeof e=="object"&amp;&amp;r==="slow"?Jl(e):e}function Rf(e){return e instanceof ArrayBuffer||e instanceof SharedArrayBuffer?!0:typeof e=="object"&amp;&amp;e!==null?e[Symbol.toStringTag]==="ArrayBuffer"||e[Symbol.toStringTag]==="SharedArrayBuffer":!1}function Jl(e){if(typeof e!="object"||e===null)return e;if(typeof e.toJSON=="function")return e.toJSON();if(Array.isArray(e))return e.map(Ql);let r={};for(let t of Object.keys(e))r[t]=Ql(e[t]);return r}function Ql(e){return typeof e=="bigint"?e.toString():Jl(e)}var Af=/^(\s*alter\s)/i,Kl=N("prisma:client");function So(e,r,t,n){if(!(e!=="postgresql"&amp;&amp;e!=="cockroachdb")&amp;&amp;t.length&gt;0&amp;&amp;Af.exec(r))throw new Error(`Running ALTER using ${n} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.
&nbsp;
Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)
&nbsp;
More Information: https://pris.ly/d/execute-raw
`)}var Ro=({clientMethod:e,activeProvider:r})=&gt;t=&gt;{let n="",i;if(qn(t))n=t.sql,i={values:Qr(t.values),__prismaRawParameters__:!0};else if(Array.isArray(t)){let[o,...s]=t;n=o,i={values:Qr(s||[]),__prismaRawParameters__:!0}}else switch(r){case"sqlite":case"mysql":{n=t.sql,i={values:Qr(t.values),__prismaRawParameters__:!0};break}case"cockroachdb":case"postgresql":case"postgres":{n=t.text,i={values:Qr(t.values),__prismaRawParameters__:!0};break}case"sqlserver":{n=Ul(t),i={values:Qr(t.values),__prismaRawParameters__:!0};break}default:throw new Error(`The ${r} provider does not support ${e}`)}return i?.values?Kl(`prisma.${e}(${n}, ${i.values})`):Kl(`prisma.${e}(${n})`),{query:n,parameters:i}},Hl={requestArgsToMiddlewareArgs(e){return[e.strings,...e.values]},middlewareArgsToRequestArgs(e){let[r,...t]=e;return new oe(r,t)}},Yl={requestArgsToMiddlewareArgs(e){return[e]},middlewareArgsToRequestArgs(e){return e[0]}};function Ao(e){return function(t,n){let i,o=(s=e)=&gt;{try{return s===void 0||s?.kind==="itx"?i??=zl(t(s)):zl(t(s))}catch(a){return Promise.reject(a)}};return{get spec(){return n},then(s,a){return o().then(s,a)},catch(s){return o().catch(s)},finally(s){return o().finally(s)},requestTransaction(s){let a=o(s);return a.requestTransaction?a.requestTransaction(s):a},[Symbol.toStringTag]:"PrismaPromise"}}}function zl(e){return typeof e.then=="function"?e:Promise.resolve(e)}var Cf=xi.split(".")[0],If={isEnabled(){return!1},getTraceParent(){return"00-10-10-00"},dispatchEngineSpans(){},getActiveContext(){},runInChildSpan(e,r){return r()}},Co=class{isEnabled(){return this.getGlobalTracingHelper().isEnabled()}getTraceParent(r){return this.getGlobalTracingHelper().getTraceParent(r)}dispatchEngineSpans(r){return this.getGlobalTracingHelper().dispatchEngineSpans(r)}getActiveContext(){return this.getGlobalTracingHelper().getActiveContext()}runInChildSpan(r,t){return this.getGlobalTracingHelper().runInChildSpan(r,t)}getGlobalTracingHelper(){let r=globalThis[`V${Cf}_PRISMA_INSTRUMENTATION`],t=globalThis.PRISMA_INSTRUMENTATION;return r?.helper??t?.helper??If}};function Zl(){return new Co}function Xl(e,r=()=&gt;{}){let t,n=new Promise(i=&gt;t=i);return{then(i){return--e===0&amp;&amp;t(r()),i?.(n)}}}function eu(e){return typeof e=="string"?e:e.reduce((r,t)=&gt;{let n=typeof t=="string"?t:t.level;return n==="query"?r:r&amp;&amp;(t==="info"||r==="info")?"info":n},void 0)}var tu=A(Ni());function zn(e){return typeof e.batchRequestIdx=="number"}function ru(e){if(e.action!=="findUnique"&amp;&amp;e.action!=="findUniqueOrThrow")return;let r=[];return e.modelName&amp;&amp;r.push(e.modelName),e.query.arguments&amp;&amp;r.push(Io(e.query.arguments)),r.push(Io(e.query.selection)),r.join("")}function Io(e){return`(${Object.keys(e).sort().map(t=&gt;{let n=e[t];return typeof n=="object"&amp;&amp;n!==null?`(${t} ${Io(n)})`:t}).join(" ")})`}var Df={aggregate:!1,aggregateRaw:!1,createMany:!0,createManyAndReturn:!0,createOne:!0,deleteMany:!0,deleteOne:!0,executeRaw:!0,findFirst:!1,findFirstOrThrow:!1,findMany:!1,findRaw:!1,findUnique:!1,findUniqueOrThrow:!1,groupBy:!1,queryRaw:!1,runCommandRaw:!0,updateMany:!0,updateManyAndReturn:!0,updateOne:!0,upsertOne:!0};function Do(e){return Df[e]}var Zn=class{constructor(r){this.options=r;this.batches={}}batches;tickActive=!1;request(r){let t=this.options.batchBy(r);return t?(this.batches[t]||(this.batches[t]=[],this.tickActive||(this.tickActive=!0,process.nextTick(()=&gt;{this.dispatchBatches(),this.tickActive=!1}))),new Promise((n,i)=&gt;{this.batches[t].push({request:r,resolve:n,reject:i})})):this.options.singleLoader(r)}dispatchBatches(){for(let r in this.batches){let t=this.batches[r];delete this.batches[r],t.length===1?this.options.singleLoader(t[0].request).then(n=&gt;{n instanceof Error?t[0].reject(n):t[0].resolve(n)}).catch(n=&gt;{t[0].reject(n)}):(t.sort((n,i)=&gt;this.options.batchOrder(n.request,i.request)),this.options.batchLoader(t.map(n=&gt;n.request)).then(n=&gt;{if(n instanceof Error)for(let i=0;i&lt;t.length;i++)t[i].reject(n);else for(let i=0;i&lt;t.length;i++){let o=n[i];o instanceof Error?t[i].reject(o):t[i].resolve(o)}}).catch(n=&gt;{for(let i=0;i&lt;t.length;i++)t[i].reject(n)}))}}get[Symbol.toStringTag](){return"DataLoader"}};function mr(e,r){if(r===null)return r;switch(e){case"bigint":return BigInt(r);case"bytes":{let{buffer:t,byteOffset:n,byteLength:i}=Buffer.from(r,"base64");return new Uint8Array(t,n,i)}case"decimal":return new Fe(r);case"datetime":case"date":return new Date(r);case"time":return new Date(`1970-01-01T${r}Z`);case"bigint-array":return r.map(t=&gt;mr("bigint",t));case"bytes-array":return r.map(t=&gt;mr("bytes",t));case"decimal-array":return r.map(t=&gt;mr("decimal",t));case"datetime-array":return r.map(t=&gt;mr("datetime",t));case"date-array":return r.map(t=&gt;mr("date",t));case"time-array":return r.map(t=&gt;mr("time",t));default:return r}}function Xn(e){let r=[],t=Of(e);for(let n=0;n&lt;e.rows.length;n++){let i=e.rows[n],o={...t};for(let s=0;s&lt;i.length;s++)o[e.columns[s]]=mr(e.types[s],i[s]);r.push(o)}return r}function Of(e){let r={};for(let t=0;t&lt;e.columns.length;t++)r[e.columns[t]]=null;return r}var kf=N("prisma:client:request_handler"),ei=class{client;dataloader;logEmitter;constructor(r,t){this.logEmitter=t,this.client=r,this.dataloader=new Zn({batchLoader:ol(async({requests:n,customDataProxyFetch:i})=&gt;{let{transaction:o,otelParentCtx:s}=n[0],a=n.map(p=&gt;p.protocolQuery),l=this.client._tracingHelper.getTraceParent(s),u=n.some(p=&gt;Do(p.protocolQuery.action));return(await this.client._engine.requestBatch(a,{traceparent:l,transaction:_f(o),containsWrite:u,customDataProxyFetch:i})).map((p,d)=&gt;{if(p instanceof Error)return p;try{return this.mapQueryEngineResult(n[d],p)}catch(f){return f}})}),singleLoader:async n=&gt;{let i=n.transaction?.kind==="itx"?nu(n.transaction):void 0,o=await this.client._engine.request(n.protocolQuery,{traceparent:this.client._tracingHelper.getTraceParent(),interactiveTransaction:i,isWrite:Do(n.protocolQuery.action),customDataProxyFetch:n.customDataProxyFetch});return this.mapQueryEngineResult(n,o)},batchBy:n=&gt;n.transaction?.id?`transaction-${n.transaction.id}`:ru(n.protocolQuery),batchOrder(n,i){return n.transaction?.kind==="batch"&amp;&amp;i.transaction?.kind==="batch"?n.transaction.index-i.transaction.index:0}})}async request(r){try{return await this.dataloader.request(r)}catch(t){let{clientMethod:n,callsite:i,transaction:o,args:s,modelName:a}=r;this.handleAndLogRequestError({error:t,clientMethod:n,callsite:i,transaction:o,args:s,modelName:a,globalOmit:r.globalOmit})}}mapQueryEngineResult({dataPath:r,unpacker:t},n){let i=n?.data,o=this.unpack(i,r,t);return process.env.PRISMA_CLIENT_GET_TIME?{data:o}:o}handleAndLogRequestError(r){try{this.handleRequestError(r)}catch(t){throw this.logEmitter&amp;&amp;this.logEmitter.emit("error",{message:t.message,target:r.clientMethod,timestamp:new Date}),t}}handleRequestError({error:r,clientMethod:t,callsite:n,transaction:i,args:o,modelName:s,globalOmit:a}){if(kf(r),Nf(r,i))throw r;if(r instanceof z&amp;&amp;Lf(r)){let u=iu(r.meta);_n({args:o,errors:[u],callsite:n,errorFormat:this.client._errorFormat,originalMethod:t,clientVersion:this.client._clientVersion,globalOmit:a})}let l=r.message;if(n&amp;&amp;(l=Pn({callsite:n,originalMethod:t,isPanic:r.isPanic,showColors:this.client._errorFormat==="pretty",message:l})),l=this.sanitizeMessage(l),r.code){let u=s?{modelName:s,...r.meta}:r.meta;throw new z(l,{code:r.code,clientVersion:this.client._clientVersion,meta:u,batchRequestIdx:r.batchRequestIdx})}else{if(r.isPanic)throw new le(l,this.client._clientVersion);if(r instanceof V)throw new V(l,{clientVersion:this.client._clientVersion,batchRequestIdx:r.batchRequestIdx});if(r instanceof P)throw new P(l,this.client._clientVersion);if(r instanceof le)throw new le(l,this.client._clientVersion)}throw r.clientVersion=this.client._clientVersion,r}sanitizeMessage(r){return this.client._errorFormat&amp;&amp;this.client._errorFormat!=="pretty"?(0,tu.default)(r):r}unpack(r,t,n){if(!r||(r.data&amp;&amp;(r=r.data),!r))return r;let i=Object.keys(r)[0],o=Object.values(r)[0],s=t.filter(u=&gt;u!=="select"&amp;&amp;u!=="include"),a=ao(o,s),l=i==="queryRaw"?Xn(a):qr(a);return n?n(l):l}get[Symbol.toStringTag](){return"RequestHandler"}};function _f(e){if(e){if(e.kind==="batch")return{kind:"batch",options:{isolationLevel:e.isolationLevel}};if(e.kind==="itx")return{kind:"itx",options:nu(e)};ar(e,"Unknown transaction kind")}}function nu(e){return{id:e.id,payload:e.payload}}function Nf(e,r){return zn(e)&amp;&amp;r?.kind==="batch"&amp;&amp;e.batchRequestIdx!==r.index}function Lf(e){return e.code==="P2009"||e.code==="P2012"}function iu(e){if(e.kind==="Union")return{kind:"Union",errors:e.errors.map(iu)};if(Array.isArray(e.selectionPath)){let[,...r]=e.selectionPath;return{...e,selectionPath:r}}return e}var ou=Sl;var cu=A(Ki());var k=class extends Error{constructor(r){super(r+`
Read more at https://pris.ly/d/client-constructor`),this.name="PrismaClientConstructorValidationError"}get[Symbol.toStringTag](){return"PrismaClientConstructorValidationError"}};x(k,"PrismaClientConstructorValidationError");var su=["datasources","datasourceUrl","errorFormat","adapter","log","transactionOptions","omit","__internal"],au=["pretty","colorless","minimal"],lu=["info","query","warn","error"],Ff={datasources:(e,{datasourceNames:r})=&gt;{if(e){if(typeof e!="object"||Array.isArray(e))throw new k(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);for(let[t,n]of Object.entries(e)){if(!r.includes(t)){let i=Wr(t,r)||` Available datasources: ${r.join(", ")}`;throw new k(`Unknown datasource ${t} provided to PrismaClient constructor.${i}`)}if(typeof n!="object"||Array.isArray(n))throw new k(`Invalid value ${JSON.stringify(e)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);if(n&amp;&amp;typeof n=="object")for(let[i,o]of Object.entries(n)){if(i!=="url")throw new k(`Invalid value ${JSON.stringify(e)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);if(typeof o!="string")throw new k(`Invalid value ${JSON.stringify(o)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`)}}}},adapter:(e,r)=&gt;{if(!e&amp;&amp;Er(r.generator)==="client")throw new k('Using engine type "client" requires a driver adapter to be provided to PrismaClient constructor.');if(e===null)return;if(e===void 0)throw new k('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');if(!Yn(r).includes("driverAdapters"))throw new k('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');if(Er(r.generator)==="binary")throw new k('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.')},datasourceUrl:e=&gt;{if(typeof e&lt;"u"&amp;&amp;typeof e!="string")throw new k(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`)},errorFormat:e=&gt;{if(e){if(typeof e!="string")throw new k(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);if(!au.includes(e)){let r=Wr(e,au);throw new k(`Invalid errorFormat ${e} provided to PrismaClient constructor.${r}`)}}},log:e=&gt;{if(!e)return;if(!Array.isArray(e))throw new k(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);function r(t){if(typeof t=="string"&amp;&amp;!lu.includes(t)){let n=Wr(t,lu);throw new k(`Invalid log level "${t}" provided to PrismaClient constructor.${n}`)}}for(let t of e){r(t);let n={level:r,emit:i=&gt;{let o=["stdout","event"];if(!o.includes(i)){let s=Wr(i,o);throw new k(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`)}}};if(t&amp;&amp;typeof t=="object")for(let[i,o]of Object.entries(t))if(n[i])n[i](o);else throw new k(`Invalid property ${i} for "log" provided to PrismaClient constructor`)}},transactionOptions:e=&gt;{if(!e)return;let r=e.maxWait;if(r!=null&amp;&amp;r&lt;=0)throw new k(`Invalid value ${r} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);let t=e.timeout;if(t!=null&amp;&amp;t&lt;=0)throw new k(`Invalid value ${t} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`)},omit:(e,r)=&gt;{if(typeof e!="object")throw new k('"omit" option is expected to be an object.');if(e===null)throw new k('"omit" option can not be `null`');let t=[];for(let[n,i]of Object.entries(e)){let o=$f(n,r.runtimeDataModel);if(!o){t.push({kind:"UnknownModel",modelKey:n});continue}for(let[s,a]of Object.entries(i)){let l=o.fields.find(u=&gt;u.name===s);if(!l){t.push({kind:"UnknownField",modelKey:n,fieldName:s});continue}if(l.relationName){t.push({kind:"RelationInOmit",modelKey:n,fieldName:s});continue}typeof a!="boolean"&amp;&amp;t.push({kind:"InvalidFieldValue",modelKey:n,fieldName:s})}}if(t.length&gt;0)throw new k(qf(e,t))},__internal:e=&gt;{if(!e)return;let r=["debug","engine","configOverride"];if(typeof e!="object")throw new k(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);for(let[t]of Object.entries(e))if(!r.includes(t)){let n=Wr(t,r);throw new k(`Invalid property ${JSON.stringify(t)} for "__internal" provided to PrismaClient constructor.${n}`)}}};function pu(e,r){for(let[t,n]of Object.entries(e)){if(!su.includes(t)){let i=Wr(t,su);throw new k(`Unknown property ${t} provided to PrismaClient constructor.${i}`)}Ff[t](n,r)}if(e.datasourceUrl&amp;&amp;e.datasources)throw new k('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them')}function Wr(e,r){if(r.length===0||typeof e!="string")return"";let t=Mf(e,r);return t?` Did you mean "${t}"?`:""}function Mf(e,r){if(r.length===0)return null;let t=r.map(i=&gt;({value:i,distance:(0,cu.default)(e,i)}));t.sort((i,o)=&gt;i.distance&lt;o.distance?-1:1);let n=t[0];return n.distance&lt;3?n.value:null}function $f(e,r){return uu(r.models,e)??uu(r.types,e)}function uu(e,r){let t=Object.keys(e).find(n=&gt;We(n)===r);if(t)return e[t]}function qf(e,r){let t=kr(e);for(let o of r)switch(o.kind){case"UnknownModel":t.arguments.getField(o.modelKey)?.markAsError(),t.addErrorMessage(()=&gt;`Unknown model name: ${o.modelKey}.`);break;case"UnknownField":t.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),t.addErrorMessage(()=&gt;`Model "${o.modelKey}" does not have a field named "${o.fieldName}".`);break;case"RelationInOmit":t.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),t.addErrorMessage(()=&gt;'Relations are already excluded by default and can not be specified in "omit".');break;case"InvalidFieldValue":t.arguments.getDeepFieldValue([o.modelKey,o.fieldName])?.markAsError(),t.addErrorMessage(()=&gt;"Omit field option value must be a boolean.");break}let{message:n,args:i}=kn(t,"colorless");return`Error validating "omit" option:
&nbsp;
${i}
&nbsp;
${n}`}function du(e){return e.length===0?Promise.resolve([]):new Promise((r,t)=&gt;{let n=new Array(e.length),i=null,o=!1,s=0,a=()=&gt;{o||(s++,s===e.length&amp;&amp;(o=!0,i?t(i):r(n)))},l=u=&gt;{o||(o=!0,t(u))};for(let u=0;u&lt;e.length;u++)e[u].then(c=&gt;{n[u]=c,a()},c=&gt;{if(!zn(c)){l(c);return}c.batchRequestIdx===u?l(c):(i||(i=c),a())})})}var rr=N("prisma:client");typeof globalThis=="object"&amp;&amp;(globalThis.NODE_CLIENT=!0);var Vf={requestArgsToMiddlewareArgs:e=&gt;e,middlewareArgsToRequestArgs:e=&gt;e},jf=Symbol.for("prisma.client.transaction.id"),Bf={id:0,nextId(){return++this.id}};function bu(e){class r{_originalClient=this;_runtimeDataModel;_requestHandler;_connectionPromise;_disconnectionPromise;_engineConfig;_accelerateEngineConfig;_clientVersion;_errorFormat;_tracingHelper;_previewFeatures;_activeProvider;_globalOmit;_extensions;_engine;_appliedParent;_createPrismaPromise=Ao();constructor(n){e=n?.__internal?.configOverride?.(e)??e,cl(e),n&amp;&amp;pu(n,e);let i=new hu.EventEmitter().on("error",()=&gt;{});this._extensions=_r.empty(),this._previewFeatures=Yn(e),this._clientVersion=e.clientVersion??ou,this._activeProvider=e.activeProvider,this._globalOmit=n?.omit,this._tracingHelper=Zl();let o=e.relativeEnvPaths&amp;&amp;{rootEnvPath:e.relativeEnvPaths.rootEnvPath&amp;&amp;ri.default.resolve(e.dirname,e.relativeEnvPaths.rootEnvPath),schemaEnvPath:e.relativeEnvPaths.schemaEnvPath&amp;&amp;ri.default.resolve(e.dirname,e.relativeEnvPaths.schemaEnvPath)},s;if(n?.adapter){s=n.adapter;let l=e.activeProvider==="postgresql"||e.activeProvider==="cockroachdb"?"postgres":e.activeProvider;if(s.provider!==l)throw new P(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${l}\` specified in the Prisma schema.`,this._clientVersion);if(n.datasources||n.datasourceUrl!==void 0)throw new P("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.",this._clientVersion)}let a=!s&amp;&amp;o&amp;&amp;ot(o,{conflictCheck:"none"})||e.injectableEdgeEnv?.();try{let l=n??{},u=l.__internal??{},c=u.debug===!0;c&amp;&amp;N.enable("prisma:client");let p=ri.default.resolve(e.dirname,e.relativePath);yu.default.existsSync(p)||(p=e.dirname),rr("dirname",e.dirname),rr("relativePath",e.relativePath),rr("cwd",p);let d=u.engine||{};if(l.errorFormat?this._errorFormat=l.errorFormat:process.env.NODE_ENV==="production"?this._errorFormat="minimal":process.env.NO_COLOR?this._errorFormat="colorless":this._errorFormat="colorless",this._runtimeDataModel=e.runtimeDataModel,this._engineConfig={cwd:p,dirname:e.dirname,enableDebugLogs:c,allowTriggerPanic:d.allowTriggerPanic,prismaPath:d.binaryPath??void 0,engineEndpoint:d.endpoint,generator:e.generator,showColors:this._errorFormat==="pretty",logLevel:l.log&amp;&amp;eu(l.log),logQueries:l.log&amp;&amp;!!(typeof l.log=="string"?l.log==="query":l.log.find(f=&gt;typeof f=="string"?f==="query":f.level==="query")),env:a?.parsed??{},flags:[],engineWasm:e.engineWasm,compilerWasm:e.compilerWasm,clientVersion:e.clientVersion,engineVersion:e.engineVersion,previewFeatures:this._previewFeatures,activeProvider:e.activeProvider,inlineSchema:e.inlineSchema,overrideDatasources:pl(l,e.datasourceNames),inlineDatasources:e.inlineDatasources,inlineSchemaHash:e.inlineSchemaHash,tracingHelper:this._tracingHelper,transactionOptions:{maxWait:l.transactionOptions?.maxWait??2e3,timeout:l.transactionOptions?.timeout??5e3,isolationLevel:l.transactionOptions?.isolationLevel},logEmitter:i,isBundled:e.isBundled,adapter:s},this._accelerateEngineConfig={...this._engineConfig,accelerateUtils:{resolveDatasourceUrl:Vr,getBatchRequestPayload:Fr,prismaGraphQLToJSError:Mr,PrismaClientUnknownRequestError:V,PrismaClientInitializationError:P,PrismaClientKnownRequestError:z,debug:N("prisma:client:accelerateEngine"),engineVersion:fu.version,clientVersion:e.clientVersion}},rr("clientVersion",e.clientVersion),this._engine=jl(e,this._engineConfig),this._requestHandler=new ei(this,i),l.log)for(let f of l.log){let h=typeof f=="string"?f:f.emit==="stdout"?f.level:null;h&amp;&amp;this.$on(h,g=&gt;{tt.log(`${tt.tags[h]??""}`,g.message||g.query)})}}catch(l){throw l.clientVersion=this._clientVersion,l}return this._appliedParent=vt(this)}get[Symbol.toStringTag](){return"PrismaClient"}$on(n,i){return n==="beforeExit"?this._engine.onBeforeExit(i):n&amp;&amp;this._engineConfig.logEmitter.on(n,i),this}$connect(){try{return this._engine.start()}catch(n){throw n.clientVersion=this._clientVersion,n}}async $disconnect(){try{await this._engine.stop()}catch(n){throw n.clientVersion=this._clientVersion,n}finally{Go()}}$executeRawInternal(n,i,o,s){let a=this._activeProvider;return this._request({action:"executeRaw",args:o,transaction:n,clientMethod:i,argsMapper:Ro({clientMethod:i,activeProvider:a}),callsite:Ze(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}$executeRaw(n,...i){return this._createPrismaPromise(o=&gt;{if(n.raw!==void 0||n.sql!==void 0){let[s,a]=mu(n,i);return So(this._activeProvider,s.text,s.values,Array.isArray(n)?"prisma.$executeRaw`&lt;SQL&gt;`":"prisma.$executeRaw(sql`&lt;SQL&gt;`)"),this.$executeRawInternal(o,"$executeRaw",s,a)}throw new Z("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n",{clientVersion:this._clientVersion})})}$executeRawUnsafe(n,...i){return this._createPrismaPromise(o=&gt;(So(this._activeProvider,n,i,"prisma.$executeRawUnsafe(&lt;SQL&gt;, [...values])"),this.$executeRawInternal(o,"$executeRawUnsafe",[n,...i])))}$runCommandRaw(n){if(e.activeProvider!=="mongodb")throw new Z(`The ${e.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`,{clientVersion:this._clientVersion});return this._createPrismaPromise(i=&gt;this._request({args:n,clientMethod:"$runCommandRaw",dataPath:[],action:"runCommandRaw",argsMapper:Bl,callsite:Ze(this._errorFormat),transaction:i}))}async $queryRawInternal(n,i,o,s){let a=this._activeProvider;return this._request({action:"queryRaw",args:o,transaction:n,clientMethod:i,argsMapper:Ro({clientMethod:i,activeProvider:a}),callsite:Ze(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}$queryRaw(n,...i){return this._createPrismaPromise(o=&gt;{if(n.raw!==void 0||n.sql!==void 0)return this.$queryRawInternal(o,"$queryRaw",...mu(n,i));throw new Z("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n",{clientVersion:this._clientVersion})})}$queryRawTyped(n){return this._createPrismaPromise(i=&gt;{if(!this._hasPreviewFlag("typedSql"))throw new Z("`typedSql` preview feature must be enabled in order to access $queryRawTyped API",{clientVersion:this._clientVersion});return this.$queryRawInternal(i,"$queryRawTyped",n)})}$queryRawUnsafe(n,...i){return this._createPrismaPromise(o=&gt;this.$queryRawInternal(o,"$queryRawUnsafe",[n,...i]))}_transactionWithArray({promises:n,options:i}){let o=Bf.nextId(),s=Xl(n.length),a=n.map((l,u)=&gt;{if(l?.[Symbol.toStringTag]!=="PrismaPromise")throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");let c=i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel,p={kind:"batch",id:o,index:u,isolationLevel:c,lock:s};return l.requestTransaction?.(p)??l});return du(a)}async _transactionWithCallback({callback:n,options:i}){let o={traceparent:this._tracingHelper.getTraceParent()},s={maxWait:i?.maxWait??this._engineConfig.transactionOptions.maxWait,timeout:i?.timeout??this._engineConfig.transactionOptions.timeout,isolationLevel:i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel},a=await this._engine.transaction("start",o,s),l;try{let u={kind:"itx",...a};l=await n(this._createItxClient(u)),await this._engine.transaction("commit",o,a)}catch(u){throw await this._engine.transaction("rollback",o,a).catch(()=&gt;{}),u}return l}_createItxClient(n){return he(vt(he(Ha(this),[re("_appliedParent",()=&gt;this._appliedParent._createItxClient(n)),re("_createPrismaPromise",()=&gt;Ao(n)),re(jf,()=&gt;n.id)])),[Lr(el)])}$transaction(n,i){let o;typeof n=="function"?this._engineConfig.adapter?.adapterName==="@prisma/adapter-d1"?o=()=&gt;{throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.")}:o=()=&gt;this._transactionWithCallback({callback:n,options:i}):o=()=&gt;this._transactionWithArray({promises:n,options:i});let s={name:"transaction",attributes:{method:"$transaction"}};return this._tracingHelper.runInChildSpan(s,o)}_request(n){n.otelParentCtx=this._tracingHelper.getActiveContext();let i=n.middlewareArgsMapper??Vf,o={args:i.requestArgsToMiddlewareArgs(n.args),dataPath:n.dataPath,runInTransaction:!!n.transaction,action:n.action,model:n.model},s={operation:{name:"operation",attributes:{method:o.action,model:o.model,name:o.model?`${o.model}.${o.action}`:o.action}}},a=async l=&gt;{let{runInTransaction:u,args:c,...p}=l,d={...n,...p};c&amp;&amp;(d.args=i.middlewareArgsToRequestArgs(c)),n.transaction!==void 0&amp;&amp;u===!1&amp;&amp;delete d.transaction;let f=await il(this,d);return d.model?Xa({result:f,modelName:d.model,args:d.args,extensions:this._extensions,runtimeDataModel:this._runtimeDataModel,globalOmit:this._globalOmit}):f};return this._tracingHelper.runInChildSpan(s.operation,()=&gt;new gu.AsyncResource("prisma-client-request").runInAsyncScope(()=&gt;a(o)))}async _executeRequest({args:n,clientMethod:i,dataPath:o,callsite:s,action:a,model:l,argsMapper:u,transaction:c,unpacker:p,otelParentCtx:d,customDataProxyFetch:f}){try{n=u?u(n):n;let h={name:"serialize"},g=this._tracingHelper.runInChildSpan(h,()=&gt;Mn({modelName:l,runtimeDataModel:this._runtimeDataModel,action:a,args:n,clientMethod:i,callsite:s,extensions:this._extensions,errorFormat:this._errorFormat,clientVersion:this._clientVersion,previewFeatures:this._previewFeatures,globalOmit:this._globalOmit}));return N.enabled("prisma:client")&amp;&amp;(rr("Prisma Client call:"),rr(`prisma.${i}(${$a(n)})`),rr("Generated request:"),rr(JSON.stringify(g,null,2)+`
`)),c?.kind==="batch"&amp;&amp;await c.lock,this._requestHandler.request({protocolQuery:g,modelName:l,action:a,clientMethod:i,dataPath:o,callsite:s,args:n,extensions:this._extensions,transaction:c,unpacker:p,otelParentCtx:d,otelChildCtx:this._tracingHelper.getActiveContext(),globalOmit:this._globalOmit,customDataProxyFetch:f})}catch(h){throw h.clientVersion=this._clientVersion,h}}$metrics=new Nr(this);_hasPreviewFlag(n){return!!this._engineConfig.previewFeatures?.includes(n)}$applyPendingMigrations(){return this._engine.applyPendingMigrations()}$extends=Ya}return r}function mu(e,r){return Uf(e)?[new oe(e,r),Hl]:[e,Yl]}function Uf(e){return Array.isArray(e)&amp;&amp;Array.isArray(e.raw)}var Gf=new Set(["toJSON","$$typeof","asymmetricMatch",Symbol.iterator,Symbol.toStringTag,Symbol.isConcatSpreadable,Symbol.toPrimitive]);function Eu(e){return new Proxy(e,{get(r,t){if(t in r)return r[t];if(!Gf.has(t))throw new TypeError(`Invalid enum value: ${String(t)}`)}})}function wu(e){ot(e,{conflictCheck:"warn"})}0&amp;&amp;(module.exports={DMMF,Debug,Decimal,Extensions,MetricsClient,PrismaClientInitializationError,PrismaClientKnownRequestError,PrismaClientRustPanicError,PrismaClientUnknownRequestError,PrismaClientValidationError,Public,Sql,createParam,defineDmmfProperty,deserializeJsonResponse,deserializeRawResult,dmmfToRuntimeDataModel,empty,getPrismaClient,getRuntime,join,makeStrictEnum,makeTypedQueryFactory,objectEnumValues,raw,serializeJsonQuery,skip,sqltag,warnEnvConflicts,warnOnce});
/*! Bundled license information:
&nbsp;
decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.5.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin &lt;M8ch88l@gmail.com&gt;
   *  MIT Licence
   *)
*/
//# sourceMappingURL=library.js.map
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-09-04T13:03:40.328Z
            </div>
        <script src="../../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../../sorter.js"></script>
        <script src="../../../../../block-navigation.js"></script>
    </body>
</html>
    